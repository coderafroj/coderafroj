{
  "title": "PROGRAMMING",
  "slug": "cp-programming",
  "description": "Module from CP.pdf: PROGRAMMING",
  "tags": [
    "cp",
    "Elite"
  ],
  "content": "# PROGRAMMING\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n![Image](/src/assets/generated_images/cp_p1_i0.png)\n\n![Image](/src/assets/generated_images/cp_p1_i1.png)\n\n![Image](/src/assets/generated_images/cp_p1_i2.png)\nC PROGRAMMING \nPage 2 \n\n\nUNIT I \n\nComputer systems: \n\nA Computer is an electronic device which performs operations such as accepts data \nAs an input, store the data, manipulate or process the data and produce the results an output. \nMain task performed by a computer \n\u2022 Accept the data \n\u2022 Process or manipulate the data \n\u2022 Display or store the result in the form of human understanding \n\u2022 Store the data, instructions and results. \n\n\n\n\n\nA computer system consists of hardware and software. \n\nComputer hardware is the collection of physical elements that comprise a computer system. \n\n\n\nComputer software is a collection of computer programs and related data that provides the \ninstructions for a computer what to do and how to do it. Software refers to one or more computer \nprograms and data held in the storage of the computer for some purpose \n\n\n\nC PROGRAMMING \nPage 3 \n\n\n\n\nBasically computer software is of three main types \n\nSystem Software: System software is responsible for managing a variety of \nindependent hardware components, so that they can work together. Its purpose is \nto unburden the application software programmer from the often complex details of \nthe particular computer being used, including such accessories as communications \ndevices, printers, device readers, displays and keyboards, and also to partition the \ncomputer's resources such as memory and processor time in a safe and stable \nmanner. \n\u2022 Device drivers \n\u2022 Operating systems \n\u2022 Servers \n\u2022 Utilities \n\u2022 Window systems \n\nProgramming Software: Programming Software usually provides tools to assist a \nprogrammer in writing computer programs, and software using different \nprogramming languages in a more convenient way. The tools include: \n\u2022 Compilers \n\u2022 Debuggers \n\u2022 Interpreters \n\u2022 Linkers \n\u2022 Text editors \n\nApplication Software: Application software is developed to aid in any task that \nbenefits from computation. It is a broad category, and encompasses Software of \nmany kinds, including the internet browser being used to display this page. This \ncategory includes: \n\u2022 Business software \n\u2022 Computer aided design \n\u2022 Databases \n\u2022 Decision making software \n\u2022 Educational software \n\u2022 Image editing \n\n\nComputing Environment: \n\nComputing Environment is a collection of computers / machines, software, and networks that \nsupport the processing and exchange of electronic information meant to support various types of \ncomputing solutions. \n\nTypes of Computing Environments : \n\n\uf0b7 Personal Computing Environment \n\n\n![Image](/src/assets/generated_images/cp_p3_i0.png)\nC PROGRAMMING \nPage 4 \n\n\n\uf0b7 Client Server Environment \n\uf0b7 Time sharing Environment \n\uf0b7 Distributed Environment \n\nPersonal Computing Environment: \nAll of the computer hardware components are tied together in our personal \ncomputer. A personal computer ( PC ) is a computer whose original sales price, \nsize, and capabilities make it useful for individuals, and intended to be operated \ndirectly by an end user, with no intervening computer operator. People generally \nrelate this term with Microsoft\u201fs Windows Operating system. Personal computers \ngenerally run on Windows, Mac or some version of Linux operating system. \nDesktop: Desktop computer is just another version of Personal Computer intended \nfor regular use from a single use. A computer that can be fit on a desk can also be \ncalled as desktop. \n\n\n\n\nTime-Sharing Environment: \n\nIn the time-sharing environment, all computing must be done by the central computer. The \ncentral computer the shared resources, it manage the shared data and printing. Employees in \nlarge companies often work in what is known as time sharing environment. In the time sharing \nenvironment, many users are connected to one or more computers. These computers may be mini \ncomputers and central mainframes. In this environment the output devices, auxiliary storage \ndevices are shared by all the users. \n\n\n\n\n\n![Image](/src/assets/generated_images/cp_p4_i0.png)\n\n![Image](/src/assets/generated_images/cp_p4_i1.png)\nC PROGRAMMING \nPage 5 \n\n\n\n\nClient/Server Environment \nClient/Server computing environment splits the computing function between a \ncentral computer and user\u201fs computers. The users are given personal computers or \nwork stations so that some of the computation responsibility can be moved from \nthe central computer and assigned to the workstations. In the client/server \nenvironment the users micro computers or work stations are called the client. The \ncentral computer which may be a powerful micro computer, minicomputer or \ncentral mainframe system is known as server. \n\n\n\n\nDistributed Computing Environment \nA distributed computing environment provides a seamless integration of computing \nfunctions between different servers and clients. The internet provides connectivity \nto different servers throughout the world. This environment provides reliable, \nscalable and highly available network. \n\n\n![Image](/src/assets/generated_images/cp_p5_i0.png)\n\n![Image](/src/assets/generated_images/cp_p5_i1.png)\nC PROGRAMMING \nPage 6 \n\n\n\n\nCOMPUTER LANGUAGES \n\nIn order to communicate with the computer user also needs to have a language that should be \nunderstood by the computer. For this purpose, different languages are developed for performing \ndifferent types of work on the computer. Basically, languages are divided into two categories \naccording to their interpretation. \n\n\n\n1. Low Level Languages. \n\n2. High Level Languages. \n\nLow Level Languages \n\nLow level computer languages are machine codes or close to it. Computer cannot understand \ninstructions given in high level languages or in English. It can only understand and execute \ninstructions given in the form of machine language i.e. language of 0 and 1. There are two types \nof low level languages: \n\n\uf0b7 \nMachine Language. \n\n\uf0b7 \nAssembly Language \n\nMachine Language: It is the lowest and most elementary level of Programming language and \nwas the first type of programming language to be Developed. Machine Language is basically the \nonly language which computer Can understand. In fact, a manufacturer designs a computer to \nobey just one Language, its machine code, which is represented inside the computer by a String \nof binary digits (bits) 0 and 1. The symbol 0 stands for the absence of Electric pulse and 1 for the \n\n\n![Image](/src/assets/generated_images/cp_p6_i0.png)\nC PROGRAMMING \nPage 7 \n\n\npresence of an electric pulse . Since a computer is Capable of recognizing electric signals, \ntherefore, it understand machine Language. \n\n\n\n\n\nAdvantages of Machine Language \n\ni) It makes fast and efficient use of the computer. \n\nii) It requires no translator to translate the code i.e. Directly understood by the computer \n\nDisadvantages of Machine Language: \n\ni) All operation codes have to be remembered \n\niv) These languages are machine dependent i.e. a particular \n\nMachine language can be used on only one type of computer \n\nAssembly Language \n\nIt was developed to overcome some of the many inconveniences of machine language. This is \nanother low level but a very important language in which operation codes and operands are given \nin the form of alphanumeric symbols instead of 0\u201fs and l\u201fs. These alphanumeric symbols will be \nknown as mnemonic codes and can have maximum up to 5 letter combination e.g. ADD for \naddition, SUB for subtraction, START,LABEL etc. Because of this feature it is also known as \n\u201eSymbolic Programming Language\u201f. This language is also very difficult and needs a lot of \npractice to master it because very small \n\nEnglish support is given to this language. The language mainly helps in compiler orientations. \nThe instructions of the Assembly language will also be converted to machine codes by language \ntranslator to be executed by the computer. \n\n\n![Image](/src/assets/generated_images/cp_p7_i0.png)\nC PROGRAMMING \nPage 8 \n\n\n\n\nAdvantages of Assembly Language \n\ni) It is easier to understand and use as compared to machine language. \n\nii) It is easy to locate and correct errors. \n\niii) It is modified easily \n\nDisadvantages of Assembly Language \n\ni) Like machine language it is also machine dependent. \n\nii) Since it is machine dependent therefore programmer Should have the knowledge of the \nhardware also. \n\nHigh Level Languages \n\nHigh level computer languages give formats close to English language and the purpose of \ndeveloping high level languages is to enable people to write programs easily and in their own \nnative language environment (English). High-level languages are basically symbolic languages \nthat use English words and/or mathematical symbols rather than mnemonic codes. Each \ninstruction in the high level language is translated into many machine language instructions thus \nshowing one-to-many translation \n\nTypes of High Level Languages \n\nMany languages have been developed for achieving different variety of tasks, some are fairly \nspecialized others are quite general purpose. \n\nThese are categorized according to their use as \n\na) Algebraic Formula-Type Processing . These languages are oriented towards the \ncomputational procedures for solving mathematical and statistical problem \n\nExamples are \n\n\uf0b7 \nBASIC (Beginners All Purpose Symbolic Instruction Code). \n\n\uf0b7 \nFORTRAN (Formula Translation). \n\n\uf0b7 \nPL/I (Programming Language, Version 1). \n\n\uf0b7 \nALGOL (Algorithmic Language). \n\n\n![Image](/src/assets/generated_images/cp_p8_i0.png)\n\n![Image](/src/assets/generated_images/cp_p8_i1.png)\nC PROGRAMMING \nPage 9 \n\n\n\uf0b7 \nAPL (A Programming Language). \n\nb) Business Data Processing: \n\n\uf0b7 \nThese languages emphasize their capabilities for maintaining data processing procedures \nand files handling problems. Examples are: \n\n\uf0b7 \nCOBOL (Common Business Oriented Language). \n\n\uf0b7 \nRPG (Report Program Generator \n\nb) String and List Processing : These are used for string manipulation including search for \npatterns, inserting and deleting characters. Examples are: \n\n\uf0b7 \nLISP (List Processing). \n\n\uf0b7 \nProlog (Program in Logic). \n\nObject Oriented Programming Language \n\nIn OOP, the computer program is divided into objects. Examples are: \n\n\uf0b7 \nC++ \n\n\uf0b7 \nJava \n\ne) Visual programming language : these are designed for building Windows-based applications \nExamples are: \n\n\uf0b7 \nVisual Basic \n\n\uf0b7 \nVisual Java \n\n\uf0b7 \nVisual C \n\n\n\n\nAdvantages of High Level Language \n\nC PROGRAMMING \nPage 10 \n\n\nFollowing are the advantages of a high level language: \n\n\uf0b7 \nUser-friendly \n\n\uf0b7 \nSimilar to English with vocabulary of words and symbols \n\n\uf0b7 \nTherefore it is easier to learn. \n\n\uf0b7 \nThey are easier to maintain. \n\nDisadvantages of High Level Language \n\n\n\n\uf0b7 \nA high-level language has to be translated into the machine language by a translator and \nthus a price in computer time is paid. \n\n\uf0b7 \nThe object code generated by a translator might be inefficient Compared to an equivalent \nassembly language program \nCreating and Running Programs: \nThere are four steps in this process. \n\n1. Writing and editing the program using Text editor (source code). \n2. Compile the program using any C compiler.(.bak file) \n3. Linking the program with the required library modules(object file) \n4. Executing the program. (.Exe file) \n\nCreating and Editing a C Program in C Programming Language compiler: \nWriting or creating and editing source program is a first step in c language. Source \ncode is written in c programming language according to the type of problem or \nrequirement, in any text editor. \n\nSaving C Program in C Programming Language: Source code is saved on the \nsecondary storage. Source code is saved as text file. The extension of file must be \n\".c\". Example the file name is \"learn c programming language.c\" \n\nCompiling C program in C Programming Language: Computer does not \nunderstand c programming language. It understands only 0 and 1 means machine \nlanguage. So c programming language code is converted into machine language. \nThe process of converting source code in to machine code is called compiling. \nCompiler is a program that compiles source code. Compiler also detects errors in source \nprogram. If compiling is successful source program is converted into object program. Object \nprogram is saved on disk. The extension of file is \".obj\" \n\nLinking in C programming Language: There are many built in functions \navailable in c programming language. These functions are also called library \nfunctions. These functions are stored in different header files. \n\nLoading program: The process of transferring a program from secondary storage \nto main memory for execution is called loading a program. A program called loader \n\n\n![Image](/src/assets/generated_images/cp_p10_i0.png)\nC PROGRAMMING \nPage 11 \n\n\ndoes loading. \n\nExecuting program: Execution is the last step. In this step program starts \nexecution. Its instructions start working and output of the program display on the \nscreen. \n\n\n\n\nPseudocode : is an artificial and informal language that helps programmers develop \nalgorithms. Pseudocode is very similar to everyday English. \n\nAlgorithm: \n\nAn algorithm is a description of a procedure which terminates with a result. Algorithm is a \nstep-by-step method of solving a problem. \n\nProperties of an Algorithm: \n1) Finiteness: - An algorithm terminates after a finite numbers of steps. \n2) Definiteness: - Each step in algorithm is unambiguous. This means that the action \nspecified by the step cannot be interpreted (explain the meaning of) in multiple ways & can \nbe performed without any confusion. \n3) Input: - An algorithm accepts zero or more inputs \n4) Output:- An algorithm should produce at least one output. \n\nC PROGRAMMING \nPage 12 \n\n\n5) Effectiveness: - It consists of basic instructions that are realizable. This means that the \ninstructions can be performed by using the given inputs in a finite amount of time. \n\n\n\nWriting an algorithm \nAn algorithm can be written in English, like sentences and using mathematical \nformulas. Sometimes algorithm written in English like language is Pseudo code. \nExamples \n1) Finding the average of three numbers \n1. Let a,b,c are three integers \n2. Let d is float \n3. Display the message \u201cEnter any three integers:\u201d \n4. Read three integers and stores in a,b,c \n5. Compute the d = (a+b+c)/3.0 \n6. Display \u201cThe avg is:\u201d , d \n7. End. \n\n\uf06e Example 1: Write an algorithm to determine a student\u201fs final grade and indicate whether \n\nit is passing or failing. The final grade is calculated as the average of four marks. \n\nPseudocode :: \n\uf06e Input a set of 4 marks \n\uf06e Calculate their average by summing and dividing by 4 \n\uf06e if average is below 50 \n\n\nPrint \u201cFAIL\u201d \n\nelse \n\n\nPrint \u201cPASS\u201d \n\n\uf06e Detailed Algorithm : \n\uf06e \nStep 1: \nInput M1,M2,M3,M4 \n\n\nStep 2: \nGRADE \uf0ac (M1+M2+M3+M4)/4 \n\n\nStep 3: \nif (GRADE < 50) then \n\n\n\n\n\nPrint \u201cFAIL\u201d \n\n\n\nelse \n\n\n\n\n\nPrint \u201cPASS\u201d \n\n\n\n\nendif \n\nFlowcharts : \n\nThe pictorial representation of algorithm is called flowchart. \n\nUses of  flow chart: \n\n1 : flow chart helps to understand the program easily. \n\n2 : as different symbols are used to specify the type of operation performed, it is easier to \nunderstand the complex programs with the help of flowcharts. \n\n\n![Image](/src/assets/generated_images/cp_p12_i0.png)\n\n![Image](/src/assets/generated_images/cp_p12_i1.png)\nC PROGRAMMING \nPage 13 \n\n\nFlowchart Symbols \n\nS.NO Description \nSymbols \n\n1 \nFlowlines : These are the left to right or top to \nbottom lines connection symbols. These lines \nshows the flow of control through the program. \n\n\n\n2 \nTerminal Symbol : The oval shaped symbol \nalways begins and ends the flowchart. Every \nflow chart starting and ending symbol is \nterminal symbol. \n\n\n\n3 \nInput / Output symbol : The parallelogram is \nused for both input (Read) and Output (Write) \nis called I/O symbol. This symbol is used to \ndenote any function of an I/O device in the \nprogram. \n\n\n\n4 \nProcess Symbol : The rectangle symbol is called \nprocess symbol. It is used for calculations and \ninitialization of memory locations. \n\n\n\n5 \nDecision symbol : The diamond shaped symbol \nis called decision symbol. This box is used for \ndecision making. There will be always two \nexists from a decision symbol one is labeled YES \nand other labeled  NO. \n\n\n6 \nConnectors \n: \nThe \nconnector \nsymbol \nis \nrepresented by a circle. Whenever a complex \nflowchart is morethan one page, in such a \nsituation, the connector symbols are used to \nconnect the flowchart. \n\n\n\nAlgorithm to find whether a number even or odd: \n\nStep1: Begin \n\n\nStep1: START \nStep2: Take a number \n\n\nStep2: Read num \nStep3: if the number is divisible by2 then \nStep3: if(num%2=0) then \n\nprint that number is even \n\n\nprint num is even \notherwise print that number is odd \notherwise \n\nStart \n\nEnd \n\n\n![Image](/src/assets/generated_images/cp_p13_i0.png)\n\n![Image](/src/assets/generated_images/cp_p13_i1.png)\n\n![Image](/src/assets/generated_images/cp_p13_i2.png)\n\n![Image](/src/assets/generated_images/cp_p13_i3.png)\n\n![Image](/src/assets/generated_images/cp_p13_i4.png)\n\n![Image](/src/assets/generated_images/cp_p13_i5.png)\n\n![Image](/src/assets/generated_images/cp_p13_i6.png)\n\n![Image](/src/assets/generated_images/cp_p13_i7.png)\nC PROGRAMMING \nPage 14 \n\n\n\n\n\n\n\n\nprint num is odd \nStep4: End \n\n\n\nStep4: STOP \n(Algorithm in natural language) \n\n(Algorithm by using pseudo code) \n\n\n\n\n\n\n\n\n\n\n\n\n\nFLOWCHART : \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSystem Development: \n\n\nt \nt \n\nread num \n\nIf \n\nprint num \n\nis even \n\nprint num \n\nis odd \n\nt \n\n\n![Image](/src/assets/generated_images/cp_p14_i0.png)\n\n![Image](/src/assets/generated_images/cp_p14_i1.png)\n\n![Image](/src/assets/generated_images/cp_p14_i2.png)\n\n![Image](/src/assets/generated_images/cp_p14_i3.png)\n\n![Image](/src/assets/generated_images/cp_p14_i4.png)\n\n![Image](/src/assets/generated_images/cp_p14_i5.png)\n\n![Image](/src/assets/generated_images/cp_p14_i6.png)\nC PROGRAMMING \nPage 15 \n\n\n\n\n\nOr \n\n\n\n\n\n\n\n\n1. Statement of Problem \n\na) Working with existing system and using proper questionnaire, the problem should be \nexplained \nclearly. \nb) What inputs are available, what outputs are required and what is needed for creating workable \nsolution, should be understood clearly. \n\n\nSystems Requirements \n\nAnalysis \n\nDesign \n\nCoding \n\nSystem Test \n\nMaintenance \n\nC PROGRAMMING \nPage 16 \n\n\n2. Analysis \na) The method of solutions to solve the problem can be identified. \nb) We also judge that which method gives best results among different methods of solution. \n\n3. Design \na) Algorithms and flow charts will be prepared. \nb) Focus on data, architecture, user interfaces and program components. \n\n4. System Test \nThe algorithms and flow charts developed in the previous steps are converted into actual \nprograms in the high level languages like C. \n\na. Compilation \nThe process of translating the program into machine code is called as Compilation. Syntactic \nerrors are found quickly at the time of compiling the program. These errors occur due to the \nusage of wrong syntaxes for the statements. \nEg: x=a*y+b \nThere is a syntax error in this statement, since, each and every statement in C language ends with \na semicolon (;). \n\nb. Execution \nThe next step is Program execution. In this phase, we may encounter two types of errors. \nRuntime Errors: these errors occur during the execution of the program and terminate the \nprogram abnormally. \nLogical Errors: these errors occur due to incorrect usage of the instructions in the program. These \nerrors are neither detected during compilation or execution nor cause any stoppage to the \nprogram execution but produces incorrect output. \n\n5. Maintenance \nWe are maintenance the software by updating the information, providing the security and license \nfor the software. \n\nWhat is C? \n\nC is a programming language developed at AT & T\u201fs Bell Laboratories of USA in 1972 .  It \nwas designed and written by Dennis Ritche . Dennis Ritchie is known as the founder of c \nlanguage . \n\nIt was developed to overcome the problems of previous languages such as B, BCPL etc. \n\nInitially, C language was developed to be used in UNIX operating system. \n\n\nFeatures of C \n\n1. Portability or machine independent \n\nC PROGRAMMING \nPage 17 \n\n\n2. Sound and versatile language \n3. Fast program execution. \n4. An extendible language. \n5. Tends to be a structured language. \nHistorical developments of C(Background) \nYear \nLanguage \nDeveloped by \nRemarks \n\n1960 \nALGOL \nInternational committee Too general, too abstract \n\n1967 \nBCPL \nMartin \nRichards \nat \nCambridge university \n\nCould deal with only specific \nproblems \n\n1970 \nB \nKen Thompson at AT & \nT \n\nCould deal with only specific \nproblems \n\n1972 \nC \nDennis Ritche at AT & T \nLost generality of BCPL and B \nrestored \n\n\n\nGeneral Structure of a C program: \n\n\n/* Documentation section */ \n/* Link section */ \n/* Definition section */ \n/* Global declaration section */ \nmain() \n{ \nDeclaration part \nExecutable part (statements) \n} \n/* Sub-program section */ \n\n\uf0d8\uf020 The documentation section is used for displaying any information about the \nprogram like the purpose of the program, name of the author, date and time written \netc, and this section should be enclosed within comment lines. The statements in \nthe documentation section are ignored by the compiler. \n\n\uf0d8\uf020 The link section consists of the inclusion of header files. \n\nC PROGRAMMING \nPage 18 \n\n\n\uf0d8\uf020 The definition section consists of macro definitions, defining constants etc,. \n\n\uf0d8\uf020 Anything declared in the global declaration section is accessible throughout \nthe program, i.e. accessible to all the functions in the program. \n\n\uf0d8\uf020 main() function is mandatory for any program and it includes two parts, the \ndeclaration part and the executable part. \n\n\uf0d8\uf020 The last section, i.e. sub-program section is optional and used when we require \nincluding user defined functions in the program. \n\nFirst C Program \n\nBefore starting the abcd of C language, you need to learn how to write, compile and run the first \nc program. \n\nTo write the first c program, open the C console and write the following code: \n\n1. #include <stdio.h> \n2. #include <conio.h> \n3. void main(){ \n4. printf( \"Hello C Language\" ); \n5. getch(); \n6. } \n\n#include <stdio.h> includes the standard input output library functions. The printf() function \nis defined in stdio.h . \n\n#include <conio.h> includes the console input output library functions. The getch() function is \ndefined in conio.h file. \n\nvoid main() The main() function is the entry point of every program in c language. The void \nkeyword specifies that it returns no value. \n\nprintf() The printf() function is used to print data on the console. \n\ngetch() The getch() function asks for a single character . Until you press any key, it blocks the \nscreen. \n\nC TOKENS : The smallest individual units are known as tokens. C has six types of tokens. \n\n1: Identifiers \n\nC PROGRAMMING \nPage 19 \n\n\n2: Keywords \n\n3: Constants \n\n4: Strings \n\n5: Special Symbols \n\n6: Operators \n\nIdentifiers : \n\nIdentifiers refer to the names of variables, constants, functions and arrays. These are user-defined \nnames is called Identifiers. These identifier are defined against a set of rules. \n\nRules for an Identifier \n\n1. An Identifier can only have alphanumeric characters( a-z , A-Z , 0-9 ) and underscore( _ \n\n). \n\n2. The first character of an identifier can only contain alphabet( a-z , A-Z ) or underscore ( _ \n\n). \n\n3. Identifiers are also case sensitive in C. For example name and Name are two different \n\nidentifier in C. \n\n4. Keywords are not allowed to be used as Identifiers. \n\n5. No special characters, such as semicolon, period, whitespaces, slash or comma are \n\npermitted to be used in or as Identifier. \n\n6. C\u201f compiler recognizes only the first 31 characters of an identifiers. \n\n\n\n\n\nEx : Valid                                     Invalid \n\nSTDNAME                              Return \n\nSUB                                          $stay \n\nTOT_MARKS                          1RECORD \n\n_TEMP                                     STD NAME. \n\nY2K \n\n\n![Image](/src/assets/generated_images/cp_p19_i0.png)\nC PROGRAMMING \nPage 20 \n\n\nKeywords: A keyword is a reserved word . All keywords have fixed meaning that means  we \ncannot change. Keywords serve as basic building blocks for program statements. All keywords \nmust be written in lowercase. A list of 32 keywords in c language is given below: \n\nauto                    break                             case                             char \n\nconst                   continue                        default                        do \n\ndouble                enum                              else                             extern \n\nfloat                    for                                  goto                             if \n\nint                       long                                return                         register \n\nsigned                 short                              static                           sizeof \n\nstruct                  switch                            typedef                       union \n\nunsigned             void                                volatile                       while \n\n\n\nNote: Keywords we cannot use it as a variable name, constant name etc. \n\n\n\nData Types/Types: \n\n\uf0b7 \nTo store data the program must reserve space which is done using datatype. A datatype is a \nkeyword/predefined instruction used for allocating memory for data. A data type specifies \nthe type of data that a variable can store such as integer, floating, character etc . It used for \ndeclaring/defining variables or functions of different types before to use in a program. \n\n\n\n\nThere are 4 types of data types in C language. \n\n\n![Image](/src/assets/generated_images/cp_p20_i0.png)\nC PROGRAMMING \nPage 21 \n\n\nTypes \nData Types \n\nBasic Data Type \nint, char, float, double \n\nDerived Data Type \narray, pointer, structure, union \n\nEnumeration Data Type \nenum \n\nVoid Data Type \nvoid \n\nNote: \nWe \ncall \nBasic \nor \nPrimary \ndata \ntype. \n\n\n\nThe basic data types are integer-based and floating-point based. C language supports both signed \nand unsigned literals. The memory size of basic data types may change according to 32 or 64 bit \noperating system. Let\u201fs see the basic data types. Its size is given according to 32 bit \narchitecture . \n\nSize and Ranges of Data Types with Type Qualifiers \n\nType \nSize (bytes) \nRange \nControl String \n\nchar or signed char \n1 \n-128 to 127 \n%c \n\nunsigned char \n1 \n0 to 255 \n%c \n\nC PROGRAMMING \nPage 22 \n\n\nint or signed int \n2 \n-32768 to 32767 \n%d or %i \n\nunsigned int \n2 \n0 to 65535 \n%u \n\nshort int or signed short \nint \n\n1 \n-128 to 127 \n%d or %i \n\nunsigned short int \n1 \n0 to 255 \n%d or %i \n\nlong int or signed long \nint \n\n4 \n-2147483648 to 2147483647 \n%ld \n\nunsigned long int \n4 \n0 to 4294967295 \n%lu \n\nfloat \n4 \n3.4E-38 to 3.4E+38 \n%f or %g \n\ndouble \n8 \n1.7E-308 to 1.7E+308 \n%lf \n\nlong double \n10 \n3.4E-4932 to 1.1E+4932 \n%Lf \n\n\n\nVariables \n\nA variable is a name of memory location. It is used to store data. Variables are changeable, \n\nwe can change value of a variable during execution of a program. . It can be reused many \ntimes. \n\nNote: Variable are nothing but identifiers. \n\n\nRules to write variable names: \n1. A variable name contains maximum of 30 characters/ Variable \n\nname must be upto 8 characters. \n2. A variable name includes alphabets and numbers, but it must start \n\nwith an alphabet. \n3. It cannot accept any special characters, blank spaces except under \n\nscore( _ ). \n4. It should not be a reserved word. \n\nEx :         i     rank1        MAX    min   Student_name \nStudentName           class_mark \n\nC PROGRAMMING \nPage 23 \n\n\n\n\nDeclaration of Variables : A variable can be used to store a value of any data type. The \ndeclaration of variables must be done before they are used in the program. The general format \nfor declaring a variable. \n\nSyntax : data_type   variable-1,variable-2,------, variable-n; \nVariables are separated by commas and declaration statement ends with a semicolon. \n\nEx :  int x,y,z; \nfloat a,b; \nchar m,n; \n\n\nAssigning values to variables : values can be assigned to variables using the assignment \noperator (=). The general format statement is : \n\nSyntax :  variable = constant; \n\nEx : x=100; \na=  12.25; \nm=\u201ff\u201f; \n\nwe can also assign a value to a variable at the time of the variable is declared. The general format \nof declaring and assigning value to a variable is : \n\nSyntax  : data_type variable = constant; \n\nEx ;     int x=100; \nfloat a=12.25; \nchar m=\u201ff\u201f; \n\n\nTypes of Variables in C \n\nThere are many types of variables in c: \n\n1. local variable \n2. global variable \n3. static variable \n\nConstants \n\nConstants refer to fixed values that do not change during the execution of a program. \n\nNote: constants are also called literals. \n\n\n![Image](/src/assets/generated_images/cp_p23_i0.png)\n\n![Image](/src/assets/generated_images/cp_p23_i1.png)\n\n![Image](/src/assets/generated_images/cp_p23_i2.png)\n\n![Image](/src/assets/generated_images/cp_p23_i3.png)\n\n![Image](/src/assets/generated_images/cp_p23_i4.png)\n\n![Image](/src/assets/generated_images/cp_p23_i5.png)\n\n![Image](/src/assets/generated_images/cp_p23_i6.png)\nC PROGRAMMING \nPage 24 \n\n\nC supports several kinds of constants . \n\n\n\n\n\nTYPES OF C CONSTANT: \n\n1. Integer constants \n2. Real or Floating point constants \n3. Character constants \n4. String constants \n5. Backslash character constants \n\n\nInteger constants: \n\nAn integer constant is a numeric constant (associated with number) without any fractional or \nexponential part. There are three types of integer constants in C programming: \n\n\uf0b7 \ndecimal constant(base 10) \n\uf0b7 \noctal constant(base 8) \n\uf0b7 \nhexadecimal constant(base 16 ) \n\nFor example: \n\n\uf0b7 \nDecimal constants: 0, -9, 22 etc \n\uf0b7 \nOctal constants: 021, 077, 033 etc \n\uf0b7 \nHexadecimal constants: 0x7f, 0x2a, 0x521 etc \n\n\uf0b7 \nIn C programming, octal constant starts with a 0 and hexadecimal constant starts with a \n0x. \n\n\nCONSTANTS \n\nNumeric Constants \n\nCharacter Constants \n\nInteger Constants \n\nReal Constants \n\nSingle Character Constants \n\nString Constants \n\nC PROGRAMMING \nPage 25 \n\n\n1: Decimal Integer : the rules for represent decimal integer. \n\na) Decimal Integer value which consist of digits from 0-9. \nb) Decimal Integer value with base 10. \nc) Decimal Integer should not prefix with 0. \nd) It allows only sign (+,-). \ne) No special character allowed in this integer. \n\n\nEx :   valid                  invalid \n\n7                      $77 \n\n77                      077 \n\n+77                      7,777 \n\n-77 \n\n2 : Octal : An  integer constants with base 8 is called octal. These rules are : \n\n\na) it consist of digits from 0 to 7. \nb) It should prefix with 0. \nc) It allows sign (+,-). \nd) No special character is allowed. \n\nEX  :               VALID                                   INVALID \n0123                                     123   -> it because no prefix with 0 \n+0123                                    0128  -> because digits from 0 to 7. \n-0123 \n\n3 : Hexadecimal  : An integer constant with base value 16 is called Hexadecimal. \n\n\na) It consist of digits from 0-9,a-f(capital letters & small leters. \n\nEx : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \nb) it should prefix with 0X or 0x. \nc) it allows sign (+,-). \nd) No special character is allowed. \n\nEX  : OX1a, ox2f \n\n\nFloating point/Real constants: \n\nA floating point constant is a numeric constant that has either a fractional form or an exponent \nform. For example : \n\nC PROGRAMMING \nPage 26 \n\n\n- 2.0 \n\n0.0000234 \n\n-0.22E-5 \n\nNote: E-5 = 10- 5 \n\nReal Constants : Real constant is base 10 number, which is represented in decimal 0r \nscientific/exponential notation. \n\nReal Notation : The real notation is represented by an integer followed by a decimal point and \nthe fractional(decimal) part. It is possible to omit digits before or after the decimal point. \n\nEx :  15.25 \n.75 \n30 \n-9.52 \n-92 \n+.94 \n\n\nScientific/Exponential Notation : The general form of Scientific/Exponential notation is \n\nmantisha e exponent \n\nThe mantisha is either a real/floating point number expressed in decimal notation or an integer \nand the exponent is an integer number with an optional sign. The character e separating the \nmantisha and the exponent can be written in either lowercase or uppercase. \n\nEx :  1.5E-2 \n100e+3 \n-2.05e2 \n\nCharacter Constant: \n\nSingle Character Constant : A character constant is either a single alphabet, a single digit, a \nsingle special symbol enclosed within single inverted commas. \n\n\na) it is value represent in \u201e \u201e (single quote). \nb) The maximam length of a character constant can be 1 character. \nEX :        VALID                               INVALID \n\u201ea\u201f                                        \u201c12\u201d \n\nC PROGRAMMING \nPage 27 \n\n\n\u201eA\u201f                                        \u201eab\u201f \nString constant : A string constant is a sequence of characters enclosed in double quote, the \ncharacters may be letters, numbers, special characters and blank space etc \n\n\nEX : \u201crama\u201d , \u201ca\u201d , \u201c+123\u201d , \u201c1-/a\u201d \n\n\"good\"                  //string constant \n\n\"\"                       //null string constant \n\n\"      \"                //string constant of six white space \n\n\"x\"                        //string constant having single character. \n\n\"Earth is round\\n\"         //prints string with newline \n\nEscape characters or backslash characters: \n\na)   \\n              newline \nb)   \\r               carriage return \nc)   \\t               tab \nd)  \\v               vertical tab \ne)   \\b               backspace \nf)   \\f                form feed (page feed) \ng)  \\a                alert (beep) \nh)  \\\u201f                single quote(\u201e) \ni)   \\\u201d               double quote(\u201c) \nj)   \\?               Question mark (?) \nk)   \\\\               backslash (\\) \n\nTwo ways to define constant in C \nThere are two ways to define constant in C programming. \n\n1. const keyword \n2. #define preprocessor \n3. \n1) C const keyword \nThe const keyword is used to define constant in C programming. \n\n1. const float PI=3.14; \nNow, the value of PI variable can't be changed. \n\n1. #include <stdio.h> \n2. #include <conio.h> \n3. void main(){ \n4. const float PI=3.14; \n5. clrscr(); \n6. printf(\"The value of PI is: %f\",PI); \n\nC PROGRAMMING \nPage 28 \n\n\n7. getch(); \n8. } \nOutput: \nThe value of PI is: 3.140000 \n\n2) C #define preprocessor \n\nThe #define preprocessor is also used to define constant. \n\nC#define \nThe #define preprocessor directive is used to define constant or micro substitution. It can use any \nbasic data type. \nSyntax: \n#define token value \nLet's see an example of #define to define a constant. \n#include <stdio.h> \n\n1. #define PI 3.14 \n2. main() { \n3. printf(\"%f\",PI); \n4. } \nOutput: \n3.140000 \n\nFormatted and Unformatted Console I/O Functions . \n\nInput / Output (I/O) Functions : In \u201eC\u201f language, two types of Input/Output functions are \navailable, and all input and output operations are carried out through function calls. Several \nfunctions are available for input / output operations in \u201eC\u201f. These functions are collectively \nknown as the standard i/o library. \nInput: In any programming language input means to feed some data into program. This can be \ngiven in the form of file or from command line. \nOutput: In any programming language output means to display some data on screen, printer or \nin any file. \nThe Standard Files \n\nC programming treats all the devices as files. So devices such as the display are addressed in the \nsame way as files and the following three files are automatically opened when a program \n\nexecutes to provide access to the keyboard and screen. \n\nStandard File \nFile Pointer \nDevice \n\nStandard input \nstdin \nKeyboard \n\n\n![Image](/src/assets/generated_images/cp_p28_i0.png)\n\n![Image](/src/assets/generated_images/cp_p28_i1.png)\n\n![Image](/src/assets/generated_images/cp_p28_i2.png)\n\n![Image](/src/assets/generated_images/cp_p28_i3.png)\n\n![Image](/src/assets/generated_images/cp_p28_i4.png)\nC PROGRAMMING \nPage 29 \n\n\nStandard output \nstdout \nScreen \n\nStandard error \nstderr \nYour screen \n\nInput / Output functions are classified into two types \n\n\n. Formated I/O Functions : formatted I/O functions operates on various types of data. \n\n1 : printf() : output data or result of an operation can be displayed from the computer to a \nstandard output device using the library function printf(). This function is used to print any \ncombination of data. \n\nSyntax : printf(\u201ccontrol string \u201c, variable1, variable2, -----------, variablen); \n\nEx : printf(\u201c%d\u201d,3977); \n// Output : 3977 \nprintf() statement another syntax : \n\nSyntax : printf( \u201cfomating string\u201d); \n\nFormating string : it prints all the character given in doublequotes (\u201c \u201c) except formatting \nspecifier. \n\n\nI / O Functions \n\nFormated I/O Functions \n\nUnformated I/O Functions \n\nInput                Output \n\n\n\nscanf()             print() \n\nfscanf()           fprintf() \n\nInput                   Output \n\n\n\ngetc()                 putc() \n\ngetchar()            putchar() \n\ngets()                 puts() \n\ngetch() \n\ngetche() \n\nC PROGRAMMING \nPage 30 \n\n\nEx : printf(\u201c hello \u201c);-> hello \nprintf(\u201ca\u201d); -> a \nprintf(\u201c%d\u201d, a); -> a value \nprintf(\u201c%d\u201d); -> no display \n\nscanf() : input data can be entered into the computer using the standard input \u201eC\u201f library \nfunction called scanf(). This function is used to enter any combination of input. \n\nSyntax : scanf(\u201ccontrol string \u201c,&var1, &var2,----, &varn); \n\nThe scanf() function is used to read information from the standard input device (keyboard). \n\nEx : scanf(\u201c %d \u201c,&a);-> hello \n\n\nEach variable name (argument) must be preceeded by an ampersand (&). The (&) symbol gives \nthe meaning \u201caddress of \u201c the variable. \n\nUnformatted I/O functions: \n\na) Character I/O \nb) String I/O \n\n\na) character I/O: \n\n1. getchar():  Used to read a character from the standard input \n2. putchar():  Used to display a character to standard output \n3. getch() and getche():  these are used to take the any alpha numeric characters \nfrom the standard input \ngetche() read and  display the character \ngetch() only read the single character but not display \n4. putch(): Used to display any alpha numeric characters to standard output \n\n\na) String I/O: \n\n1. gets(): Used for accepting any string from the standard input(stdin) \n\neg:gets() \n\n\n2. puts(): Used to display a string or character array                 Eg:puts() \n3. Cgets():read a string from the console                eg;   cgets(char *st) \n4. Cputs():display the string to the console            eg;   cputs(char *st) \n\n\n\nC PROGRAMMING \nPage 31 \n\n\nOPERATORS AND EXPRESSIONS: \nOperators  : An operator is a Symbol that performs an operation. An operators acts some \nvariables are called operands to get the desired result. \n\nEx : a+b; \nWhere a,b are operands    and   + is the operator. \n\n\nTypes of Operator : \n1) Arithmetic Operators. \n\n2) Relational Operators. \n3) Logical Operators. \n4) Assignment Operators. \n5). Unary Operators. \n6) Conditional Operators. \n7) Special Operators. \n8) Bitwise Operators. \n9)  Shift Operators. \n\n\n\nArithmetic Operators \nAn arithmetic operator performs mathematical operations such as addition, subtraction and \nmultiplication on numerical values (constants and variables). \nC Program to demonstrate the working of arithmetic operators \n#include <stdio.h> \nvoid  main() \n{ \nint a = 9,b = 4, c; \n\nc = a+b; \nprintf(\"a+b = %d \\n\",c); \n\nc = a-b; \nprintf(\"a-b = %d \\n\",c); \n\nc = a*b; \nprintf(\"a*b = %d \\n\",c); \n\nc=a/b; \nprintf(\"a/b = %d \\n\",c); \n\nc=a%b; \nprintf(\"Remainder when a divided by b = %d \\n\",c); \n\n\n} \n\nC PROGRAMMING \nPage 32 \n\n\nOutput \na+b = 13 \na-b = 5 \na*b = 36 \na/b = 2 \nRemainder when a divided by b=1 \n\n\n\nRelational Operators . A relational operator checks the relationship between two operands. \nIf the relation is true, it returns 1; if the relation is false, it returns value 0. \nOperands may be variables, constants or expressions. \n\nRelational operators are used in decision making and loops . \n\n\n\nOperator \nMeaning \nExample \nReturn value \n< \nis less than \n2<9 \n1 \n< = \nis less than or equal to \n2 < = 2 \n1 \n> \nis greater than \n2 > 9 \n0 \n> = \nis greater than or equal to \n3 > = 2 \n1 \n= = \nis equal to \n2 = = 3 \n0 \n!= \nis not equal to \n2!=2 \n0 \n\n// C Program to demonstrate the working of relational operators \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint a = 5, b = 5, c = 10; \n\nprintf(\"%d == %d = %d \\n\", a, b, a == b); // true \n\nprintf(\"%d == %d = %d \\n\", a, c, a == c); // false \n\nprintf(\"%d > %d = %d \\n\", a, b, a > b); //false \n\nprintf(\"%d > %d = %d \\n\", a, c, a > c); //false \n\nC PROGRAMMING \nPage 33 \n\n\nprintf(\"%d < %d = %d \\n\", a, b, a < b); //false \n\nprintf(\"%d < %d = %d \\n\", a, c, a < c); //true \n\nprintf(\"%d != %d = %d \\n\", a, b, a != b); //false \n\nprintf(\"%d != %d = %d \\n\", a, c, a != c); //true \n\nprintf(\"%d >= %d = %d \\n\", a, b, a >= b); //true \n\nprintf(\"%d >= %d = %d \\n\", a, c, a >= c); //false \n\nprintf(\"%d <= %d = %d \\n\", a, b, a <= b); //true \n\nprintf(\"%d <= %d = %d \\n\", a, c, a <= c); //true \n\nreturn 0; \n\n} \n\nOutput \n\n5 == 5 = 1 \n\n5 == 10 = 0 \n\n5 > 5 = 0 \n\n5 > 10 = 0 \n\n5 < 5 = 0 \n\n5 < 10 = 1 \n\n5 != 5 = 0 \n\n5 != 10 = 1 \n\n5 >= 5 = 1 \n\n5 >= 10 = 0 \n\nC PROGRAMMING \nPage 34 \n\n\n5 <= 5 = 1 \n\n5 <= 10 = 1 \n\n\n\nLogical Operators. \n\nThese operators are used to combine the results of two or more conditions. An expression \ncontaining logical operator returns either 0 or 1 depending upon whether expression results true \nor false. Logical operators are commonly used in decision making in C programming . \n\nOperator \nMeaning \nExample \nReturn value \n&& \nLogical AND \n(9>2)&&(17>2) \n1 \n|| \nLogical OR \n(9>2) || (17 = = 7) \n1 \n! \nLogical NOT \n29!=29 \n0 \nLogical AND : If any one condition false the complete condition becomes false. \n\nTruth Table \n\nOp1 \nOp2 \nOp1 && Op2 \ntrue \ntrue \ntrue \ntrue \nfalse \nfalse \nfalse \ntrue \nfalse \nfalse \nfalse \nfalse \n\nLogical OR : If any one condition true the complete condition becomes true. \n\nTruth Table \n\nOp1 \nOp2 \nOp1 // Op2 \ntrue \ntrue \ntrue \ntrue \nfalse \ntrue \nfalse \ntrue \ntrue \nfalse \nfalse \nfalse \n\n\nLogical Not  : This operator reverses the value of the expression it operates on i.e, it makes a \ntrue expression false and false expression true. \n\n\nOp1 \nOp1 ! \ntrue \nfalse \nfalse \ntrue \n\n// C Program to demonstrate the working of logical operators \n\n#include <stdio.h> \n\nC PROGRAMMING \nPage 35 \n\n\nint main() \n\n{ \n\nint a = 5, b = 5, c = 10, result; \n\nresult = (a = b) && (c > b); \n\nprintf(\"(a = b) && (c > b) equals to %d \\n\", result); \n\nresult = (a = b) && (c < b); \n\nprintf(\"(a = b) && (c < b) equals to %d \\n\", result); \n\nresult = (a = b) || (c < b); \n\nprintf(\"(a = b) || (c < b) equals to %d \\n\", result); \n\nresult = (a != b) || (c < b); \n\nprintf(\"(a != b) || (c < b) equals to %d \\n\", result); \n\nresult = !(a != b); \n\nprintf(\"!(a == b) equals to %d \\n\", result); \n\nresult = !(a == b); \n\nprintf(\"!(a == b) equals to %d \\n\", result); \n\nreturn 0; \n\n} \n\nOutput \n\n(a = b) && (c > b) equals to 1 \n\n(a = b) && (c < b) equals to 0 \n\n(a = b) || (c < b) equals to 1 \n\nC PROGRAMMING \nPage 36 \n\n\n(a != b) || (c < b) equals to 0 \n\n!(a != b) equals to 1 \n\n!(a == b) equals to 0 \n\n\n\nAssignment Operators. Assignment operators are used to assign a value (or) an expression \n(or) a value of a variable to another variable. \n\nSyntax : variable name=expression (or) value (or) variable \n\nEx : x=10; \ny=a+b; \nz=p; \n\nCompound assignment operator: \n\n\u201eC\u201f provides compound assignment operators to assign a value to variable in order to assign a \nnew value to a variable after performing a specified operation. \n\n\nOperator \nExample Meaning \n+ = \nx + = y \nx=x+y \n- = \nx - = y \nx=x-y \n* = \nx * = y \nx=x*y \n/ = \nx / = y \nx=x/y \n% = \nx % = y \nX=x%y \n\n\n\n// C Program to demonstrate the working of assignment operators \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint a = 5, c; \n\nc = a; \n\nC PROGRAMMING \nPage 37 \n\n\nprintf(\"c = %d \\n\", c); \n\nc += a; // c = c+a \n\nprintf(\"c = %d \\n\", c); \n\nc -= a; // c = c-a \n\nprintf(\"c = %d \\n\", c); \n\nc *= a; // c = c*a \n\nprintf(\"c = %d \\n\", c); \n\nc /= a; // c = c/a \n\nprintf(\"c = %d \\n\", c); \n\nc %= a; // c = c%a \n\nprintf(\"c = %d \\n\", c); \n\nreturn 0; \n\n} \n\nOutput \n\nc = 5 \n\nc = 10 \n\nc = 5 \n\nc = 25 \n\nc = 5 \n\nc = 0 \n\nIncrement and Decrement Operators /Unary Operators: \n\nC PROGRAMMING \nPage 38 \n\n\nUnary operators are having higher priority than the other operators. Unary operators , meaning \nthey only operate on a single operand. \n\nIncrement Operator in C Programming \n\n1. Increment operator is used to increment the current value of variable by adding integer 1. \n\n2. Increment operator can be applied to only variables. \n\n3. Increment operator is denoted by ++. \n\nWe have two types of increment operator i.e Pre-Increment and Post-Increment Operator . \n\nPre-Increment \n\nPre-increment operator is used to increment the value of variable before using in the expression. In \nthe Pre-Increment value is first incremented and then used inside the expression. \n\nb = ++y; \n\nIn this example suppose the value of variable \u201ey\u201f is 5 then value of variable \u201eb\u201f will be 6 because \nthe value of \u201ey\u201f gets modified before using it in a expression . \n\nPost-Increment \n\nPost-increment operator is used to increment the value of variable as soon as after executing \nexpression completely in which post increment is used. In the Post-Increment value is first used \nin a expression and then incremented. \n\nb = x++; \n\nIn this example suppose the value of variable \u201ex\u201f is 5 then value of variable \u201eb\u201f will be 5 because \nold value of \u201ex\u201f is used. \n\n\n\n\n\nNote : \n\nWe cannot use increment operator on the constant values because increment operator operates on \nonly variables. It increments the value of the variable by 1 and stores the incremented value back \nto the variable \n\nC PROGRAMMING \nPage 39 \n\n\nb = ++5; \n\nor \n\nb = 5++; \n\n\n\nThe syntax of the operators is given below. \n\n++<variable name>                   --<variable name> \n<variable name>++                    <variable name>-- \nThe operator ++ adds 1 to the operand and \u2013 subtracts 1 from the operand. These  operators in \ntwo forms : prefix (++x) and postfix(x++). \n\n\nOperator \nMeaning \n++x \nPre increment \n- -x \nPre decrement \nx++ \nPost increment \nx-- \nPost decrement \n\nWhere \n1 : ++x : Pre increment, first increment and then do the operation. \n2 : - -x  : Pre decrement, first decrements and then do the operation. \n3 : x++ : Post increment, first do the operation and then increment. \n4 : x- -  : Post decrement, first do the operation and then decrement. \n\n// C Program to demonstrate the working of increment and decrement operators \n#include <stdio.h> \nint main() \n{ \nint a = 10, b = 100; \nfloat c = 10.5, d = 100.5; \nprintf(\"++a = %d \\n\", ++a); \nprintf(\"--b = %d \\n\", --b); \nprintf(\"++c = %f \\n\", ++c); \nprintf(\"--d = %f \\n\", --d); \nreturn 0; \n} \n\nOutput \n++a = 11 \n--b = 99 \n++c = 11.500000 \n++d = 99.500000 \n\n\n![Image](/src/assets/generated_images/cp_p39_i0.png)\nC PROGRAMMING \nPage 40 \n\n\n\n\nMultiple increment operators inside printf \n\n#include<stdio.h> \nvoid main() { \nint i = 1; \nprintf(\"%d %d %d\", i, ++i, i++); \n} \nOutput :  3 3 1 \n\n\nPictorial representation \n\n\nExplanation of program \n\nI am sure you will get confused after viewing the above image and output of program. \n\n1. Whenever more than one format specifiers (i.e %d) are directly or indirectly related with \n\nsame variable (i,i++,++i) then we need to evaluate each individual expression from right \nto left. \n2. As shown in the above image evaluation sequence of expressions written inside printf \n\nwill be \u2013 i++,++i,i \n3. After execution we need to replace the output of expression at appropriate place \n\nNo \nStep \nExplanation \n\n1 \nEvaluate \ni++ \nAt the time of execution we will be using older value of i = 1 \n\n2 \nEvaluate \n++i \n\nAt the time of execution we will be increment value already modified after \nstep 1 i.e i = 3 \n\n2 \nEvaluate i \nAt the time of execution we will be using value of i modified in step 2 \n\n\n\n\n\n![Image](/src/assets/generated_images/cp_p40_i0.png)\nC PROGRAMMING \nPage 41 \n\n\n\n\nPostfix and Prefix Expression in Same Statement \n#include<stdio.h> \n#include<conio.h> \nvoid main() { \nint i = 0, j = 0; \nj = i++ + ++i; \nprintf(\"%d\\n\", i); \nprintf(\"%d\\n\", j); \n} \n\nOutput : \n2 \n2 \n\nExplanation of Program \n\n\n\n\n\nConditional Operator/ Ternary operator: \nconditional operator checks the condition and executes the statement depending of the condition. \nA conditional operator is a ternary operator, that is, it works on 3 operands. \nConditional operator consist of two symbols. \n\n1 : question mark (?). \n2 : colon ( : ). \n\n\nC PROGRAMMING \nPage 42 \n\n\nSyntax : condition ? exp1 : exp2; \n\nIt first evaluate the condition, if it is true (non-zero)  then the \u201cexp1\u201d is \nevaluated, if the condition is false (zero) then the \u201cexp2\u201d is evaluated. \n\n#include <stdio.h> \nint main(){ \nchar February; \nint days; \nprintf(\"If this year is leap year, enter 1. If not enter any integer: \"); \nscanf(\"%c\",&February); \n// If test condition (February == 'l') is true, days equal to 29. \n// If test condition (February =='l') is false, days equal to 28. \ndays = (February == '1') ? 29 : 28; \nprintf(\"Number of days in February = %d\",days); \nreturn 0; \n} \n\nOutput \nIf this year is leap year, enter 1. If not enter any integer: 1 \nNumber of days in February = 29 \n\n\nBitwise Operators: \nBitwise operators are used to manipulate the data at bit level. It operates on integers only. It \nmay not be applied to float. In arithmetic-logic unit (which is within the CPU), mathematical \noperations like: addition, subtraction, multiplication and division are done in bit-level which \nmakes processing faster and saves power. To perform bit-level operations in C programming, \nbitwise operators are used. \n\nOperator \nMeaning \n& \nBitwise AND \n| \nBitwise OR \n^ \nBitwise XOR \n< < \nShift left \n> > \nShift right \n~ \nOne\u201fs complement. \n\n\nBitwise AND operator & \n\nThe output of bitwise AND is 1 if the corresponding bits of two operands is 1. If either bit of an \noperand is 0, the result of corresponding bit is evaluated to 0. \n\nLet us suppose the bitwise AND operation of two integers 12 and 25. \n12 = 00001100 (In Binary) \n25 = 00011001 (In Binary) \n\nC PROGRAMMING \nPage 43 \n\n\n\nBit Operation of 12 and 25 \n00001100 \n& 00011001 \n________ \n00001000  = 8 (In decimal) \nExample #1: Bitwise AND \n#include <stdio.h> \nint main() \n{ \nint a = 12, b = 25; \nprintf(\"Output = %d\", a&b); \nreturn 0; \n} \nOutput \nOutput =8 \n\n\nBitwise OR operator | \n\nThe output of bitwise OR is 1 if at least one corresponding bit of two operands is 1. In C \nProgramming, bitwise OR operator is denoted by |. \n\n12 = 00001100 (In Binary) \n\n25 = 00011001 (In Binary) \n\nBitwise OR Operation of 12 and 25 \n\n00001100 \n\n| 00011001 \n\n________ \n\n00011101  = 29 (In decimal) \n\nExample #2: Bitwise OR \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint a = 12, b = 25; \n\nprintf(\"Output = %d\", a|b); \n\nreturn 0; \n\nC PROGRAMMING \nPage 44 \n\n\n} \n\nOutput \nOutput =29 \n\n\nBitwise XOR (exclusive OR) operator ^ \n\nThe result of bitwise XOR operator is 1 if the corresponding bits of two operands are opposite. It \nis denoted by ^. \n\n12 = 00001100 (In Binary) \n\n25 = 00011001 (In Binary) \n\nBitwise XOR Operation of 12 and 25 \n\n00001100 \n\n| 00011001 \n\n________ \n\n00010101  = 21 (In decimal) \n\nExample #3: Bitwise XOR \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint a = 12, b = 25; \n\nprintf(\"Output = %d\", a^b); \n\nreturn 0; \n\n} \n\nOutput \n\nOutput = 21 \n\nBitwise complement operator ~ \n\nBitwise compliment operator is an unary operator (works on only one operand). It changes 1 to 0 \nand 0 to 1. It is denoted by ~. \n\n35 = 00100011 (In Binary) \n\nBitwise complement Operation of 35 \n\nC PROGRAMMING \nPage 45 \n\n\n~ 00100011 \n\n________ \n\n11011100  = 220 (In decimal) \n\nTwist in bitwise complement operator in C Programming \n\nThe bitwise complement of 35 (~35) is -36 instead of 220, but why? \n\nFor any integer n, bitwise complement of n will be -(n+1). To understand this, you should have \nthe knowledge of 2's complement . \n\n2's Complement \n\nTwo's complement is an operation on binary numbers. The 2's complement of a number is equal \nto the complement of that number plus 1. For example: \n\nDecimal         Binary           2's complement \n\n0            00000000           -(11111111+1) = -00000000 = -0(decimal) \n\n1            00000001           -(11111110+1) = -11111111 = -256(decimal) \n\n12           00001100           -(11110011+1) = -11110100 = -244(decimal) \n\n220          11011100           -(00100011+1) = -00100100 = -36(decimal) \n\nNote: Overflow is ignored while computing 2's complement. \n\nThe bitwise complement of 35 is 220 (in decimal). The 2's complement of 220 is -36. Hence, the \noutput is -36 instead of 220. \n\nBitwise complement of any number N is -(N+1). Here's how: \n\nbitwise complement of N = ~N (represented in 2's complement form) \n\n2'complement of ~N= -(~(~N)+1) = -(N+1) \n\n\n\nExample #4: Bitwise complement \n\n#include <stdio.h> \n\nC PROGRAMMING \nPage 46 \n\n\nint main() \n\n{ \n\nprintf(\"complement = %d\\n\",~35); \n\nprintf(\"complement = %d\\n\",~-12); \n\nreturn 0; \n\n} \n\nOutput \n\nComplement = -36 \n\nComplement = 11 \n\nThere are two Bitwise shift operators in C programming: \n\n\uf0b7 \nRight shift operator \n\uf0b7 \nLeft shift operator. \n\nRight Shift Operator \n\nRight shift operator shifts all bits towards right by certain number of specified bits. It is denoted \nby >>. \n\nLeft Shift Operator \n\nLeft shift operator shifts all bits towards left by certain number of specified bits. It is denoted by \n<<. \n\nSpecial Operators \n\n1 ) Comma Operator : The comma operator is used to separate the statement elements such as \nvariables, constants or expressions, and this operator is used to link the related expressions \ntogether, such expressions can be evaluated from left to right and the value of right most \nexpressions is the value of combined expressions \n\nEx :  val(a=3, b=9, c=77, a+c) \nFirst signs the value 3 to a, then assigns 9 to b, then assigns 77 to c, and finaly80(3+77) to \nvalue. \n\nC PROGRAMMING \nPage 47 \n\n\n\n2 ) Sizeof Operator : The sizeof() is a unary operator, that returns the length in bytes o the \nspecified variable, and it is very useful to find the bytes occupied by the specified variable in the \nmemory. \n\nSyntax : sizeof(variable-name); \n\nint a; \nEx : sizeof(a); //OUTPUT-----2bytes \n\nExample #6: sizeof Operator \n#include <stdio.h> \nint main() \n{ \nint a, e[10]; \nfloat b; \ndouble c; \nchar d; \nprintf(\"Size of int=%lu bytes\\n\",sizeof(a)); \nprintf(\"Size of float=%lu bytes\\n\",sizeof(b)); \nprintf(\"Size of double=%lu bytes\\n\",sizeof(c)); \nprintf(\"Size of char=%lu byte\\n\",sizeof(d)); \nprintf(\"Size of integer type array having 10 elements = %lu bytes\\n\", sizeof(e)); \nreturn 0; \n} \nOutput \n\nSize of int = 4 bytes \nSize of float = 4 bytes \nSize of double = 8 bytes \nSize of char = 1 byte \nSize of integer type array having 10 elements = 40 bytes \n\n\n\nExpressions \n\nExpressions : An expression is a combination of operators and operands which reduces to a \nsingle value. An operator indicats an operation to be performed on data that yields a value. An \noperand is a data item on which an operation is performed. \n\nA simple expression contains only one operator. \n\nEx : 3+5 is a simple expression which yields a value 8,   -a is also a single expression. \nA complex expression contain more than one operator. \n\n\nC PROGRAMMING \nPage 48 \n\n\nEx : complex expression is 6+8*7. \n\nEx ;      Algeberic Expressions                                 C-expression \n1 : ax2+bx+c                                               1:  a*x*x+b*x+c \n2 : a+bx                                                       2 : a+b*x. \n3 : 4ac/b                                                      3 : 4*a*c/b. \n4 : x2/y2-1                                                  4 : x*x/y*y-1 \n\nOperator Precedence : Arithmetic Operators are evaluvated left to right using the \nprecedence of operator when the expression is written without the paranthesis.They are two \nlevels of arithmetic operators in C. \n\n1 : High Priority    *  /   % \n2 : Low  Priority    +   -. \n\nArithmetic Expression evaluation is carried out using the two phases from left to right. \n\n1 : First phase : The highest priority operator are evaluated in the 1 st phase. \n2 : Second Phase : The lowest priority operator are evaluated in the 2 nd phase. \n\nEx : a=x-y/3+z*2+p/4. \nx=7,  y=9,  z=11,  p=8. \na= 7-9/3+11*2+8/4. \n\n1 st phase : \n1 : a = 7-3+11*2+8/4 \n2 : a = 7-3+22+8/4 \n3 : a = 7-3+22+2 \n2 nd phase : \n1 : a = 4+22+2 \n2 : a = 26+2 \n3 : a = 28 \n\nThe order of evaluation can be changed by putting paranthesis in an expression. \n\nEx : 9-12/(3+3)*(2-1) \n\nWhenever parentheses are used, the expressions within parantheses highest priority. If two or \nmore sets of paranthesis appear one after another. The expression contained in the left-most set is \nevaluated first and the right-most in the last. \n1 st phase : \n1 : 9-12/6*(2-1) \n2 : 9-12/6*1 \n2 nd phase : \n1 : 9-2*1 \n2 : 9-2. \n3 rd phase : \n\nC PROGRAMMING \nPage 49 \n\n\n1 : 7. \n\nRules for Evaluation of Expression : \n\n1 : Evaluate the sub-expression from left to right. If parenthesized. \n2 : Evaluate the arithemetic Expression from left to right using the rules of precedence. \n3 : The highest precedence is given to the expression with in paranthesis. \n4 : When parantheses are used, the expressions within parantheses assume highest priority. \n5 : Apply the associative rule, if more operators of the same precedence occurs. \n\n\nOperator Precedence and Associativity : \n\nEvery operator has a precedence value. An expression containing more than one \noerator is known as complex expression. Complex expressions are executed according to \nprecedence of operators. \n\nAssociativity specifies the order in which the operators are evaluated with the same \nprecedence in a complex expression. Associativity is of two ways, i.e left to ringht and right to \nleft. Left to right associativity evaluates an expression starting from left and moving towards \nright. Right to left associativity proceds from right to left. \n\n\nThe precedence and associativity of various operators in C. \nOperator \nDescription \nPrecedence \nAssociativity \n( ) \n[ ] \n\nFunction call \nSquare brackets. \n\n1 \nL-R (left to right) \n\n+ \n\n- \n++ \n\n-- \n\n! \n~ \n* \n& \nsizeof \n\nUnary plus \nUnary minus \n\nIncrement \nDecrement \nNot operator \nComplement \nPointer operator \nAddress operator \n\nSizeof operator \n\n2 \nR-L (right to left) \n\n* \n/ \n% \n\nMultiplication \n\nDivision \nModulo division \n\n3 \nL-R (left to right) \n\n+ \n\n- \n\nAddition \nSubtraction \n\n4 \nL-R (left to right) \n\n<< \n>> \n\nLeft shift \nRight shift \n\n5 \nL-R (left to right) \n\nC PROGRAMMING \nPage 50 \n\n\n<  <=  >  >= \nRelational Operator \n6 \nL-R (left to right) \n= = \n\n!= \n\nEquality \nInequality \n\n7 \nL-R (left to right) \n\n& \nBitwise AND \n8 \nL-R (left to right) \n^ \nBitwise XOR \n9 \nL-R (left to right) \n| \nBitwise OR \n10 \nL-R (left to right) \n&& \nLogical AND \n11 \nL-R (left to right) \n| | \nLogical OR \n12 \nL-R (left to right) \n?: \nConditional \n13 \nR-L (right to left) \n= *= /= %= += \n-= &=  ^=  <<= \n\n>>= \n\nAssignment operator \n14 \nR-L (right to left) \n\n, \nComma operator \n15 \nL-R (left to right) \n\nType Conversion/Type casting: \nType conversion is used to convert variable from one data type to another data type, and after \ntype casting complier treats the variable as of new data type. \nFor example, if you want to store a 'long' value into a simple integer then you can type cast \n'long' to 'int'. You can convert the values from one type to another explicitly using the cast \noperator. Type conversions can be implicit which is performed by the compiler automatically, \nor it can be specified explicitly through the use of the cast operator. \n\nSyntax: \n(type_name) expression; \n\nWithout Type Casting: \n\n1. int f= 9/4; \n2. printf( \"f : %d\\n\" , f ); //Output: 2 \n\nWith Type Casting: \n\n1. float f=( float ) 9/4; \n2. printf( \"f : %f\\n\" , f ); //Output: 2.250000 \n\n\n\nExample: \n\n#include <stdio.h> \n\nint main() \n\nC PROGRAMMING \nPage 51 \n\n\n{ \n\nprintf( \"%c\\n\", (char)65 ); \n\ngetchar(); \n\n} \n\nor \n\nType Casting - C Programming \n\nType casting refers to changing an variable of one data type into another. The compiler will \nautomatically change one type of data into another if it makes sense. For instance, if you assign \nan integer value to a floating-point variable, the compiler will convert the int to a float. Casting \nallows you to make this type conversion explicit, or to force it when it wouldn\u201ft normally \nhappen. \n\n\n\nType conversion in c can be classified into the following two types: \n\n1. Implicit Type Conversion \n\nWhen the type conversion is performed automatically by the compiler without programmers \nintervention, such type of conversion is known as implicit type conversion or type promotion. \n\nint x; \n\nfor(x=97; x<=122; x++) \n\n{ \n\nprintf(\"%c\", x);   /*Implicit casting from int to char thanks to %c*/ \n\n} \n\n2. Explicit Type Conversion \n\nThe type conversion performed by the programmer by posing the data type of the expression of \nspecific type is known as explicit type conversion. The explicit type conversion is also known as \ntype casting. \n\nC PROGRAMMING \nPage 52 \n\n\nType casting in c is done in the following form: \n\n(data_type)expression; \n\nwhere, data_type is any valid c data type, and expression may be constant, variable or \nexpression. \n\nFor example, \n\nint x; \n\nfor(x=97; x<=122; x++) \n\n{ \n\nprintf(\"%c\", (char)x);   /*Explicit casting from int to char*/ \n\n} \n\nThe following rules have to be followed while converting the expression from one type to \nanother to avoid the loss of information: \n\n\n\nAll integer types to be converted to float. \n\nAll float types to be converted to double. \n\nAll character types to be converted to integer. \n\nExample \n\nConsider the following code: \n\nint x=7, y=5 ; \n\nfloat z; \n\nz=x/y; /*Here the value of z is 1*/ \n\nIf we want to get the exact value of 7/5 then we need explicit casting from int to float: \n\nC PROGRAMMING \nPage 53 \n\n\nint x=7, y=5; \n\nfloat z; \n\nz = (float)x/(float)y;   /*Here the value of z is 1.4*/ \n\n\n\nInteger Promotion \n\nInteger promotion is the process by which values of integer type \"smaller\" than int or unsigned \nint are converted either to int or unsigned int. Consider an example of adding a character with an \ninteger \u2212 \n\n#include <stdio.h> \n\nmain() \n\n{ \n\nint  i = 17; \n\nchar c = 'c'; /* ascii value is 99 */ \n\nint sum; \n\nsum = i + c; \n\nprintf(\"Value of sum : %d\\n\", sum ); \n\n} \n\nWhen the above code is compiled and executed, it produces the following result \u2212 \n\nValue of sum : 116 \n\nHere, the value of sum is 116 because the compiler is doing integer promotion and \nconverting the value of 'c' to ASCII before performing the actual addition operation. \n\nUsual Arithmetic Conversion \n\n\n![Image](/src/assets/generated_images/cp_p53_i0.png)\nC PROGRAMMING \nPage 54 \n\n\nThe usual arithmetic conversions are implicitly performed to cast their values to a common \ntype. The compiler first performs integer promotion ; if the operands still have different types, \nthen they are converted to the type that appears highest in the following hierarchy \u2013 \n\n\n\nUNIT II \n\n\n\nSTATEMENTS \n\nA statement causes the computer to carry out some definite action. There are three different \nclasses of statements in C: \n\nExpression statements , C ompound statements , and C ontrol statements . \n\n\n\n\n![Image](/src/assets/generated_images/cp_p54_i0.png)\nC PROGRAMMING \nPage 55 \n\n\nNull statement \n\nA null statement consisting of only a semicolon and performs no operations . It can appear \nwherever a statement is expected. Nothing happens when a null statement is executed. \n\nSyntax: - ; \n\n\n\n\n\nStatements such as do , for , if , and while require that an executable statement appear as the \nstatement body. The null statement satisfies the syntax requirement in cases that do not need a \nsubstantive statement body. \n\nThe Null statement is nothing but, there is no body within loop or any other statements in \nC. \n\nExample illustrates the null statement: \n\nfor ( i = 0; i < 10; i++) ; \n\nor \n\n\n\nfor (i=0;i<10;i++) \n\n{ \n\nC PROGRAMMING \nPage 56 \n\n\n//empty body \n\n} \n\nExpression \n\nMost of the statements in a C program are expression statements . An expression statement is \nsimply an expression followed by a semicolon. The lines \n\n\ni = 0; \n\n\ni = i + 1; \n\nand \nprintf(\"Hello, world!\\n\"); \n\nare all expression statements. In C, however, the semicolon is a statement terminator. Expression \nstatements do all of the real work in a C program. Whenever you need to compute new values for \nvariables, you'll typically use expression statements (and they'll typically contain assignment \noperators). Whenever you want your program to do something visible, in the real world, you'll \ntypically call a function (as part of an expression statement). We've already seen the most basic \nexample: calling the function printf to print text to the screen. \n\nNote - If no expression is present, the statement is often called the null statement . \n\nReturn \n\nThe return statement terminates execution of a function and returns control to the calling \nfunction, with or without a return value. A function may contain any number \nof return statements. The return statement has \n\nsyntax: return expression (opt); \n\nIf present, the expression is evaluated and its value is returned to the calling function. If \nnecessary, its value is converted to the declared type of the containing function's return value. \n\nA return statement with an expression cannot appear in a function whose return type is void . If \nthere is no expression and the function is not defined as void , the return value is undefined. For \nexample, the following main function returns an unpredictable value to the operating \nsystem: \n\nmain ( ) \n\n{ \n\n\n![Image](/src/assets/generated_images/cp_p56_i0.png)\nC PROGRAMMING \nPage 57 \n\n\nreturn; \n\n} \n\nCompound statements \n\nA compound statement (also called a \"block\") typically appears as the body of another statement, \nsuch as the if statement, for statement, while statement, etc \n\nA Compound statement consists of several individual statements enclosed within a pair of \nbraces { }. The individual statements may themselves be expression statements, compound \nstatements or control statements. Unlike expression statements, a compound statement does not \nend with a semicolon. A typical Compound statement is given below. \n\n{ \n\npi=3.14; \n\narea=pi*radius*radius; \n\n} \n\nThe particular compound statement consists of two assignment-type expression \nstatements. \n\nExample: \n\n\n\nC PROGRAMMING \nPage 58 \n\n\n\n\nSelection Statement/Conditional Statements/Decision Making Statements \n\nA selection statement selects among a set of statements depending on the value of a controlling \nexpression.       Or \n\nMoving execution control from one place/line to another line based on condition \n\nOr \n\nConditional statements control the sequence of statement execution, depending on the value of a \ninteger expression \n\nC\u201f language supports two conditional statements. \n\n1: if \n\n2: switch. \n\n1: if Statement: The if Statement may be implemented in different forms. \n\n1: simple if statement. \n\n2: if \u2013else statement \n\n3: nested if-else statement. \n\n4: else if ladder. \n\nif statement. \n\nThe  if statement controls conditional branching. The body of an if statement is executed if the \nvalue of the expression is nonzero.  Or    if statement is used to execute the code if condition \nis true. If the expression/condition is evaluated to false (0), statements inside the body of if is \nskipped from execution . \n\nSyntax : if(condition/expression) \n\n{ \n\ntrue statement; \n\n\n![Image](/src/assets/generated_images/cp_p58_i0.png)\nC PROGRAMMING \nPage 59 \n\n\n} \n\nstatement-x; \n\nIf the condition/expression is true, then the true statement will be executed otherwise the true \nstatement block will be skipped and the execution will jump to the statement-x. The \u201etrue \nstatement\u201f may be a single statement or group of statement. \n\nIf there is only one statement in the if block, then the braces are optional. But \nif there is more than one statement the braces are compulsory \n\n\n\nFlowchart \n\n\n\n\n\n\n\nExample: \n\n#include<stdio.h> \n\nmain() \n\n{ \n\nint a=15,b=20; \n\nC PROGRAMMING \nPage 60 \n\n\nif(b>a) \n\n{ \n\nprintf(\"b is greater\"); \n\n} \n\n} \n\nOutput \n\nb is greater \n\n#include <stdio.h> \nint main() \n{ \nint number; \n\nprintf(\"Enter an integer: \"); \nscanf(\"%d\", &number); \n\n// Test expression is true if number is less than 0 \nif (number < 0) \n{ \nprintf(\"You entered %d.\\n\", number); \n} \n\nprintf(\"The if statement is easy.\"); \n\nreturn 0; \n} \nOutput 1 \nEnter an integer: -2 \nYou entered -2. \nThe if statement is easy. \n\nOutput 2 \nEnter an integer: 5 \nThe if statement in C programming is easy. \n\nIf-else statement : The if-else statement is an extension of the simple if statement. The \ngeneral form is. The if...else statement executes some code if the test expression is true (nonzero) \nand some other code if the test expression is false (0). \n\n\n\n![Image](/src/assets/generated_images/cp_p60_i0.png)\nC PROGRAMMING \nPage 61 \n\n\nSyntax : if (condition) \n{ \ntrue statement; \n} \nelse \n{ \nfalse statement; \n} \nstatement-x; \n\nIf the condition is true , then the true statement and statement-x will be executed and if the \ncondition is false, then the false statement and statement-x is executed. \nOr \nIf test expression is true, codes inside the body of if statement is executed and, codes inside the \nbody of else statement is skipped. \nIf test expression is false, codes inside the body of else statement is executed and, codes inside \nthe body of if statement is skipped. \n\nFlowchart \n\n\nExample: \n// Program to check whether an integer entered by the user is odd or even \n\n#include <stdio.h> \nint main() \n{ \n\nC PROGRAMMING \nPage 62 \n\n\nint number; \nprintf(\"Enter an integer: \"); \nscanf(\"%d\",&number); \n\n// True if remainder is 0 \nif( number%2 == 0 ) \nprintf(\"%d is an even integer.\",number); \nelse \nprintf(\"%d is an odd integer.\",number); \nreturn 0; \n} \nOutput \nEnter an integer: 7 \n7 is an odd integer. \n\n\nNested if-else statement \n\nWhen a series of decisions are involved, we may have to use more than on if-else statement in \nnested form. If \u2013else statements can also be nested inside another if block or else block or both. \n\n\n\nSyntax : if(condition-1) \n\n{                                                                  { \n\nif (condition-2) \n\n{ \n\nstatement-1; \n\n} \n\nelse \n\n{ \n\nstatement-2; \n\n} \n\n} \n\nelse \n\n{ \n\nstatement-3; \n\n\n![Image](/src/assets/generated_images/cp_p62_i0.png)\nC PROGRAMMING \nPage 63 \n\n\n} \n\nstatement-x; \n\nIf the condition-1 is false, the  statement-3 and statement-x will be executed. Otherwise it \ncontinues to perform the second test. If the condition-2 is true, the true statement-1 will be \nexecuted otherwise the statement-2 will be executed and then the control is transferred to the \nstatement-x \n\nFlowchart \n\n\n\n\n\nExample \n#include<stdio.h> \nint var1, var2; \nprintf(\"Input the value of var1:\"); \nscanf(\"%d\", &var1); \nprintf(\"Input the value of var2:\"); \nscanf(\"%d\",&var2); \nif (var1 !=var2) \n{ \nprintf(\"var1 is not equal to var2\"); \n//Below \u2013 if-else is nested inside another if block \nif (var1 >var2) \n{ \nprintf(\"var1 is greater than var2\"); \n} \nelse \n{ \nprintf(\"var2 is greater than var1\"); \n} \n} \nelse \n\nC PROGRAMMING \nPage 64 \n\n\n{ \nprintf(\"var1 is equal to var2\"); \n} \n\u2026 \n\nElse if ladder. \nThe if else-if statement is used to execute one code from multiple conditions . \nSyntax : if( condition-1) \n{ \nstatement-1; \n} \nelse if(condition-2) \n{ \nstatement-2; \n} \nelse if(condition-3) \n{ \nstatement-3; \n} \nelse if(condition-n) \n{ \nstatement-n; \n} \nelse \n{ \ndefault-statement; \n} \nstatement-x; \n\nFlowchart \n\n\n\n![Image](/src/assets/generated_images/cp_p64_i0.png)\nC PROGRAMMING \nPage 65 \n\n\n\n\nExample \n\n#include<stdio.h> \n\n#include<conio.h> \nvoid main(){ \nint number=0; \nclrscr(); \nprintf(\"enter a number:\"); \nscanf(\"%d\",&number); \nif(number==10){ \nprintf(\"number is equals to 10\"); \n} \nelse if(number==50){ \nprintf(\"number is equal to 50\"); \n} \nelse if(number==100){ \nprintf(\"number is equal to 100\"); \n} \nelse{ \nprintf(\"number is not equal to 10, 50 or 100\"); \n} \ngetch(); \n} \n\n\n\n\nC PROGRAMMING \nPage 66 \n\n\n\nPoints to Remember \n\n1. In if statement, a single statement can be included without enclosing it into curly braces { } \n2. int a = 5; \n\n3. if(a > 4) \n\n4. printf(\"success\"); \n\nNo curly braces are required in the above case, but if we have more than one statement \n\ninside if condition, then we must enclose them inside curly braces. \n\n5. == must be used for comparison in the expression of if condition, if you use = the expression will \n\nalways return true, because it performs assignment not comparison. \n\n6. Other than 0(zero) , all other values are considered as true. \n7. if(27) \n\n8. printf(\"hello\"); \n\nIn above example, hello will be printed. \n\n\n\nSwitch statement : when there are several options and we have to choose only one option \nfrom the available ones, we can use switch statement. Depending on the selected option, a \nparticular task can be performed. A task represents one or more statements. \n\nSyntax: \nswitch( expression ) \n{ \ncase value-1: \n\nstatement/block-1; \n\nbreak; \ncase value-2: \n\nstatement/block t-2; \n\nbreak; \ncase value-3: \n\nstatement/block -3; \n\nbreak; \ncase value-4: \n\nstatement/block -4; \n\nbreak; \ndefault: \n\ndefault- statement/block t; \n\nbreak; \n\nC PROGRAMMING \nPage 67 \n\n\n} \n\n\nThe expression following the keyword switch in any \u201eC\u201f expression that must yield an integer \nvalue. It must be ab integer constants like 1,2,3 . \n\nThe keyword case is followed by an integer or a character constant, each constant in each \nmust be different from all the other. \n\nFirst the integer expression following the keyword switch is evaluated. The value it gives \nis searched against the constant values that follw the case statements. When a match is found, the \nprogram executes the statements following the case. If no match is found with any of the case \nstatements, then the statements follwing the default are executed. \n\nRules for writing switch() statement. \n1 : The expression in switch statement must be an integer value or a character constant. \n2 : No real numbers are used in an expression. \n3 : The default is optional and can be placed anywhere, but usually placed at end. \n4 : The case keyword must terminate with colon ( : ). \n5 : No two case constants are identical. \n6 : The case labels must be constants. \n\n\n\nValid Switch \nInvalid Switch \nValid Case \nInvalid Case \n\nswitch(x) \nswitch(f) \ncase 3; \ncase 2.5; \n\nswitch(x>y) \nswitch(x+2.5) \ncase 'a'; \ncase x; \n\nswitch(a+b-2) \n\ncase 1+2; \ncase x+2; \n\nswitch(func(x,y)) \n\ncase 'x'>'y'; \ncase 1,2,3; \n\n\n\nExample \n#include<stdio.h> \nmain() \n{ \nint a; \nprintf(\"Please enter a no between 1 and 5: \"); \nscanf(\"%d\",&a); \nswitch(a) \n{ \ncase 1: \nprintf(\"You chose One\"); \nbreak; \ncase 2: \n\n\n![Image](/src/assets/generated_images/cp_p67_i0.png)\n\n![Image](/src/assets/generated_images/cp_p67_i1.png)\nC PROGRAMMING \nPage 68 \n\n\nprintf(\"You chose Two\"); \nbreak; \ncase 3: \nprintf(\"You chose Three\"); \nbreak; \ncase 4: \nprintf(\"You chose Four\"); \nbreak; \ncase 5: printf(\"You chose Five.\"); \nbreak; \ndefault : \nprintf(\"Invalid Choice. Enter a no between 1 and 5\"); break; \n} \n} \n\n\n\n\nFlowchart \n\n\n\nC PROGRAMMING \nPage 69 \n\n\nPoints to Remember \n\nIt  isn't necessary to use break after each block, but if you do not use it, all the consecutive block \n\nof codes will get executed after the matching block. \n\n1. int i = 1; \n\n2. switch(i) \n\n3. { \n\n4. case 1: \n\n5. printf(\"A\");        // No break \n\n6. case 2: \n\n7. printf(\"B\");        // No break \n\n8. case 3: \n\n9. printf(\"C\"); \n\n10. break; \n\n11. } \n\nOutput : A B C \n\nThe output was supposed to be only A because only the first case matches, but as there is no \n\nbreak statement after the block, the next blocks are executed, until the cursor encounters a \n\nbreak. \n\ndefault case can be placed anywhere in the switch case. Even if we don't include the default case \n\nswitch statement works. \n\nIteration Statements/ Loop Control Statements \n\nHow it Works \n\n\n![Image](/src/assets/generated_images/cp_p69_i0.png)\nC PROGRAMMING \nPage 70 \n\n\n\n\nA sequence of statements are executed until a specified condition is true. This sequence of \n\nstatements to be executed is kept inside the curly braces { } known as the Loop body. After \n\nevery execution of loop body, condition is verified, and if it is found to be true the loop body is \n\nexecuted again. When the condition check returns false, the loop body is not executed. \n\nThe loops in C language are used to execute a block of code or a part of the program several \ntimes.  In other words, it iterates/repeat a code or group of code many times . \n\nOr Looping means a group of statements are executed repeatedly, until some logical condition \nis satisfied . \n\nWhy use loops in C language? \n\nSuppose that you have to print table of 2, then you need to write 10 lines of code.By using the \n\nloop statement, you can do it by 2 or 3 lines of code only. \n\nA looping process would include the following four steps. \n\n1 : Initialization of a condition variable. \n\n2 : Test the condition. \n\n3 : Executing the body of the loop depending on the condition. \n\n4 : Updating the condition variable. \n\n\n\n\n\nC PROGRAMMING \nPage 71 \n\n\nC language provides three iterative/repetitive loops. \n\n1 : while loop \n\n2 : do-while loop \n\n3 : for loop \n\nWhile Loop: S yntax : \n\nvariable initialization ; \n\nwhile (condition) \n\n{ \n\nstatements ; \n\nvariable increment or decrement ; \n\n} \n\nwhile loop can be addressed as an entry control loop. It is completed in 3 steps. \n\n\uf0b7 \nVariable initialization.( e.g int x=0; ) \n\n\uf0b7 \ncondition( e.g while( x<=10) ) \n\n\uf0b7 \nVariable increment or decrement ( x++ or x-- or x=x+2 ) \n\n\n\nThe while loop is an entry controlled loop statement, i.e means the condition is evaluated \nfirst and it is true, then the body of the loop is executed. After executing the body of the loop, \nthe condition is once again evaluated and if it is true, the body is executed once again, the \nprocess of repeated execution of the loop continues until the condition finally becomes false and \nthe control is transferred out of the loop. \n\nExample : Program to print first 10 natural numbers \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main( ) \n\n{ \n\nC PROGRAMMING \nPage 72 \n\n\nint x; \n\nx=1; \n\nwhile(x<=10) \n\n{ \n\nprintf(\"%d\\t\", x); \n\nx++; \n\n} \n\ngetch(); \n\n} \n\nOutput \n\n1 2 3 4 5 6 7 8 9 10 \n\n\n\n\n\n\n\nC Program to reverse number \n\n#include<stdio.h> \n\n#include<conio.h> \n\nmain() \n\n{ \n\nint n, reverse=0, rem; \n\nclrscr(); \n\nprintf(\"Enter a number: \"); \n\nscanf(\"%d\", &n); \n\nC PROGRAMMING \nPage 73 \n\n\nwhile(n!=0) \n\n{ \n\nrem=n%10; \n\nreverse=reverse*10+rem; \n\nn/=10; \n\n} \n\nprintf(\"Reversed Number: %d\",reverse); \n\ngetch(); \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFlowchart \n\n\n![Image](/src/assets/generated_images/cp_p73_i0.png)\nC PROGRAMMING \nPage 74 \n\n\n\n\n\n\ndo-while loop \n\nSyntax : variable initialization ; \n\ndo { \n\nstatements ; \n\nvariable increment or decrement ; \n\n} while (condition); \n\nThe do-while loop is an exit controlled loop statement The body of the loop are executed first \nand then the condition is evaluated. If it is true, then the body of the loop is executed once again. \nThe process of execution of body of the loop is continued until the condition finally becomes \nfalse and the control is transferred to the statement immediately after the loop. The statements \nare always executed at least once. \n\nFlowchart \n\n\n![Image](/src/assets/generated_images/cp_p74_i0.png)\nC PROGRAMMING \nPage 75 \n\n\n\n\nExample : Program to print first ten multiple of 5 \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nint a,i; \n\na=5; \n\ni=1; \n\ndo \n\n{ \n\nprintf(\"%d\\t\",a*i); \n\ni++; \n\n}while(i <= 10); \n\ngetch(); \n\n} \n\nC PROGRAMMING \nPage 76 \n\n\nOutput \n\n5 10 15 20 25 30 35 40 45 50 \n\nExample \n\nmain() \n\n{ \n\nint i=0 \n\ndo \n\n{ \n\nprintf(\"while vs do-while\\n\"); \n\n}while(i= =1); \n\nprintf(\"Out of loop\"); \n\n} \n\nOutput: \n\nwhile vs do-while \n\nOut of loop \n\nFor Loop: \n\n\uf0b7 This is an entry controlled looping statement. \n\n\uf0b7 In this loop structure, more than one variable can be initialized. \n\n\uf0b7 One of the most important features of this loop is that the three actions can be taken at a \n\ntime like variable initialization, condition checking and increment/decrement. \n\n\uf0b7 The for loop can be more concise and flexible than that of while and do-while loops. \n\nSyntax : for(initialization; condition; increment/decrement) \n\n{ \n\nStatements; \n\n} \n\nC PROGRAMMING \nPage 77 \n\n\n\n\nExample: \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main( ) \n\n{ \n\nint x; \n\nfor(x=1; x<=10; x++) \n\n{ \n\nprintf(\"%d\\t\",x); \n\n} \n\ngetch(); \n\n} \n\nOutput \n\n1 2 3 4 5 6 7 8 9 10 \n\n\n\nVarious forms of FOR LOOP \n\nI am using variable num in all the below examples \u2013 \n\n1) Here instead of num++, I\u201fm using num=num+1 which is nothing but same as num++. \n\nfor (num=10; num<20; num=num+1) \n\n2) Initialization part can be skipped from loop as shown below, the counter variable is declared \nbefore the loop itself. \n\nint num=10; \n\nfor (;num<20;num++) \n\nMust Note: Although we can skip init part but semicolon (;) before condition is must, without \nwhich \nyou \nwill \nget \ncompilation \nerror. \n\nC PROGRAMMING \nPage 78 \n\n\n3) Like initialization, you can also skip the increment part as we did below. In this case \nsemicolon (;) is must, after condition logic. The increment part is being done in for loop body \nitself. \n\nfor (num=10; num<20; ) \n\n{ \n\n//Code \n\nnum++; \n\n} \n\n4) Below case is also possible, increment in body and init during declaration of counter variable. \n\nint num=10; \n\nfor (;num<20;) \n\n{ \n\n//Statements \n\nnum++; \n\n} \n\n5) Counter can be decremented also, In the below example the variable gets decremented each \ntime the loop runs until the condition num>10 becomes false. \n\nfor(num=20; num>10; num--) \n\nProgram to calculate the sum of first n natural numbers \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint num, count, sum = 0; \n\nprintf(\"Enter a positive integer: \"); \n\nscanf(\"%d\", &num); \n\n// for loop terminates when n is less than count \n\nC PROGRAMMING \nPage 79 \n\n\nfor(count = 1; count <= num; ++count) \n\n{ \n\nsum += count; \n\n} \n\nprintf(\"Sum = %d\", sum); \n\nreturn 0; \n\n} \n\nOutput \n\nEnter a positive integer: 10 \n\nSum = 55 \n\nFactorial Program using loop \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main(){ \n\nint i,fact=1,number; \n\nclrscr(); \n\nprintf(\"Enter a number: \"); \n\nscanf(\"%d\",&number); \n\n\n\nfor(i=1;i<=number;i++){ \n\nfact=fact*i; \n\n} \n\nprintf(\"Factorial of %d is: %d\",number,fact); \n\ngetch(); \n\n} \n\nC PROGRAMMING \nPage 80 \n\n\nOutput: \n\nEnter a number: 5 \n\nFactorial of 5 is: 120 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFlow Chart of for Loop : \n\n\n![Image](/src/assets/generated_images/cp_p80_i0.png)\n\n![Image](/src/assets/generated_images/cp_p80_i1.png)\nC PROGRAMMING \nPage 81 \n\n\n\n\n\n\nInfinitive for loop in C \n\nIf you don't initialize any variable, check condition and increment or decrement variable in for \nloop, it is known as infinitive for loop. In other words, if you place 2 semicolons in for loop, it is \nknown as infinitive for loop. \n\nfor (; ;){ \n\nC PROGRAMMING \nPage 82 \n\n\nprintf(\"infinitive for loop example by javatpoint\"); \n\n} \n\n\n\nBasis of Difference \nFor Loop \nWhile Loop \nDo While Loop \n\nWhere \nto \nUse for Loop, while Loop \nand do while Loop \n\nThe for loop \nis \nappropriate \nwhen we know in \nadvance \nhow many times the \nloop \nwill be executed. \n\nThe other two loops i.e. while and do \nwhile loops are more suitable in the \nsituations where it is not known before \nhand when the loop will terminate. \n\n\n\nIn case if the \ntest \ncondition \nfails \nat \nthe \nbeginning, and \nyou \nmay \nnot \nwant to execute \nthe body of the \nloop even once \nif it fails, then \nthe while loop \nshould \nbe \npreferred. \n\nIn case if the test \ncondition fails at the \nbeginning, and you \nmay want to execute \nthe body of the loop \natleast once even in \nthe failed condition, \nthen the do while \nloop \nshould \nbe \npreferred. \n\nHow all the three loops \nworks? \n\nA for loop initially \ninitiates a \ncounter \nvariable (initialization- \nexpression), then \nit \nchecks \nthe \ntest-expression, \nand \nexecutes the body of \nthe loop if the test \nexpression is \ntrue. \nAfter executing the \nbody of the loop, \n\nA while loop \nwill \nalways \nevaluate \nthe \ntest-expression \ninitially. It the \ntest-expression \nbecomes \ntrue, \nthen the body of \nthe loop will be \nexecuted. \nThe \nupdate \n\nA do while loop will \nalways executed the \ncode in the do {} i.e. \nbody of the loop \nblock first and then \nevaluates \nthe \ncondition. \nIn \nthis \ncase also, the counter \nvariable is initialized \noutside the body of \nthe loop. \n\nC PROGRAMMING \nPage 83 \n\n\nthe update-expression \nis executed \nwhich \nupdates the value of \ncounter variable. \n\nexpression \nshould \nbe \nupdated \ninside \nthe body of the \nwhile. However, \nthe \ncounter \nvariable \nis \ninitialized \noutside the body \nof the loop. \n\nPosition of the statements \n: \n\n\uf0b7 \nInitialization \n\n\uf0b7 \ntest-expression \n\n\uf0b7 \nupdate-expression \n\nIn for loop, all the \nthree statements are \nplaced in one position \n\nIn while and do while loop, they are \nplaced in different position. \n\nSyntax of Loops \n\nfor ( \n\ninitialization- \nexp.(s); \n\ntest-expression(s); \n\nupdate- \nexpression(s) \n\n) \n\n{ \n\nbody-of-the-loop \n; \n\n} \n\n\n\nwhile(test- \nexpression) \n\n{ \n\nbody-of-the- \nloop; \n\nupdate- \nexpression(s); \n\n} \n\ndo  { \n\nbody-of-the- \nloop; \n\nupdate- \nexpression(s); \n\n} \n\nwhile \n(test- \nexpression); \n\nC PROGRAMMING \nPage 84 \n\n\nWhich \none \nis \nEntry \nControlled \nLoop \nand \nWhich \none \nis \nExit \nControlled Loop ? \n\nBoth loops i.e. for loop and while loop are \nentry controlled loop, means condition is \nchecked first and if the condition is true \nthen the body of the loop will executes. \n\ndo while loop is an \nexit controlled loop, \nmeans means that \ncondition is placed \nafter the body of the \nloop and is evaluated \nbefore exiting from \nthe loop. \n\nConversion of one Loop \nto \nanother \nLoop \nor \nExample : Print numbers \nfrom 1 to 10 using all the \nthree loops. \n\n: \n\n: \n\nfor (int i=1; i<=10; \ni++) \n\n{ \n\nPrintf(\u201c%d\u201d,i);  } \n\nint i = 1; \n\n: \n\n: \n\nwhile (i<=10) \n\n{ \n\n\nPrintf(\u201c%d\u201d,i); \n++i \n\n} \n\nint i = 1; \n\n: \n\n: \n\ndo \n\n{ \n\nPrintf(\u201c%d\u201d,i); \n++i; \n\n} \n\nwhile (i<=10) \n\n\n\n\n\nNested for loop \n\nWe can also have nested for loops, i.e one for loop inside another for loop. nesting is often used \nfor handling multidimensional arrays. \n\nSyntax: \n\nfor( initialization ; condition ; increment/decrement ) \n\n{ \n\nfor( initialization ; condition ; increment/decrement ) \n\nC PROGRAMMING \nPage 85 \n\n\n{ \n\nstatement ; \n\n} \n\n} \n\nExample: \n\nmain() \n\n{ \n\nfor (int i=0; i<=5; i++) \n\n{ \n\nfor (int j=0; j<=5; j++) \n\n{ \n\nprintf(\"%d, %d\",i ,j); \n\n} \n\n} \n\n} \n\n\n\nExample : Program to print half Pyramid of numbers \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main( ) \n\n{ \n\nint i,j; \n\nfor (i=1;i<5;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nC PROGRAMMING \nPage 86 \n\n\nfor (j=i;j>0;j--) \n\n{ \n\nprintf(\"%d\",j); \n\n} \n\n} \n\ngetch(); \n\n} \n\nOutput \n\n1 \n\n21 \n\n321 \n\n4321 \n\n54321 \n\n\n\nJump Statements \n\nJumping statements are used to transfer the program\u201fs control from one location to another, these \nare set of keywords which are responsible to transfer program\u201fs control within the same block or \n\nfrom one function to another . \n\nThere are four jumping statements in C language: \n\n\uf0b7 \ngoto statement \n\n\uf0b7 \nreturn statement \n\n\uf0b7 \nbreak statement \n\n\uf0b7 \ncontinue statement \n\ngoto statement : goto statement doesnot require any condition. This statement passes control \nanywhere in the program i.e, control is transferred to another part of the program without testing \nany condition. \n\n\n![Image](/src/assets/generated_images/cp_p86_i0.png)\nC PROGRAMMING \nPage 87 \n\n\nSyntax : goto label; \n\n. . . . . \n\n. . . . . \n\nlabel: \n\nstatements; \n\nInthissyntax, label isan identifier. \nWhen, the control of program reaches to goto statement, the control of the program will jump to \nthe label: and executes the code below it. \n\nOr \n\nThe goto statement requires a label to identify the place to move the execution. A label is a valid \nvariable/identifier name and must be ended with colon ( : ) \n\n\n\n\nFlowchart \n\n\n\n![Image](/src/assets/generated_images/cp_p87_i0.png)\nC PROGRAMMING \nPage 88 \n\n\n\n\nExample \n\nint main() \n\n{ \n\nint age; \n\nVote: \n\nprintf(\"you are eligible for voting\"); \n\nNoVote: \n\nprintf(\"you are not eligible to vote\"); \n\nprintf(\"Enter you age:\"); \n\nscanf(\"%d\", &age); \n\nif(age>=18) \n\ngoto Vote; \n\nelse \n\ngoto NoVote; \n\nreturn 0; \n\nC PROGRAMMING \nPage 89 \n\n\n} \n\nOutput \n\nEnter you age:19 \n\nyou are eligible for voting \n\nEnter you age:15 \n\nyou are not eligible to vote \n\nBreak Statement \n\nBreak is a keyword. The break statement terminates the loop (for, while and do...while loop) \n\nimmediately when it is encountered. The break statement is used/ associated with decision \n\nmaking statement such as if ,if-else. \n\nSyntax of break statement \n\nbreak; \n\n\n\n\n\nFlowchart \n\n\n![Image](/src/assets/generated_images/cp_p89_i0.png)\nC PROGRAMMING \nPage 90 \n\n\n\n\nHow break statement works? \n\n\n![Image](/src/assets/generated_images/cp_p90_i0.png)\nC PROGRAMMING \nPage 91 \n\n\n\n\nExample \n\n#include <stdio.h> \n\n#include <conio.h> \n\nvoid main(){ \n\nint i=1;//initializing a local variable \n\nclrscr(); \n\n//starting a loop from 1 to 10 \n\nfor(i=1;i<=10;i++){ \n\nC PROGRAMMING \nPage 92 \n\n\nprintf(\"%d \\n\",i); \n\nif(i==5){//if value of i is equal to 5, it will break the loop \n\nbreak; \n\n} \n\n}//end of for loop \n\ngetch(); \n\n} \n\nOutput \n\n12345 \n\n\n\n\n\n\n\nContinue Statement \n\nContinue is keyword exactly opposite to break. The continue statement is used for continuing \n\nnext iteration of loop statements. When it occurs in the loop it does not terminate, but it skips \n\nsome statements inside the loop / the statements after this statement. . The continue statement is \n\nused/ associated with decision making statement such as if ,if-else. \n\nSyntax of continue Statement \n\ncontinue; \n\nFlowchart of continue Statement \n\n\n![Image](/src/assets/generated_images/cp_p92_i0.png)\n\n![Image](/src/assets/generated_images/cp_p92_i1.png)\nC PROGRAMMING \nPage 93 \n\n\n\n\nHow continue statement works? \n\n\n\n\n\nExample \n\nC PROGRAMMING \nPage 94 \n\n\n1. #include <stdio.h> \n\n2. #include <conio.h> \n\n3. void main(){ \n\n4. int i=1;//initializing a local variable \n\n5. clrscr(); \n\n6. //starting a loop from 1 to 10 \n\n7. for(i=1;i<=10;i++){ \n\n8. if(i==5){//if value of i is equal to 5, it will continue the loop \n\n9. continue; \n\n10. } \n\n11. printf(\"%d \\n\",i); \n\n12. }//end of for loop \n\n13. getch(); \n\n14. } \n\nOutput \n1234678910 \n\nComparision between break and continue statements \n\nBreak \nContinue \n\n1 : break statement takes the control to the \nouside of the loop \n\n1 :continue statement takes the control to \nthe beginning of the loop.. \n\n2 : it is also used in switch statement. \n2 : This can be used only in loop \nstatements. \n\n3 : Always associated with if condition in \nloops. \n\n3 : This is also associated with if \ncondition. \n\n\n\n\n\nARRAYS \n\nUsing Arrays in C \n\nC PROGRAMMING \nPage 95 \n\n\nC supports a derived data type known as array that can be used to handle large amounts of data \n(multiple values) at a time . \n\nDefinition: \n\nAn array is a group (or collection) of same data types. \n\nOr \n\nAn array is a collection of data that holds fixed number of values of same type. \n\nOr \n\nArray is a collection or group of elements (data). All the elements of array \nare homogeneous (similar). It has contiguous memory location . \n\nOr \n\nAn array is a data structured that can store a fixed size sequential collection  of elements of same \ndata type. \n\nWhat\u201fs the need of an array? \n\nSuppose you have to store marks of 50 students, one way to do this is allotting 50 \n\nvariables. So it will be typical and hard to manage. For example we can not access the \n\nvalue of these variables with only 1 or 2 lines of code. \n\nAnother way to do this is array. By using array, we can access the elements easily. Only \n\nfew lines of code is required to access the elements of array. \n\nWhere arrays are used \n\n\uf0b7 \nto store list of Employee or Student names, \n\n\uf0b7 \nto store marks of a students, \n\n\uf0b7 \nor to store list of numbers or characters etc. \n\nAdvantage of C Array \n\n1) Code Optimization : Less code to the access the data. \n\n2) Easy to traverse data : By using the for loop, we can retrieve the elements of an array easily. \n\n\n![Image](/src/assets/generated_images/cp_p95_i0.png)\n\n![Image](/src/assets/generated_images/cp_p95_i1.png)\nC PROGRAMMING \nPage 96 \n\n\n3) Easy to sort data : To sort the elements of array, we need a few lines of code only. \n\n4) Random Access : We can access any element randomly using the array. \n\nDisadvantage of  Array \n\nFixed Size: Whatever size, we define at the time of declaration of array, we can't exceed the \nlimit. So, it doesn't grow the size dynamically like LinkedList \n\nDeclaration of an Array \n\ndata-type variable-name[size/length of array]; \n\nFor example: \n\nint arr[10]; \n\n\n\n\n\n\n\nint arr[ 5]; \n\n\n\nHere int is the data type, arr is the name of the array and 10 is the size of array. It means \narray arr can only contain 10 elements of int type. Index of an array starts from 0 to size-1 i.e \nfirst element of arr array will be stored at arr[0] address and last element will occupy arr[9]. \n\nInitialization of an Array \n\n\n![Image](/src/assets/generated_images/cp_p96_i0.png)\nC PROGRAMMING \nPage 97 \n\n\nAfter an array is declared it must be initialized. Otherwise, it will contain garbage value(any \nrandom value). An array can be initialized at either compile time or at runtime . \n\nCompile time Array initialization \n\nCompile time initializtion of array elements is same as ordinary variable initialization. \n\nSyntax : data_type  array_name[size]={v1,v2,\u2026vn/list of values ; \n\nExample \n\nint age[5]={22,25,30,32,35}; \n\n\n\nint marks[4]={ 67, 87, 56, 77 }; //integer array initialization \n\nfloat area[5]={ 23.4, 6.8, 5.5 }; //float array initialization \n\nint marks[4]={ 67, 87, 56, 77, 59 };    //Compile time error \n\nDifferent ways of initializing arrays : \n\n1 : Initilizing all specified memory locations \n\n2 : Partial array initialization. \n\n3 : Intilization without size. \n\n4 : String initialization. \n\n\n\n1 : Initilizing all specified memory locations : If the number of values to be initialized is equal \nto size of array. Arrays can be initialized at the time of declaration. Array elements can be \ninitialized with data items of type int,float,char, etc. \n\n\n\nEx :  consider integer initialization \n\nint a[5]={10,20,30,40,50}; \n\nC PROGRAMMING \nPage 98 \n\n\nDuring compilation, 5 contiguous memory locations are reserved by the compiler for the \nvariable a and all these locations are initialized. \n\n\n\nThe array a is initialized as \n\na[0]            a[1]         a[2]               a[3]              a[4] \n\n\n\n10 \n20 \n30 \n40 \n50 \n\n1000          1002          1004            1006              1008 \n\n\n\n\n\nIf the size of integer is 2 bytes, 10 bytes will be allocated for the variable a. \n\nEx : consider character initialization \n\n\n\nchar b[8] = {\u201eC\u201f,\u201fO\u201f,\u201fM\u201f,\u201fP\u201f,\u201fU\u201f,\u201fT\u201f,\u201fE\u201f,\u201fR\u201f}; \n\n\n\nThe array b is initialized as \n\n\n\n\n\nb[0]    b[1]      b[2]     b[3]     b[4]      b[5]     b[6]     b[7] \n\n\n\nC \nO \nM \nP \nU \nT \nE \nR \n\nOther Examples : char b[5]={\u201eJ\u201f,\u201fB\u201f,\u201fR\u201f,\u201fE\u201f,\u201fC\u201f,\u201fB\u201f}; \n\n//error : number of initial values are more than the size of array. \n\nOther Example : int a[5]={10,20,30,40,50,60}; \n\nC PROGRAMMING \nPage 99 \n\n\n//error : Number of initial values are more than the size of array. \n\n\n\n2 : Partial Array Initilization : partial array initialization is possible in C language. If the \nnumber of values to be initialized is less than the size of the array, then the elements are \ninitialized in the order from 0 th location. The remaining locations will be initialized to zero \nautomatically. \n\nEx : Consider the partial initilization \n\nint a[5]={10,15}; \n\nEventhough compiler allocates 5 memory locations, using this declaration \nstatement, the compiler initializes first two locations with 10 and 15, the next set of memory \nlocations are automatically initialized to zero. \n\n\n\nThe array a is partial initialization as \n\na[0]            a[1]         a[2]               a[3]              a[4] \n\n\n\n10 \n15 \n0 \n0 \n0 \n\n1000          1002          1004            1006              1008 \n\nHow to access the elements of an array? \n\nYou can access elements of an array by indices/index. You can use array subscript (or index) to \naccess any element stored in array. Subscript starts with 0, which means array_name[0] would be \nused to access first element in an array. \n\nIn general array_name[n-1] can be used to access nth element of an array. where n is any integer \nnumber. \n\n\n\nExample \n\nfloat mark[5]; \n\nSuppose you declared an array mark as above. The first element is mark[0], second element \nis mark[1] and so on. \n\n\n![Image](/src/assets/generated_images/cp_p99_i0.png)\nC PROGRAMMING \nPage 100 \n\n\n\n\nFew key notes: \n\n\uf0b7 \nArrays have 0 as the first index not 1. In this example, mark[0] \n\uf0b7 \nIf the size of an array is n, to access the last element, (n-1) index is used. In this \nexample, mark[4] \n\uf0b7 \nSuppose the starting address of mark[0] is 2120d. Then, the next address, a[1], will be \n2124d, address of a[2] will be 2128d and so on. It's because the size of a float is 4 bytes. \n\nInput data into array \n\nAs you can see, in above example that I have used \u201efor loop\u201f and \u201escanf statement\u201f to enter data \ninto array. You can use any loop for data input. \n\nCode: \n\nfor (x=0; x<=19;x++) \n\n{ \n\nprintf(\"enter the integer number %d\\n\", x); \n\nscanf(\"%d\", &num[x]); \n\n} \n\nReading out data from an array \n\nFor example you want to read and display array elements, you can do it just by using any \nloop.  Suppose array is mydata[20]. \n\nfor (int i=0; i<20; i++) \n\n{ \n\nprintf(\"%d\\n\", mydata[x]); \n\n} \n\nC PROGRAMMING \nPage 101 \n\n\nExmaple \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nint i; \n\nint arr[]={2,3,4}; //Compile time array initialization \n\nfor(i=0 ; i<3 ; i++) { \n\nprintf(\"%d\\t\",arr[i]); \n\n} \n\ngetch(); \n\n} \n\nOutput \n\n2  3  4 \n\nExmaple \n\n1. include <stdio.h> \n2. #include <conio.h> \n3. void main(){ \n4. int i=0; \n5. int marks[5]={20,30,40,50,60};//declaration and initialization of array \n6. clrscr(); \n7. \n8. //traversal of array \n9. for (i=0;i<5;i++){ \n10. printf(\"%d \\n\",marks[i]); \n11. } \n12. \n13. getch(); \n14. } \n\nC PROGRAMMING \nPage 102 \n\n\nOutput \n20 \n30 \n40 \n50 \n60 \n\n\nRuntime Array initialization \n\nAn array can also be initialized at runtime using scanf() function. This approach is usually \nused for initializing large array, or to initialize array with user specified values. \n\nExample \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nint arr[4]; \n\nint i, j; \n\nprintf(\"Enter array element\"); \n\nfor(i=0;i<4;i++) \n\n{ \n\nscanf(\"%d\",&arr[i]); //Run time array initialization \n\n} \n\nfor(j=0;j<4;j++) \n\n{ \n\nprintf(\"%d\\n\",arr[j]); \n\n} \n\ngetch(); \n\n\n![Image](/src/assets/generated_images/cp_p102_i0.png)\nC PROGRAMMING \nPage 103 \n\n\n} \n\n\n\nTwo \u2010 Dimensional Arrays \n\nThe two dimensional array in C language is represented in the form of rows and columns, \nalso known as matrix. It is also known as array of arrays or list of arrays . \n\nThe two dimensional, three dimensional or other dimensional arrays are also known \nas multidimensional arrays. \n\nDeclaration of two dimensional Array \n\ndata_type array_name[size1][size2]; \n\nExample \n\nint twodimen[4][3]; \n\nExample : \n\nint a[3][4]; \n\n\n\nInitialization of 2D Array \n\nint arr[4][3]={{1,2,3},{2,3,4},{3,4,5},{4,5,6}}; \n\n\n\nC PROGRAMMING \nPage 104 \n\n\nAccessing Two-Dimensional Array Elements \n\nAn element in a two-dimensional array is accessed by using the subscripts, i.e., row index \nand column index of the array. \n\n\n\n\n\nExample \n\n1. #include <stdio.h> \n2. #include <conio.h> \n3. void main(){ \n4. int i=0,j=0; \n5. int arr[4][3]={{1,2,3},{2,3,4},{3,4,5},{4,5,6}}; \n6. clrscr(); \n7. //traversing 2D array \n8. for(i=0;i<4;i++){ \n9. for(j=0;j<3;j++){ \n10. printf(\"arr[%d] [%d] = %d \\n\",i,j,arr[i][j]); \n11. }//end of j \n12. }//end of i \n13. getch(); \n14. } \n\nOutput \narr[0][0] = 1 \narr[0][1] = 2 \narr[0][2] = 3 \narr[1][0] = 2 \narr[1][1] = 3 \narr[1][2] = 4 \narr[2][0] = 3 \narr[2][1] = 4 \narr[2][2] = 5 \narr[3][0] = 4 \narr[3][1] = 5 \narr[3][2] = 6 \n\n\n\nExample Write a C program Addition of Two Matrices \n\n#include<stdio.h> \n\n#include<conio.h> \n\nC PROGRAMMING \nPage 105 \n\n\nvoid main() \n\n{ \n\nint a[25][25],b[25][25],c[25][25],i,j,m,n; \n\nclrscr(); \n\nprintf(\"enter the rows and colums of two matrics:\\n\"); \n\nscanf(\"%d%d\",&m,&n); \n\nprintf(\"\\nenter the elements of A matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nfor(j=0;j<n;j++) \n\nscanf(\"\\t%d\",&a[i][j]); \n\n} \n\nprintf(\"\\nenter the elements of B matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nfor(j=0;j<n;j++) \n\nscanf(\"\\t%d\",&b[i][j]); \n\n} \n\nprintf(\"\\nThe elements of A matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nfor(j=0;j<n;j++) \n\nC PROGRAMMING \nPage 106 \n\n\nprintf(\"\\t%d\",a[i][j]); \n\n} \n\nprintf(\"\\nThe elements of B matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nfor(j=0;j<n;j++) \n\nprintf(\"\\t%d\",a[i][j]); \n\n} \n\nprintf(\"\\nThe additon of two matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nfor(j=0;j<n;j++) \n\n{ \n\nc[i][j]=a[i][j]+b[i][j]; \n\nprintf(\"\\t%d\",c[i][j]); \n\n} \n\n} \n\ngetch(); \n\n} \n\n\n\n\n\nC PROGRAMMING \nPage 107 \n\n\n\n\nWrite a C program Multiplication of Two Matrices. \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nint a[25][25],b[25][25],c[25][25],i,j,m,n,k,r,s; \n\nclrscr(); \n\nprintf(\"enter the rows and colums of A matrics:\\n\"); \n\nscanf(\"%d%d\",&m,&n); \n\nprintf(\"enter the rows and colums of B matrics:\\n\"); \n\nscanf(\"%d%d\",&r,&s); \n\nprintf(\"\\nenter the elements of A matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nfor(j=0;j<n;j++) \n\nscanf(\"\\t%d\",&a[i][j]); \n\n} \n\nprintf(\"\\nenter the elements of B matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nfor(j=0;j<n;j++) \n\nscanf(\"\\t%d\",&b[i][j]); \n\nC PROGRAMMING \nPage 108 \n\n\n} \n\nprintf(\"\\nThe elements of A matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nfor(j=0;j<n;j++) \n\nprintf(\"\\t%d\",a[i][j]); \n\n} \n\nprintf(\"\\nThe elements of B matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nfor(j=0;j<n;j++) \n\nprintf(\"\\t%d\",b[i][j]); \n\n} \n\n\n\nfor(i=0;i<m;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nfor(j=0;j<n;j++) \n\n{ \n\nc[i][j]=0; \n\nfor(k=0;k<m;k++) \n\n\nC PROGRAMMING \nPage 109 \n\n\nc[i][j]=c[i][j]+a[i][k]*b[k][j]; \n\n} \n\n} \n\n\n\nprintf(\"\\nThe Multiplication of two matrics\"); \n\nfor(i=0;i<m;i++) \n\n{ \n\nprintf(\"\\n\"); \n\nfor(j=0;j<n;j++) \n\nprintf(\"\\t%d\",c[i][j]); \n\n} \n\ngetch(); \n\n} \n\n\n\nMultidimensional Arrays \n\nHow to initialize a multidimensional array? \n\nInitialization of a three dimensional array. \n\nYou can initialize a three dimensional array in a similar way like a two dimensional array. Here's \nan example \n\nint test[2][3][4] = { \n\n{ {3, 4, 2, 3}, {0, -3, 9, 11}, {23, 12, 23, 2} }, \n\n{ {13, 4, 56, 3}, {5, 9, 3, 5}, {3, 1, 4, 9} } \n\n}; \n\nExample \n\nC PROGRAMMING \nPage 110 \n\n\n#include <stdio.h> \n\nint main() \n\n{ \n\n// this array can store 12 elements \n\nint i, j, k, test[2][3][2]; \n\nprintf(\"Enter 12 values: \\n\"); \n\nfor(i = 0; i < 2; ++i) { \n\nfor (j = 0; j < 3; ++j) { \n\nfor(k = 0; k < 2; ++k ) { \n\nscanf(\"%d\", &test[i][j][k]); \n\n} \n\n} \n\n} \n\n// Displaying values with proper index. \n\nprintf(\"\\nDisplaying values:\\n\"); \n\nfor(i = 0; i < 2; ++i) { \n\nfor (j = 0; j < 3; ++j) { \n\nfor(k = 0; k < 2; ++k ) { \n\nprintf(\"test[%d][%d][%d] = %d\\n\", i, j, k, test[i][j][k]); \n\n} \n\n} \n\n} \n\nreturn 0; \n\n} \n\nOutput \n\nC PROGRAMMING \nPage 111 \n\n\nEnter 12 values: \n\n123456789101112 \n\nDisplaying Values: \n\ntest[0][0][0] = 1 \n\ntest[0][0][1] = 2 \n\ntest[0][1][0] = 3 \n\ntest[0][1][1] = 4 \n\ntest[0][2][0] = 5 \n\ntest[0][2][1] = 6 \n\ntest[1][0][0] = 7 \n\ntest[1][0][1] = 8 \n\ntest[1][1][0] = 9 \n\ntest[1][1][1] = 10 \n\ntest[1][2][0] = 11 \n\ntest[1][2][1] = 12 \n\n\n\n\n\n\n\n\n\nSTRINGS : \n\nString Concepts \n\nString is an array of characters that is terminated by \\0 (null character). This null \ncharacter indicates the end of the string. Strings are always enclosed by double quotes ( \" \n\n\" ) . Whereas, character is enclosed by single quotes. \n\nOr \n\nC PROGRAMMING \nPage 112 \n\n\nIn \u201eC\u201f language the group of characters, digits, and symbols enclosed within double \nquotation ( \" \" ) marks are called as string otherwise a string is an array of characters and \nterminated by NULL character which is denoted by the escape sequence \u201e\\0\u201f. \n\nC Strings \n\nDeclaration of String : C does not support string as a data type. However, it allows us to \nrepresent strings as character arrays. In C, a string variable is any valid C variable name and it is \nalways declared as an array of characters. \n\nThe general form of declaration of a string variable is : \n\nSyntax: char string_name[size]; \n\nThe size determines the number of characters in the string name. \n\nNote: In declaration of string size must be required to mention otherwise it gives an error. \n\nEx: char str[];   // Invalid \n\nchar str[0];  // Invalid \n\nchar str[-1]; // Invalid \n\nchar str[10]; // Valid \n\nchar a[9];    //Valid \n\nUsing this declaration the compiler allocates 9 memory locations for the variable a \nranging from 0 to 8. \n\n\n\n0   1    2     3    4    5     6    7     8 \n\n\n\n\n\n\n\n\n\n\n\n\n\nHere, the string variable a can hold maximum of 9 characters including NULL(\\0) \ncharacter. \n\nInitializing Array string \n\nSyntax : char  string_name[size]={\u201cstring\u201d }; \n\nNote: In Initialization of the string if the specific number of character is not initialized it then \nrest of all character will be initialized with NULL. \n\nC PROGRAMMING \nPage 113 \n\n\nchar str[5]={'5','+','A'}; \n\nstr[0];  ---> 5 \n\nstr[1];  ---> + \n\nstr[2];  ---> A \n\nstr[3];  ---> NULL \n\nstr[4];  ---> NULL \n\nNote: In initialization of the string we can not initialized more than size of string elements. \n\nEx: \n\nchar str[2]={'5','+','A','B'};  // Invalid \n\nDifferent ways of initialization can be done in various ways : \n\n1 : Initilizing locations character by character. \n\n2 : Partial array initialization. \n\n3 : Intilization without size. \n\n4 : Array initialization with a string . \n\n1 : Initilizing locations character by character \n\nConsider the following declaration with initialization, \n\nChar b[9]={\u201eC\u201f,\u201fO\u201f,\u201fM\u201f,\u201fP\u201f,\u201fU\u201f,\u201fT\u201f,\u201fE\u201f,\u201fR\u201f}; \n\nThe compiler allocates 9 memory locations ranging from 0 to 8 and these locations are \ninitialized with the characters in the order specified. The remaining locations are automatically \ninitialized to null characters. \n\n\n\nC  O M P \nU T E \nR \\0 \n\n0     1    2     3     4    5     6    7    8 \n\n\n\n2 : Partial Array Initilization : If the characters to be  initialized is less than the size of the \narray, then the characters are stored sequentially from left to right.The remaining locations will \nbe initialized to NULL characters automatically. \n\nC PROGRAMMING \nPage 114 \n\n\n\n\nEx : Consider the partial initilization \n\nint a[10]={\u201eR\u201f,\u201fA\u201f,\u201fM\u201f,\u201fA\u201f }; \n\nThe  compiler allocates 10 bytes for the variable a ranging from 0 to 9 and \ninitializes first four locations with the ASCII characters of \u201eR\u201f, \u201eA\u201f, \u201eM\u201f, \u201eA\u201f.The remaining \nlocations are automatically filled with NULL characters (i.e,\\0). \n\n\n\nR A \nM A \\0 \\0 \\0 \\0 \\0 \\0 \n\n0     1      2     3     4     5    6     7     8     9 \n\n\n\n3 : Initilization without size : consider the declaration along with the initialization \n\nchar b[]={\u201eC\u201f,\u201fO\u201f,\u201fM\u201f,\u201fP\u201f,\u201fU\u201f,\u201fT\u201f,\u201fE\u201f,\u201fR\u201f}; \n\nIn this declaration, The compiler will set the array size to the total number of \ninitial values i.e 8. The character will be stored in these memory locations in the order specified. \n\nb[0]    b[1]      b[2]     b[3]     b[4]      b[5]     b[6]     b[7] \n\nC \nO \nM \nP \nU \nT \nE \nR \n\n\n\n4) Array Initilization with a String : consider the declaration with string initialization. \n\nchar b[ ] = \u201cCOMPUTER\u201d; \n\nHere, the string length is 8 bytes. But , string size is 9 bytes. So the compiler reserves \n8+1 memory locations and these locations are initialized with the characters in the order \nspecified. The string is terminated by \\0 by the compiler. \n\n\n\nC O M P \nU T E \nR \\0 \n\n0    1    2     3     4     5    6     7    8 \n\nThe string \u201cCOMPUTER\u201d contin 8 charactes, because it is a string. It always ends with \nnull character. So, the array is 9 bytes (i.e string length+1 byte for null character). \n\nC PROGRAMMING \nPage 115 \n\n\nReading and Writing Strings : The \u201e%s\u201f control string can be used in scanf() statement to read \na string from the teriminal and the same may be used to write string to the terminal in printf() \nstatement. \n\nExample : char name[10]; \n\nscanf(\u201c%s\u201d,name); \n\nprintf(\u201c%s\u201d,name); \n\nExample: \n\n1. #include <stdio.h> \n\n2. void main () \n\n3. { \n\n4. char ch[13]={'c', 'p', 'r', 'o', 'g', 'r', 'a', 'm', 'm', i', \u201en\u201f, \u201eg\u201f, \u201e\\0\u201f}; \n\n5. char ch2[13]=\"cprogramming\"; \n\n6. \n\n7. printf(\"Char Array Value is: %s\\n\", ch); \n\n8. printf(\"String Literal Value is: %s\\n\", ch2); \n\n9. } \n\nOutput \n\nChar Array Value is: cprogramming \n\nString Literal Value is: cprogramming \n\nExample: \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nchar name[20]; \n\nprintf(\"Enter name: \"); \n\nscanf(\"%s\", name); \n\n\n![Image](/src/assets/generated_images/cp_p115_i0.png)\n\n![Image](/src/assets/generated_images/cp_p115_i1.png)\n\n![Image](/src/assets/generated_images/cp_p115_i2.png)\n\n![Image](/src/assets/generated_images/cp_p115_i3.png)\n\n![Image](/src/assets/generated_images/cp_p115_i4.png)\nC PROGRAMMING \nPage 116 \n\n\nprintf(\"Your name is %s.\", name); \n\nreturn 0; \n\n} \n\nOutput \n\nEnter name: Dennis Ritchie \n\nYour name is Dennis. \n\nString Input/output Functions \n\nThe strings can be read from the keyboard and can be displayed onto the monitor \nusing various functions. \n\nThe various input and output functions that are associated with can be classified \nas \n\n\n\n\n\n\n\n\n\nI / O Functions \n\nFormated I/O Functions \n\nUnformated I/O Functions \n\nInput                Output \n\n\n\nscanf()             print() \n\nfscanf()           fprintf() \n\nInput                   Output \n\n\n\ngetc()                 putc() \n\ngetchar()            putchar() \n\ngets()                 puts() \n\ngetch() \n\ngetche() \n\nC PROGRAMMING \nPage 117 \n\n\n\n\n\n\nUnformated I/O Functions \n\n1 : getchar() function : A single character can be given to the computer using \u201eC\u201f input library \n\nfunction getchar(). \n\nSyntax : char variable=getchar(); \n\nThe getchar() function is written in standared I/O library. It reads a single character from a \nstandared input device. This function do not require any arguments, through a pair of \nparantheses, must follow the statements getchar(). \n\n\n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<ctype.h> \n\nvoid main() \n\n{ \n\nchar ch; \n\nclrscr(); \n\nprintf(\"Enter any character/digit:\"); \n\nch=getchar(); \n\nif(isalpha(ch)>0) \n\nprintf(\"it is a alphabet:%c\\n\",ch); \n\nelse if(isdigit(ch)>0) \n\nprintf(\"it is a digit:%c\\n\",ch); \n\nelse \n\nprintf(\"it is a alphanumeric:%c\\n\",ch); \n\ngetch(); \n\nC PROGRAMMING \nPage 118 \n\n\n}. \n\n\n\nOUTPUT : Enter any character/Digit : abc \n\nit is a alphabet:a \n\n\n\n2 : putchar() function : The putchar() function is used to display one character at a time on the \nstandared output device. This function does the reverse operation of the single character input \nfunction. \n\nSyntax : putchar(character varaiable); \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<ctype.h> \n\nvoid main() \n\n{ \n\nchar ch; \n\nprintf(\"Enter any alphabet either in lower or uppercase:\"); \n\nch=getchar(); \n\nif(islower(ch)) \n\nputchar(toupper(ch)); \n\nelse \n\nputchar(tolower(ch)); \n\ngetch(); \n\n} \n\nOUTPUT : Enter any alphabet either in lower or uppercase :a \n\nA \n\nC PROGRAMMING \nPage 119 \n\n\n3 : gets() : The gets() function is used to read the string (String is a group of characters) from the \nstandard input device (keyboard). \n\nSyntax : gets(char type of array variable); \n\nEx : #include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nchar str[40]; \n\nclrscr(); \n\nprintf(\"Enter String name:\"); \n\n\ngets(str); \n\n\nprintf(\"Print the string name%s:\",str); \n\n\ngetch(); \n\n} \n\n\n\nOUTPUT : Enter the string : reddy \n\nPrint the string :reddy \n\n4 : puts() : The puts() function is used to display the string to the standared output device \n(Monitor). \n\nSyntax : puts(char type of array variable); \n\nProgram using gets() function and puts() function. \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nchar str[40]; \n\nC PROGRAMMING \nPage 120 \n\n\nputs(\"Enter String name:\"); \n\ngets(str); \n\nputs(\"Print the string name:\"); \n\nputs(str); \n\ngetch(); \n\n} \n\nOUTPUT : Enter string name : \n\nsubbareddy \n\nPrint the string name \n\nsubbareddy \n\ngetch() function :The getch function reads a single character directly from the keyboard, \nwithout echoing to the screen. \n\nSyntax : int getch(); \n\nEx : #include<stdio.h> \n\nvoid main() \n\n{ \n\nchar c; \n\nc=getch(); \n\n} \n\n\n\ngetche() function : The getche() function reads a single character from the keyboard and echoes \nit to the current text window. \n\nSyntax : int getche(); \n\nEx : #include<stdio.h> \n\nvoid main() \n\n{ \n\nC PROGRAMMING \nPage 121 \n\n\nchar c; \n\nc=getche(); \n\n} \n\ngetc() function : This function is used to accept a single character from the standared input to a \ncharacter variable. \n\nSyntax : character variable=getc(); \n\nputc() function : This function is used to display a single character in a character variable to \nstandared output device. \n\nSyntax : putc(character variable); \n\n\n\nArray of Strings \n\n\n\nString Manipulation Functions/ String Handling Functions \n\nThe various string handling functions that are supported in C language are as shown \n\nString Function \nDescription \n\nstrlen(str) \nReturns the length of the string str. \n\nstrcpy(str1,str2) \nCopies the string str2 to string str1 \n\nstrcat(str1,str2) \nAppend string str2 to string str1. \n\nstrlwr(str) \nConverts the string str to lowercase \n\nstrupr(str) \nConverts the string str to uppercase. \n\nstrrev(str) \nReverse the string str. \n\nstrcmp(str1,str2) \nCompare two strings str1 and str2. \n\n\n\nAll these functions are defined in string.h header file. \n\n1 : strlen(string) \u2013 String Length : This function is used to count and return the number of \ncharacters present in a string. \n\nC PROGRAMMING \nPage 122 \n\n\nSyntax : var=strlen(string); \n\nEx : Progrm using strlen() function \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\nchar name[]=\"JBREC\"; \n\nint len1,len2; \n\nclrscr(); \n\nlen1=strlen(name); \n\nlen2=strlen(\"JBRECECE\"); \n\nprintf(\"The string length of %s is: %d\\n\",name,len1); \n\nprintf(\"The string length of %s is: %d\",\"JBRECECE\",len2); \n\ngetch(); \n\n} \n\nOUTPUT : \n\nThe string length of JBREC is : 5 \n\nThe string length of JBRECECE is :8 \n\n\n\nWrite a program to find the length of string \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nC PROGRAMMING \nPage 123 \n\n\nchar str[10]; \n\nint index; \n\nprintf(\"Enter the string:\"); \n\nscanf(\"%s\",str); \n\nfor(index=0;str[index]!=0;index++); \n\nprintf(\"The length of string is:%d\",index); \n\ngetch(); \n\n} \n\nOUTPUT : \n\nEnter the string : subbareddy \n\nThe length of string is :10 \n\n\n\n2 : strcpy(string1,string2) \u2013 String Copy : This function is used to copy the contents of one string \nto another string. \n\nSyntax : strcpy(string1,string2); \n\nWhere \n\nstring1 : is the destination string. \n\nstring 2: is the source string. \n\ni.e the contents of string2 is assigned to the contents of string1. \n\nEx : Progrm using strcpy() function \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\nC PROGRAMMING \nPage 124 \n\n\nchar str1[]=\"REDDY\"; \n\nchar str2[10]; \n\nstrcpy(str2,str1); \n\nprintf(\"The string1 is :%s\\n\",str1); \n\nprintf(\"The string2 is :%s\\n\",str2); \n\nstrcpy(str2,str1+1); \n\nprintf(\"The string1 is :%s\\n\",str1); \n\nprintf(\"The string2 is :%s\",str2); \n\n} \n\nOUTPUT : \n\nThe string1 is : REDDY \n\nThe string2 is : REDDY \n\nThe string1 is : REDDY \n\nThe string2 is : EDDY \n\n\n\n//Write a program to copy contents of one string to another string. \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nchar str1[10],str2[20]; \n\nint index; \n\nprintf(\"Enter the string\\n\"); \n\nscanf(\u201c%s\u201d,str1); \n\nfor(index=0;str1[index]!='\\0';index++) \n\nC PROGRAMMING \nPage 125 \n\n\n\nstr2[index]=str1[index]; \n\n\nstr2[index]='\\0'; \n\n\nprintf(\"String1 is :%s\\n\",str1); \n\n\nprintf(\"String2 is :%s\\n\",str2); \n\n\ngetch(); \n\n} \n\nOUTPUT : \n\nEnter the string : cprogramming \n\n\nString1 is : cprogramming \n\nString2 is : cprogramming \n\n\n\n3 : strlwr(string) \u2013 String LowerCase : This function is used to converts upper case letters of the \nstring in to lower case letters. \n\nSyntax : strlwr(string); \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\nchar str[]=\"JBREC\"; \n\nclrscr(); \n\nstrlwr(str); \n\nprintf(\"The lowercase is :%s\\n\",str); \n\ngetch(); \n\n} \n\nC PROGRAMMING \nPage 126 \n\n\n\n\nOUTPUT : The lowercase is : jbrec \n\nWrite a program to which converts given string in to lowercase. \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nchar str[10]; \n\nint index; \n\nprintf(\"Enter the string:\"); \n\nscanf(\"%s\",str); \n\nfor(index=0;str[index]!='\\0';index++) \n\n{ \n\nif(str[index]>='A' && str[index]<='Z') \n\n\nstr[index]=str[index]+32; \n\n} \n\nprintf(\"After conversionis :%s\",str); \n\ngetch(); \n\n} \n\n\n\nOUTPUT : Enter the string : SUBBAREDDY \n\nAfter conversion string is :subbareddy \n\n\n\n4 : strupr(string) \u2013 String UpperCase : This function is used to converts lower case letters of the \nstring in to upper case letters. \n\nC PROGRAMMING \nPage 127 \n\n\nSyntax : strupr(string); \n\nProgram using strupr() function. \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\nchar str[]=\"jbrec\"; \n\nstrupr(str); \n\nprintf(\"UpperCase is :%s\\n\",str); \n\ngetch(); \n\n} \n\n\n\nOUTPUT : UpperCase is : JBREC \n\nWrite a program to which converts given string in to uppercase. \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\nchar str[10]; \n\nint index; \n\nprintf(\"Enter the string:\"); \n\nscanf(\"%s\",str); \n\nfor(index=0;str[index]!='\\0';index++) \n\n{ \n\nC PROGRAMMING \nPage 128 \n\n\nif(str[index]>='a' && str[index]<='z') \n\n\nstr[index]=str[index]-32; \n\n} \n\nprintf(\"After conversionis :%s\",str); \n\ngetch(); \n\n} \n\nOUTPUT : Enter the string : subbareddy \n\nAfter conversion string is :SUBBAREDDY \n\n5 : strcmp(string1,string2) \u2013 String Comparision : This function is used to compares two strings \nto find out whether they are same or different. If two strings are compared character by character \nuntil the end of one of the string is reached. If the two strings are same strcmp() returns a value \nzero. If they are not equal, it returns the numeric difference between the first non-matching \ncharacters. \n\nSyntax : strcmp(string1,string2); \n\nProgram using strcmp() function \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\nchar str1[]=\"reddy\"; \n\nchar str2[]=\"reddy\"; \n\nint i,j,k; \n\ni=strcmp(str1,str2); \n\nj=strcmp(str1,\"subba\"); \n\nk=strcmp(str2,\"Subba\"); \n\nprintf(\"%5d%5d%5d\\n\",i,j,k); \n\nC PROGRAMMING \nPage 129 \n\n\n} \n\nOUTPUT : 0  -1  32 \n\nWrite a C program to find the comparision of two strings. \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\nchar str1[10],str2[20]; \n\nint index,l1,l2,flag=1; \n\nprintf(\"Enter first string:\"); \n\nscanf(\"%s\",str1); \n\nprintf(\"Enter second string:\"); \n\nscanf(\"%s\",str2); \n\nl1=strlen(str1); \n\nl2=strlen(str2); \n\nprintf(\"Length of string1:%d\\n\",l1); \n\nprintf(\"Length of string2:%d\\n\",l2); \n\nif(l1==l2) \n\n{ \n\nfor(index=0;str1[index]!='\\0';index++) \n\n{ \n\nif(str1[index]!=str2[index]) \n\n{ \n\n\nflag=0; \n\nC PROGRAMMING \nPage 130 \n\n\n\nbreak; \n\n} \n\n} \n\n} \n\nelse \n\nflag=0; \n\nif(flag==1) \n\nprintf(\"Strings are equal\"); \n\nelse \n\nprintf(\"Strings are not equal\"); \n\n} \n\nOUTPUT : Enter the first string :jbrec \n\nEnter the second string:jbrec \n\nLength of string1 :5 \n\nLength of string2 :5 \n\nStrings are equal \n\n6: strcat(string1,string2) \u2013 String Concatenation : This function is used to concatenate or \ncombine, two strings together and forms a new concatenated string. \n\nSyntax : strcat(sting1,string2); \n\nWhere \n\nstring1 : is the firdt string1. \n\nstring2 : is the second string2 \n\nwhen the above function is executed, string2 is combined with string1 and it \nremoves the null character (\\0) of string1 and places string2 from there. \n\n\n\n\n\nC PROGRAMMING \nPage 131 \n\n\nProgram using strcat() function. \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\nchar str1[10]=\"jbrec\"; \n\nchar str2[]=\"ece\"; \n\nstrcat(str1,str2); \n\nprintf(\"%s\\n\",str1); \n\nprintf(\"%s\\n\",str2); \n\ngetch(); \n\n} \n\n\n\nOUTPUT : jbrecece \n\nece \n\n7 : strrev(string) - String Reverse :This function is used to reverse a string. This function takes \nonly one argument and return one argument. \n\nSyntax : strrev(string); \n\nEx : Program using strrev() function \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nvoid main() \n\n{ \n\n\n![Image](/src/assets/generated_images/cp_p131_i0.png)\nC PROGRAMMING \nPage 132 \n\n\nchar str[20]; \n\nprintf(\"Enter the string:\"); \n\nscanf(\"%s\",str); \n\nprintf(\"The string reversed is:%s\",strrev(str)); \n\ngetch(); \n\n} \n\n\n\nOUTPUT : Enter the string :subbareddy \n\nThe string reversed is : ydderabbus \n\n\n\nUNIT \u2013 III \n\n\n\nFUNCTIONS: \n\n\n\nUser \u2010 Defined Functions \n\nDefinition : A function is a block of code/group of statements/self contained block of statements/ \nbasic building blocks in a program that performs a particular task. It is also known \nas procedure or subroutine or module , in other programming languages. \n\nTo perform any task, we can create function. A function can be called many times. It \nprovides modularity and code reusability . \n\nC PROGRAMMING \nPage 133 \n\n\nAdvantage of functions \n\n1) Code Reusability \n\nBy creating functions in C, you can call it many times. So we don't need to write the same code \nagain and again. \n\n2) Code optimization \n\nIt makes the code optimized we don't need to write much code. \n\n3) Easily to debug the program. \n\n\nExample: Suppose, you have to check 3 numbers (781, 883 and 531) whether it is prime number or \nnot. Without using function, you need to write the prime number logic 3 times. So, there is repetition of \ncode. \n\nBut if you use functions, you need to write the logic only once and you can reuse it several times. \n\n\n\nTypes of Functions \n\nThere are two types of functions in C programming: \n\n1. Library Functions : are the functions which are declared in the C header files such as \n\nscanf(), printf(), gets(), puts(), ceil(), floor() etc. You just need to include appropriate \nheader files to use these functions. These are already declared and defined in C \nlibraries. oints to be Remembered \n\nSystem defined functions are declared in header files \n\nSystem defined functions are implemented in .dll files. (DLL stands for Dynamic Link \nLibrary). \n\nTo use system defined functions the respective header file must be included. \n\n2. User-defined functions : are the functions which are created by the C programmer, so \n\nthat he/she can use it many times. It reduces complexity of a big program and optimizes \nthe code. Depending upon the complexity and requirement of the program, you can create \nas many user-defined functions as you want. \n\n\n\n\n![Image](/src/assets/generated_images/cp_p133_i0.png)\nC PROGRAMMING \nPage 134 \n\n\n\n\n\n\n\n\n\nELEMENTS OF USER-DEFINED FUNCTINS : \n\nIn order to write an efficient user defined function, the programmer must familiar with the \nfollowing three elements. \n\n\n\n1 : Function Declaration. (Function Prototype). \n\n2 : Function Call. \n\n3 : Function Definition \n\nFunction Declaration. (Function Prototype). \n\nA function declaration is the process of tells the compiler about a function name. \n\nSyntax \n\nreturn_type  function_name(parameter/argument); \n\nreturn_type function-name(); \n\nEx : int add(int a,int b); \n\nint add(); \n\nC PROGRAMMING \nPage 135 \n\n\nNote: At the time of function declaration function must be terminated with ; . \n\nCalling a function/function call \n\nWhen we call any function control goes to function body and execute entire code. \n\nSyntax :   function-name(); \n\nfunction-name(parameter/argument); \n\nreturn value/ variable = function-name(parameter/argument); \n\n\n\nEx :     add();                // function without parameter/argument \n\nadd(a,b);           // function with parameter/argument \n\nc=fun(a,b);       // function with parameter/argument and return values \n\n\n\nDefining a function. \n\nDefining of function is nothing but give body of function that means write logic inside function \nbody. \n\nSyntax \n\nreturn_ type function-name(parameter list) // function header. \n\n{ \n\ndeclaration of variables; \n\nbody of function; // Function body \n\nreturn statement; (expression or value)  // optional \n\n} \n\nEg: \n\nint   add( int x, int y) \n\n\nint add( int x, int y) \n\n\n\n{ \n\n\n\n\n\n\n{ \n\n\n\n\nint z; \n( or ) \n\n\nreturn ( x + y ); \n\n\n\n\nz = x + y; \n\n\n\n\n} \n\n\n\n![Image](/src/assets/generated_images/cp_p135_i0.png)\nC PROGRAMMING \nPage 136 \n\n\n\n\n\nreturn z; \n\n\n\n\n\n\n} \n\n\n\n\n\nThe execution of a C program begins from the main() function. \n\nWhen the compiler encounters functionName(); inside the main function, control of the program \njumps to \n\nvoid functionName() \n\nAnd, the compiler starts executing the codes inside the user-defined function. \n\nThe control of the program jumps to statement next to functionName(); once all the codes inside \nthe function definition are executed. \n\nExample: \n\n#include<stdio.h> \n\nC PROGRAMMING \nPage 137 \n\n\n#include<conio.h> \n\n\n\nvoid sum(); // declaring a function \n\nclrsct(); \n\nint a=10,b=20, c; \n\nvoid sum()  // defining function \n\n{ \n\nc=a+b; \n\nprintf(\"Sum: %d\", c); \n\n} \n\nvoid main() \n\n{ \n\nsum();  // calling function \n\n} \n\nOutput \n\nSum:30 \n\nExample: \n\n#include <stdio.h> \n\nint addNumbers(int a, int b);         // function prototype \n\nint main() \n\n{ \n\nint n1,n2,sum; \n\nprintf(\"Enters two numbers: \"); \n\nscanf(\"%d %d\",&n1,&n2); \n\nsum = addNumbers(n1, n2);        // function call \n\n\n![Image](/src/assets/generated_images/cp_p137_i0.png)\nC PROGRAMMING \nPage 138 \n\n\nprintf(\"sum = %d\",sum); \n\nreturn 0; \n\n} \n\nint addNumbers(int a,int b)         // function definition \n\n{ \n\nint result; \n\nresult = a+b; \n\nreturn result;                  // return statement \n\n} \n\n\n\n\n\nReturn Statement \n\n\n![Image](/src/assets/generated_images/cp_p138_i0.png)\nC PROGRAMMING \nPage 139 \n\n\nSyntax of return statement \n\n\n\nSyntax : return;      // does not return any value \n\nor \n\nreturn(exp);  // the specified exp value to calling function. \n\n\n\nFor example, \n\nreturn a; \n\nreturn (a+b); \n\nThe return statement terminates the execution of a function and returns a value to the calling \nfunction. The program control is transferred to the calling function after return statement. \n\nIn the above example, the value of variable result is returned to the variable sum in \nthe main() function. \n\n\n\nPARAMETERS : \n\nparameters provides the data communication between the calling function and called function. \n\n\n\nThey are two types of parametes \n\nC PROGRAMMING \nPage 140 \n\n\n1 : Actual parameters. \n\n2 : Formal parameters. \n\n1 : Actual Parameters : These are the parameters transferred from the calling function (main \nprogram) to the called function (function). \n\n2 : Formal Parameters : These are the parameters transferred into the calling function (main \nprogram) from the called function(function). \n\n\uf0b7 \nThe parameters specified in calling function are said to be Actual Parameters. \n\n\uf0b7 \nThe parameters declared in called function are said to be Formal Parameters. \n\n\uf0b7 \nThe value of actual parameters is always copied into formal parameters. \n\n\n\nEx : main() \n\n{ \n\nfun1( a , b ); //Calling function \n\n} \n\nfun1( x, y ) //called function \n\n{ \n\n. . . . .  . \n\n} \n\nWhere \n\na, b are the Actual Parameters \n\nx, y are the Formal Parameters \n\n\n\nDifference between Actual Parameters and Formal Parameters \n\nActual Parameters \nFormal Parameters \n\n1 : Actual parameters are used in calling \nfunction when a function is invoked. \n\n1 : Formal parameters are used in the \nfunction header of a called function. \n\nC PROGRAMMING \nPage 141 \n\n\nEx : c=add(a,b); \n\nHere a,b are actual parameters. \n\nEx : int add(int m,int n); \n\nHere m,n are called formal parameters. \n\n2 : Actual parameters can be constants, \nvariables or expression. \n\nEx : c=add(a,b) //variable \n\nc=add(a+5,b); //expression. \n\nc=add(10,20); //constants. \n\n2 : Formal parametes should be only \nvariable. Expression and constants are not \nallowed. \n\nEx : int add(int m,n); //CORRECT \n\nint add(int m+n,int n) //WRONG \n\nint add(int m,10); //WRONG \n\n3 : A ctual parameters sends values to the \nformal parameters. \n\nEx : c=add(4,5); \n\n3 : Formal parametes receive values from \nthe actual parametes. \n\nEx : int add(int m,int n); \n\nHere m will have the value 4 and n will \nhave the value 5. \n\n4 : Address of actual parameters can be sent \nto formal parameters \n\n4 : if formal parameters contains address, \nthey should be declared as pointers. \n\n\n\nPASSING PARAMETERS TO FUNCTIONS : There are two ways to pass value or data to \nfunction in C language: call by value and call by reference . Original value is not modified in \n\n\n![Image](/src/assets/generated_images/cp_p141_i0.png)\nC PROGRAMMING \nPage 142 \n\n\ncall by value but it is modified in call by reference. \n\n\n\n\n\n\n\nThe called function receives the information from the calling function through the parameters. \nThe variables used while invoking the calling function are called actual parameters and the \nvariables used in the function header of the called function are called formal parameters. \n\nC provides two mechanisms to pass parameters to a function. \n\n\n\n1 : Pass by value (OR) Call by value. \n\n2 : Pass by reference (OR) Call by Reference. \n\n1 : Pass by value (OR) Call by value : \n\nIn call by value, value being passed to the function is locally stored by the function parameter in \nstack memory location. If you change the value of function parameter, it is changed for the \ncurrent function only. It will not change the value of variable inside the caller method such as \nmain(). \n\nOr \n\nC PROGRAMMING \nPage 143 \n\n\nWhen a function is called with actual parameters, the values of actual parameters are copied into \nformal parameters. If the values of the formal parametes changes in the function, the values of \nthe actual parameters are not changed. This way of passing parameters is called pass by value or \ncall by value. \n\nEx : \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid swap(int ,int ); \n\nvoid main() \n\n{ \n\nint i,j; \n\nprintf(\"Enter i and j values:\"); \n\nscanf(\"%d%d\",&i,&j); \n\nprintf(\"Before swapping:%d%d\\n\",i,j); \n\nswap(i,j); \n\nprintf(\"After swapping:%d%d\\n\",i,j); \n\ngetch(); \n\n} \n\nvoid swap(int a,int b) \n\n{ \n\nint temp; \n\ntemp=a; \n\na=b; \n\nb=temp; \n\n} \n\nOutput \n\nC PROGRAMMING \nPage 144 \n\n\nEnter i and j values: 10 20 \n\nBefore swapping: 10 20 \n\nAfter swapping: 10 20 \n\n2 : Pass by reference (OR) Call by Reference  : In pass by reference, a function is called with \naddresses of actual parameters. In the function header, the formal parameters receive the \naddresses of actual parameters. Now the formal parameters do not contain values, instead  they \ncontain addresses. Any variable if it contains an address, it is called a pointer variable. Using \npointer variables, the values of the actual parameters can be changed. This way of passing \nparameters is called call by reference or pass by reference. \n\nEx : #include<stdio.h> \n\n#include<conio.h> \n\nvoid swap(int *,int *); \n\nvoid main() \n\n{ \n\nint i,j; \n\nprintf(\"Enter i and j values:\"); \n\nscanf(\"%d%d\",&i,&j); \n\nprintf(\"Before swapping:%d%d\\n\",i,j); \n\nswap(&i ,&j); \n\nprintf(\"After swapping:%d%d\\n\",i,j); \n\n} \n\nvoid swap(int *a,int *b) \n\n{ \n\nint temp; \n\ntemp=*a; \n\n*a=*b; \n\n*b=temp; \n\nC PROGRAMMING \nPage 145 \n\n\n} \n\nOutput \n\nEnter i and j values: 10 20 \n\nBefore swapping:10  20 \n\nAfter swapping: 20 10 \n\nDiffernce between Call by value and Call by reference \n\nCall by value \nCall by Reference \n\n1 : When a function is called the values of \nvariables are passed \n\n1 : When a function is called the address of \nvariables are passed. \n\n2 : Change of formal parameters in the \nfunction will not affect the actual \nparameters in the calling function. \n\n2 : The actual parameters are changed since \nthe formal parameters indirectly manipulate \nthe actual parametes. \n\n3 : Execution is slower since all the values \nhave to be copied into formal parameters. \n\n3 : Execution is faster since only address \nare copied. \n\n1 : Functions with no Parameters and no Return Values. \n\n2 : Functions with no Parameters and Return Values. \n\n3 : Functions with Parameters and no Return Values. \n\n4 : Functions with Parameters and Return Values. \n\n\n\n1 : Functions with no Parameters and no Return Values : \n\n1 : In this category, there is no data transfer between the calling function and called function. \n\n2 : But there is flow of control from calling function to the called function. \n\n3 : When no parameters are there , the function cannot receive any value from the calling \nfunction. \n\n4: When the function does not return a value, the calling function cannot receive any value from \nthe called function. \n\nEx #include<stdio.h> \n\nC PROGRAMMING \nPage 146 \n\n\n#include<conio.h> \n\nvoid sum(); \n\nvoid main() \n\n{ \n\nsum(); \n\ngetch(); \n\n} \n\nvoid sum() \n\n{ \n\nint a,b,c; \n\nprintf(\"enter the values of a and b\"); \n\nscanf(\"%d%d\",&a,&b); \n\nc=a+b; \n\nprintf(\"sum=%d\",c); \n\n} \n\n2 : Functions with no Parameters and Return Values. \n\n1 : In this category, there is no data transfer between the calling function and called function. \n\n2 : But there is data transfer from called function to the calling function. \n\n3 : When no parameters are there , the function cannot receive any values from the calling \nfunction. \n\n4: When the function returns a value, the calling function receives one value from the called \nfunction. \n\n\n\nEx :                      #include<stdio.h> \n\n#include<conio.h> \n\nint sum(); \n\nC PROGRAMMING \nPage 147 \n\n\nvoid main() \n\n{ \n\nint c; \n\nclrscr(); \n\nc=sum(); \n\nprintf(\"sum=%d\",c); \n\ngetch(); \n\n} \n\nint sum() \n\n{ \n\nint a,b,c; \n\nprintf(\"enter the values of a and b\"); \n\nscanf(\"%d%d\",&a,&b); \n\nc=a+b; \n\nreturn c; \n\n} \n\n3 : Functions with Parameters and no Return Values. \n\n1 : In this category, there is data transfer from the calling function to the called function using \nparameters. \n\n2 : But there is no data transfer from called function to the calling function. \n\n3 : When  parameters are there , the function can receive any values from the calling function. \n\n4: When the function does not return a value, the calling function cannot receive any value from \nthe called function. \n\n\n\nEx : #include<stdio.h> \n\n#include<conio.h> \n\nC PROGRAMMING \nPage 148 \n\n\nvoid sum(int a,int b); \n\nvoid main() \n\n{ \n\nint m,n; \n\nclrscr(); \n\nprintf(\"Enter m and n values:\"); \n\nscanf(\"%d%d\",&m,&n); \n\nsum(m,n); \n\ngetch(); \n\n} \n\nvoid sum(int a,int b) \n\n{ \n\nint c; \n\nc=a+b; \n\nprintf(\"sum=%d\",c); \n\n} \n\n4 : Functions with Parameters and Return Values. \n\n1 : In this category, there is data transfer from the calling function to the called function using \nparameters. \n\n2 : But there is no data transfer from called function to the calling function. \n\n3 : When  parameters are there , the function can receive any values from the calling function. \n\n4: When the function returns a value, the calling function receive a value from the called \nfunction. \n\nEx :                                  #include<stdio.h> \n\n#include<conio.h> \n\nint sum(int a,int b); \n\nC PROGRAMMING \nPage 149 \n\n\nvoid main() \n\n{ \n\nint m,n,c; \n\nclrscr(); \n\nprintf(\"Enter m and n values\"); \n\nscanf(\"%d%d\",&m,&n); \n\nc=sum(m,n); \n\nprintf(\"sum=%d\",c); \n\ngetch(); \n\n} \n\nint sum(int a,int b) \n\n{ \n\nint c; \n\nc=a+b; \n\nreturn c; \n\n} \n\n\n\nInter \u2010 Function Communication \n\nWhen a function gets executed in the program, the execution control is transferred from calling \nfunction to called function and executes function definition, and finally comes back to the calling \nfunction. In this process, both calling and called functions have to communicate each other to \nexchange information. The process of exchanging information between calling and called \nfunctions is called as inter function communication. \n\nIn C, the inter function communication is classified as follows... \n\n\uf0b7 \nDownward Communication \n\n\uf0b7 \nUpward Communication \n\n\n![Image](/src/assets/generated_images/cp_p149_i0.png)\nC PROGRAMMING \nPage 150 \n\n\n\uf0b7 \nBi-directional Communication \n\n\n\n\n\nDownward Communication \n\nIn this type of inter function communication, the data is transferred from calling function to \ncalled function but not from called function to calling function. The functions with parameters \nand without return value are considered under downward communication. In the case of \ndownward communication, the execution control jumps from calling function to called function \nalong with parameters and executes the function definition,and finally comes back to the calling \nfunction without any return value. For example consider the following program... \n\nExample: \n\n#include <stdio.h> \n\n#include<conio.h> \n\nvoid main(){ \n\nint num1, num2 ; \n\nvoid addition(int, int) ; // function declaration \n\nclrscr() ; \n\nnum1 = 10 ; \n\nnum2 = 20 ; \n\nprintf(\"\\nBefore swap: num1 = %d, num2 = %d\", num1, num2) ; \n\naddition(num1, num2) ; // calling function \n\ngetch() ; \n\nC PROGRAMMING \nPage 151 \n\n\n} \n\nvoid addition(int a, int b)  // called function \n\n{ \n\nprintf(\"SUM = %d\", a+b) ; \n\n} \n\nOutput \n\nSUM=30 \n\n\n\nUpward Communication \n\nIn this type of inter function communication, the data is transferred from called function to \ncalling function but not from calling function to called function. The functions without \nparameters and with return value are considered under upward communication. In the case of \nupward communication, the execution control jumps from calling function to called function \nwithout parameters and executes the function definition, and finally comes back to the calling \nfunction along with a return value. For example consider the following program... \n\nExmaple: \n\n#include <stdio.h> \n\n#include<conio.h> \n\nvoid main(){ \n\nint result ; \n\nint addition() ; // function declaration \n\nclrscr() ; \n\nresult = addition() ; // calling function \n\nprintf(\"SUM = %d\", result) ; \n\ngetch() ; \n\n} \n\nint addition()  // called function \n\nC PROGRAMMING \nPage 152 \n\n\n{ \n\nint num1, num2 ; \n\nnum1 = 10; \n\nnum2 = 20; \n\nreturn (num1+num2) ; \n\n} \n\nOutput \n\nSUM=30 \n\n\n\nBi - Directional Communication \n\nIn this type of inter function communication, the data is transferred from calling function to \ncalled function and also from called function to calling function. The functions with parameters \nand with return value are considered under bi-directional communication. In the case of bi- \ndrectional communication, the execution control jumps from calling function to called function \nalong with parameters and executes the function definition, and finally comes back to the calling \nfunction along with a return value. For example consider the following program... \n\nExample: \n\n#include <stdio.h> \n\n#include<conio.h> \n\nvoid main(){ \n\nint num1, num2, result ; \n\nint addition(int, int) ; // function declaration \n\nclrscr() ; \n\nnum1 = 10 ; \n\nnum2 = 20 ; \n\nresult = addition(num1, num2) ; // calling function \n\nprintf(\"SUM = %d\", result) ; \n\nC PROGRAMMING \nPage 153 \n\n\ngetch() ; \n\n} \n\nint addition(int a, int b)  // called function \n\n{ \n\nreturn (a+b) ; \n\n} \n\nOutput \n\nSUM=30 \n\nStandard Functions \n\nThe standard functions are built-in functions. In C programming language, the standard functions \nare declared in header files and defined in .dll files. In simple words, the standard functions can \nbe defined as \"the ready made functions defined by the system to make coding more easy\". The \nstandard functions are also called as library functions or pre-defined functions. \n\nIn C when we use standard functions, we must include the respective header file \nusing #include statement. \nFor \nexample, \nthe \nfunction printf() is \ndefined \nin \nheader \nfile stdio.h (Standard Input Output header file). When we use printf() in our program, we must \ninclude stdio.h header file using #include<stdio.h> statement. \n\nC Programming Language provides the following header files with standard functions. \n\nHeader \nFile \nPurpose \nExample Functions \n\nstdio.h \nProvides functions to perform standard I/O operations \nprintf(), scanf() \n\nconio.h \nProvides functions to perform console I/O operations \nclrscr(), getch() \n\nmath.h \nProvides functions to perform mathematical operations \nsqrt(), pow() \n\nstring.h \nProvides functions to handle string data values \nstrlen(), strcpy() \n\nstdlib.h \nProvides functions to perform general functions \ncalloc(), malloc() \n\nC PROGRAMMING \nPage 154 \n\n\ntime.h \nProvides functions to perform operations on time and \ndate \ntime(), localtime() \n\nctype.h \nProvides functions to perform - testing and mapping of \ncharacter data values \nisalpha(), islower() \n\nsetjmp.h \nProvides functions that are used in function calls \nsetjump(), \nlongjump() \n\nsignal.h \nProvides functions to handle signals during program \nexecution \nsignal(), raise() \n\nassert.h \nProvides Macro that is used to verify assumptions made \nby the program \nassert() \n\nlocale.h \nDefines the location specific settings such as date \nformats and currency symbols \nsetlocale() \n\nstdarg.h \nUsed to get the arguments in a function if the arguments \nare not specified by the function \n\nva_start(), va_end(), \nva_arg() \n\nerrno.h \nProvides macros to handle the system calls \nError, errno \n\nfloat.h \nProvides constants related to floating point data values \n\n\n\nlimits.h \nDefines the maximum and minimum values of various \nvariable types like char, int and long \n\n\nstddef.h \nDefines various variable types \n\n\n\ngraphics.h \nProvides functions to draw graphics. \ncircle(), rectangle() \n\n\n\nSTANDARD \u201eC\u201f LIBRARY FUNCTIONS \n\n1 : stdio.h \n\n2 : stdlib.h \n\nC PROGRAMMING \nPage 155 \n\n\n3 : string.h \n\n4 : math.h \n\n5 : ctype.h \n\n6 : time.h \n\n\n\n1 : STANDARD I/O LIBRARY FUNCTIONS  <STDIO.H> \n\nFunctions \nDataType \nPurpose \n\nprintf() \nint \nSend data items to the standared output device. \n\nscanf() \nint \nEnter data items from the standard input device. \n\ngets(s) \nchar \nEnter string s from the standard input device. \n\ngetc(f) \nint \nEnter a string character from file f. \n\ngetchar() \nint \nEnter a single character from the standard input device. \n\nputc(c,f) \nint \nSend a single character to file f. \n\nputs(s) \nint \nSend string s to the standard output device. \n\nputchar(c) \nint \nSend a single character to the standard output device. \n\nfgetc(f) \nint \nEnter a single character from file f. \n\nfgets(s,I,f) \nchar \nEnter string s, containing I characters, from file f. \n\nfprintf(f) \nint \nSend data items to file f. \n\nfscanf(f) \nint \nEnter data items from file f. \n\nfputc(c,f) \nint \nSend a single character to file f. \n\nfputs(s,f) \nint \nSend string s to file f. \n\nfread(s,il,i2,f) int \nEnter i2 data items, each of size i1 bytes, from file f. \n\nfclose(f) \nint \nClose file f, return 0 if file is successfully closed. \n\n\n\n2 : STANDARD LIBRARY FUNCTIONS  <STDLIB.H> \n\nC PROGRAMMING \nPage 156 \n\n\nFunctions \nDataType \nPurpose \n\nabs(i) \nint \nReturn the absolute value of i. \n\natof(s) \ndouble \nConvert string s to a double-precesion quantity. \n\ncalloc(u1,u2) void* \nAllocate memory for an array having u1 elements, each of \nlength u2 bytes. Return a pointer to the beginning of the \nallocated space. \n\nexit(u) \nvoid \nClose all files and buffers, and terminate the program. \n\nfree(p) \nvoid \nFree a block of allocated memory whose beginning is \nindicated by p. \n\nmalloc(u) \nvoid* \n\n\nAllocate u bytes of memory. \n\nrand() \nint \nReturn a random positive integer. \n\nrealloc(p,u) \nvoid* \nAllocate u bytes of new memory to the pointer variable p, \nreturn a pointer to the beginning of the new memory space. \n\nsystem(s) \nint \nPass command string s to the operating system. \n\nsrand(u) \nvoid \nInitialize the random number generator. \n\n\n\n\n\n3 : STRING LIBRARY FUNCTIONS  <STRING.H> \n\nFunctions \nDataType \nPurpose \n\nstrlen() \n\nFinds length of string \n\nstrlwr() \n\nConverts a string to lowercase \n\nstrupr() \n\nConverts a string to uppercase \n\nstrcat() \n\nAppends one string at the end of another \n\nstrcpy() \n\nCopies a string into another \n\nstrcmp() \n\nCompares two strings \n\nstrrev() \n\nReverses string \n\nC PROGRAMMING \nPage 157 \n\n\n\n\n\n\n4 : MATH LIBRARY FUNCTIONS  <MATH.H> \n\n\n\nFunctions \nDataType \nPurpose \n\nacos(d) \ndouble \nReturn the arc cosine of d. \n\natan(d) \ndouble \nReturn the arc tangent of d. \n\nasin(d) \ndouble \nReturn the arc sine of d. \n\nceil(d) \ndouble \nReturn a value rounded up to the next higher integer. \n\ncos(d) \ndouble \nReturn the cosine of d. \n\ncosh(d) \ndouble \nReturn the hyperbolic cosine of d. \n\nexp(d) \ndouble \nRaise e to the power d. \n\nfabs(d) \ndouble \nReturn the absolute value of d. \n\nfloor(d) \ndouble \nReturn a value rounded down to the next lower integer. \n\nlabs(l) \nlong int \nReturn the absolute value of l. \n\nlog(d) \ndouble \nReturn the natural logarithm of d. \n\npow(d1,d2) \ndouble \nReturn d1 raised to the d2 power. \n\nsin(d) \ndouble \nReturn the sine of d. \n\nsqrt(d) \ndouble \nReturn squre root of d. \n\ntan(d) \ndouble \nReturn the tangent of d. \n\n\n\n5 : CHARACTER LIBRARY FUNCTIONS  <CTYPE.H> \n\n\n\nFunctions \nDataType \nPurpose \n\nC PROGRAMMING \nPage 158 \n\n\nisalnum(c) \nInt \nDetermine if argument is alphanumeric. Return nonzero value \nif true, 0 otherwise. \n\nisalpha(c) \nInt \nDetermine if argument is alphabetic. Return nonzero value if \ntrue, 0 otherwise. \n\nisascii(c) \nInt \nDetermine if argument is an ASCII character,. Return nonzero \nvalue if true, 0 otherwise. \n\nisdigit(c) \nInt \nDetermine if argument is a decimal digit. Return nonzero \nvalue if true, 0 otherwise. \n\nisgraph(c) \nInt \nDetermine if argument is a graphic printing ASCII Character. \nReturn nonzero value if true, 0 otherwise. \n\nislower(c) \nInt \nDetermine if argument is lowercase. Return nonzero value if \ntrue, 0 otherwise. \n\nisprint(c) \nInt \nDetermine if argument is a printing ASCII character. Return \nnonzero value if true, 0 otherwise. \n\nisspace(c) \nInt \nDetermine if argument is a whitespace character. Return \nnonzero value if true, 0 otherwise. \n\nisupper(c) \nInt \nDetermine if argument is uppercase. Return nonzero value if \ntrue, 0 otherwise. \n\ntoascii(c) \nInt \nConvert value of argument to ASCII \n\ntolower(c) \nInt \nConvert letter to lowercase \n\ntoupper(c) \nInt \nConvert letter to uppercase. \n\n\n\n6 : TIME LIBRARY FUNCTIONS  <TIME.H> \n\nFunctions \nDataType \nPurpose \n\ndifftime(11,12) double \nReturn the time difference 11-12, where 11 and 12 \nrepresent elapsed time beyond a designated base time. \n\ntime(p) \nlong int \nReturn the number of seconds elapsed beyond a designated \nbase time. \n\n\n\nC PROGRAMMING \nPage 159 \n\n\nStorage Classes \n\nIn C language, each variable has a storage class which is used to define scope and life time of a \nvariable. \n\nStorage: Any variable declared in a program can be stored either in memory or registers. \nRegisters are small amount of storage in CPU. The data stored in registers has fast access \ncompared to data stored in memory. \n\nStorage class of a variable gives information about the location of the variable \nin which it is stored, initial value of the variable, if storage class is not specified; scope of the \nvariable; life of the variable. \n\n\n\nThere are four storage classes in C programming. \n\n1 : Automatic Storage class. \n\n2 : Register Storage class. \n\n3 : Static Storage class. \n\n4 : External Storage class. \n\n1: Automatic Storage class : To define a variable as automatic storage class, the keyword \u201eauto\u201f \nis used. By defining a variable as automatic storage class, it is stored in the memory. The default \nvalue of the variable will be garbage value. Scope of the variable is within the block where it is \ndefined and the life of the variable is until the control remains within the block. \n\nSyntax : auto data_type variable_name; \n\nauto int a,b; \n\nExample: \n\nvoid main() \n\n{ \n\nint detail; \n\nor \n\nauto int detail; //Both are same \n\n} \n\nC PROGRAMMING \nPage 160 \n\n\nThe variables a and b are declared as integer type and auto. The keyword auto is \nnot mandatory. Because the default storage class in C is auto. \n\nNote: A variable declared inside a function without any storage class specification, is by default \nan automatic variable. Automatic variables can also be called local variables because they \nare local to a function. \n\n\n\nEx : void function1(); \n\nvoid function2();                                    OUTPUT \n\nvoid main()                                                10 \n\n{                                                                 0 \n\nint x=100;                                            100 \n\nfunction2(); \n\nprintf(\u201c%d\u201d,x); \n\n} \n\nvoid function1() \n\n{ \n\nint x=10; \n\nprintf(\u201c%d\u201d,x); \n\n} \n\nvoid function2() \n\n{ \n\nint x=0; \n\nfunction1(); \n\nprintf(\u201c%d\u201d,x); \n\n} \n\n2: Register Storage class : To define a variable as register storage class, the keyword \n\u201eregister\u201f is used. If  CPU cannot store the variables in CPU registers, then the variables are \n\nC PROGRAMMING \nPage 161 \n\n\nassumed as auto and stored in the memory. When a variable is declared as register, it is stored \nin the CPU registers. The default value of the variable will be garbage value . Scope of the \nvariable within the block where it is defined and the life of the variables is until the control \nremains within the block. \n\nRegister variable has faster access than normal variable. Frequently used variables are kept in \nregister. Only few variables can be placed inside register. \n\nNOTE : We can't get the address of register variable \n\nSytax : register data_type variable_name; \n\nEx: register int i; \n\nEx : void demo(); OUTPUT \n\nvoid main() 20 \n\n{                                                              20 \n\ndemo();                                              20 \n\ndemo(); \n\ndemo(); \n\n} \n\nvoid demo() \n\n{ \n\nregister int i=20; \n\nprintf(\u201c%d\\n\u201d,i); \n\ni++; \n\n} \n\n3 : Static Storage class : When a variable is declared as static, it is stored in the memory. The \ndefault value of the variable will be zero . Scope of the variable is within the block where it is \ndefined and the life of the variable persists between different function calls. To define a variable \nas static storage class, the keyword \u201estatic\u201f is used . A static variable can be initialized only \nonce, it cannot be reinitialized. \n\nSyntax :        static data_type variable_name; \n\nC PROGRAMMING \nPage 162 \n\n\nEx: static int i; \n\nEx : void demo();                                     OUTPUT \n\nvoid main()                                            20 \n\n{                                                              21 \n\ndemo();                                              22 \n\ndemo(); \n\ndemo(); \n\n} \n\nvoid demo() \n\n{ \n\nstatic  int i=20; \n\nprintf(\u201c%d\u201d,i); \n\ni++; \n\n} \n\n\n\n4 : External Storage class : When a variable is declared as extern , it is stored in the memory. \nThe default value is initialized to zero . The scope of the variable is global and the life of the \nvariable is until the program execution comes to an end. To define a variable as external storage \nclass, the keyword \u201eextern\u201f is used. An extern variable is also called as a global variable. \nGlobal variables remain available throughout the entire program. One important thing to \nremember about global variable is that their values can be changed by any function in the \nprogram. \n\n\n\nSystax : extern data_type variable_name; \n\nextern int i; \n\n\n\nEx: \n\nC PROGRAMMING \nPage 163 \n\n\nint number; \n\nvoid main() \n\n{ \n\nnumber=10; \n\n} \n\nfun1() \n\n{ \n\nnumber=20; \n\n} \n\nfun2() \n\n{ \n\nnumber=30; \n\n} \n\nHere the global variable number is available to all three functions. \n\n\n\n\n\nEx : void fun1(); \n\nvoid fun2(); \n\nint e=20; \n\nvoid main() \n\n{ \n\nfun1(); \n\nfun2(); \n\n} \n\nvoid fun1() \n\nC PROGRAMMING \nPage 164 \n\n\n{ \n\nextern int e; \n\nprintf(\u201ce number is :%d\u201d,e); \n\n} \n\nvoid fun2() \n\n{ \n\nprintf(\u201ce number is :%d\u201d,e); \n\n} \n\nextern keyword \n\nThe extern keyword is used before a variable to inform the compiler that this variable is declared \nsomewhere else. The extern declaration does not allocate storage for variables. \n\nProblem when extern is not used \n\nmain() \n\n{ \n\na = 10;      //Error:cannot find variable a \n\nprintf(\"%d\",a); \n\n} \n\n\n\nExample Using extern in same file \n\nmain() \n\n{ \n\nextern int x; //Tells compiler that it is defined somewhere else \n\nx = 10; \n\nprintf(\"%d\",x); \n\n} \n\n\n![Image](/src/assets/generated_images/cp_p164_i0.png)\nC PROGRAMMING \nPage 165 \n\n\nint x; //Global variable x \n\n\n\n\n\n\n\n\n\n\n\nStorage \nClasses \n\nStorage \nPlace \n\nDefault \nValue \n\nScope \nLife-time \n\nauto \nRAM \nGarbage \n\nValue \n\nLocal \nWithin function \n\nextern \nRAM \nZero \nGlobal \nTill the end of main program, May be \n\ndeclared anywhere in the program \n\nstatic \nRAM \nZero \nLocal \nTill the end of main program, Retains \n\nvalue between multiple functions call \n\nregister \nRegister \nGarbage \n\nValue \n\nLocal \nWithin function \n\n\n\n\n\nC PROGRAMMING \nPage 166 \n\n\n\n\nRecursion \n\nWhen function is called within the same function , it is known as recursion in C. The function \nwhich calls the same function, is known as recursive function. \n\nA function that calls itself, and doesn't perform any task after function call, is know as tail \nrecursion. In tail recursion, we generally call the same function with return statement. \n\nFeatures : \n\n\uf0b7 There should be at least one if statement used to terminate recursion. \n\n\uf0b7 It does not contain any looping statements. \n\nAdvantages : \n\n\uf0b7 It is easy to use. \n\n\uf0b7 It represents compact programming structures. \n\nDisadvantages : \n\n\uf0b7 It is slower than that of looping statements because each time function is called. \n\nNote: while using recursion, programmers need to be careful to define an exit condition from the \nfunction, otherwise it will go into an infinite loop. Recursive functions are very useful to solve \nmany mathematical problems, such as calculating the factorial of a number, generating Fibonacci \nseries, etc. \n\n\n\nExample of recursion. \n\nrecursionfunction(){ \n\nrecursionfunction();//calling self function \n\n} \n\n\n![Image](/src/assets/generated_images/cp_p166_i0.png)\nC PROGRAMMING \nPage 167 \n\n\n\n\nExample of tail recursion in C \n\n// print factorial number using tail recursion \n\n#include<stdio.h> \n\n#include<conio.h> \n\nint factorial ( int n) \n\n{ \n\nif ( n < 0) \n\nreturn -1; /*Wrong value*/ \n\nif (n == 0) \n\nreturn 1; /*Terminating condition*/ \n\nreturn (n * factorial (n -1)); \n\n} \n\nvoid main(){ \n\n\n![Image](/src/assets/generated_images/cp_p167_i0.png)\nC PROGRAMMING \nPage 168 \n\n\nint fact=0; \n\nclrscr(); \n\nfact=factorial(5); \n\nprintf(\"\\n factorial of 5 is %d\",fact); \n\ngetch();  } Output factorial of 5 is 120 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n![Image](/src/assets/generated_images/cp_p168_i0.png)\n\n![Image](/src/assets/generated_images/cp_p168_i1.png)\nC PROGRAMMING \nPage 169 \n\n\nPreprocessor Commands \n\n\n\nA program in C language involves into different processes. Below diagram will help you to \nunderstand all the processes that a C program comes across. \n\n\n\nThe C Preprocessor is not a part of the compiler, but is a separate step in the compilation \nprocess. In simple terms, a C Preprocessor is just a text substitution tool and it instructs the \n\nC PROGRAMMING \nPage 170 \n\n\ncompiler to do required pre-processing before the actual compilation. All preprocessor \ncommands begin with a hash symbol (#). \n\nlist of preprocessor directives. \n\no #include \n\no #define \n\no #undef \n\no #ifdef \n\no #ifndef \n\no #if \n\no #else \n\no #elif \n\no #endif \n\no #error \n\no #pragma \n\nC Macros \n\nA macro is a segment of code which is replaced by the value of macro. Macro is defined by \n#define directive. There are two types of macros: \n\n1. Object-like Macros \n\n2. Function-like Macros \n\nObject-like Macros \n\nThe object-like macro is an identifier that is replaced by value. It is widely used to represent \nnumeric constants. For example: \n\n#define PI 3.14 \n\nHere, PI is the macro name which will be replaced by the value 3.14. \n\nFunction-like Macros \n\nThe function-like macro looks like function call. For example: \n\nC PROGRAMMING \nPage 171 \n\n\n#define MIN(a,b) ((a)<(b)?(a):(b)) \n\nHere, MIN is the macro name. \n\nPredefined Macros \n\nThere are some predefined macros which are readily for use in C programming. \n\nNo. \nMacro \nDescription \n\n1 \n_DATE_ \nrepresents current date in \"MMM DD YYYY\" format. \n\n2 \n_TIME_ \nrepresents current time in \"HH:MM:SS\" format. \n\n3 \n_FILE_ \nrepresents current file name. \n\n4 \n_LINE_ \nrepresents current line number. \n\n5 \n_STDC_ \nIt is defined as 1 when compiler complies with the ANSI standard. \n\n\n\n#include <stdio.h> \n\nmain() { \n\nprintf(\"File :%s\\n\", __FILE__ ); \n\nprintf(\"Date :%s\\n\", __DATE__ ); \n\nprintf(\"Time :%s\\n\", __TIME__ ); \n\nprintf(\"Line :%d\\n\", __LINE__ ); \n\nprintf(\"ANSI :%d\\n\", __STDC__ ); \n\n} \n\nOutput \n\nFile :test.c \n\nDate :Jun 2 2012 \n\nTime :03:36:24 \n\nC PROGRAMMING \nPage 172 \n\n\nLine :8 \n\nANSI :1 \n\nC #include \n\nThe #include preprocessor directive is used to paste code of given file into current file. It is used \ninclude system-defined and user-defined header files. If included file is not found, compiler \nrenders error. \n\nBy the use of #include directive, we provide information to the preprocessor where to look for \nthe header files. There are two variants to use #include directive. \n\n1. #include <filename> \n\n2. #include \"filename\" \n\nThe #include <filename> tells the compiler to look for the directory where system header files \nare held. In UNIX, it is \\usr\\include directory. \n\nThe #include \"filename\" tells the compiler to look in the current directory from where program \nis running. \n\n#include directive example \n\nLet's see a simple example of #include directive. In this program, we are including stdio.h file \nbecause printf() function is defined in this file. \n\n1. #include <stdio.h> \n\n2. main() { \n\n3. printf(\"Hello C\"); \n\n4. } \n\nOutput: \n\nHello C \n\n#include notes: \n\nNote 1: In #include directive, comments are not recognized. So in case of #include <a//b>, a//b is \ntreated as filename. \n\nNote 2: In #include directive, backslash is considered as normal text not escape sequence. So in \ncase of #include <a\\nb>, a\\nb is treated as filename. \n\nC PROGRAMMING \nPage 173 \n\n\nNote 3: You can use only comment after filename otherwise it will give error. \n\nC #define \n\nThe #define preprocessor directive is used to define constant or micro substitution. It can use any \nbasic data type. \n\nSyntax: \n\n#define token value \n\nExample of #define to define a constant. \n\n#include <stdio.h> \n\n#define PI 3.14 \n\nmain() { \n\nprintf(\"%f\",PI); \n\n} \n\nOutput: \n\n3.140000 \n\nExample of #define to create a macro. \n\n#include <stdio.h> \n\n#define MIN(a,b) ((a)<(b)?(a):(b)) \n\nvoid main() { \n\nprintf(\"Minimum between 10 and 20 is: %d\\n\", MIN(10,20)); \n\n} \n\nOutput: \n\nMinimum between 10 and 20 is: 10 \n\nC #undef \n\nThe #undef preprocessor directive is used to undefine the constant or macro defined by #define. \n\n\n\nC PROGRAMMING \nPage 174 \n\n\nSyntax: \n\n#undef token \n\nSimple example to define and undefine a constant. \n\n#include <stdio.h> \n\n#define PI 3.14 \n\n#undef PI \n\nmain() { \n\nprintf(\"%f\",PI); \n\n} \n\nOutput: \n\nCompile Time Error: 'PI' undeclared \n\nThe #undef directive is used to define the preprocessor constant to a limited scope so that you \ncan declare constant again. \n\nLet's see an example where we are defining and undefining number variable. But before being \nundefined, it was used by square variable. \n\n#include <stdio.h> \n\n#define number 15 \n\nint square=number*number; \n\n#undef number \n\nmain() { \n\nprintf(\"%d\",square); \n\n} \n\nOutput: \n\n225 \n\n\n\n\n\nC PROGRAMMING \nPage 175 \n\n\nC #ifdef \n\nThe #ifdef preprocessor directive checks if macro is defined by #define. If yes, it \nexecutes the code otherwise #else code is executed, if present. \n\nSyntax: \n\n#ifdef MACRO \n\n//code \n\n#endif \n\nSyntax with #else: \n\n#ifdef MACRO \n\n//successful code \n\n#else \n\n//else code \n\n#endif \n\nC #ifdef example \n\n#include <stdio.h> \n\n#include <conio.h> \n\n#define NOINPUT \n\nvoid main() { \n\nint a=0; \n\n#ifdef NOINPUT \n\na=2; \n\n#else \n\nprintf(\"Enter a:\"); \n\nscanf(\"%d\", &a); \n\n#endif \n\nC PROGRAMMING \nPage 176 \n\n\nprintf(\"Value of a: %d\\n\", a); \n\ngetch(); \n\n} \n\nOutput: \n\nValue of a: 2 \n\nif you don't define NOINPUT, it will ask user to enter a number. \n\n#include <stdio.h> \n\n#include <conio.h> \n\nvoid main() { \n\nint a=0; \n\n#ifdef NOINPUT \n\na=2; \n\n#else \n\nprintf(\"Enter a:\"); \n\nscanf(\"%d\", &a); \n\n#endif \n\nprintf(\"Value of a: %d\\n\", a); \n\ngetch(); \n\n} \n\nOutput: \n\nEnter a:5 \n\nValue of a: 5 \n\n\n\n\n\n\n\nC PROGRAMMING \nPage 177 \n\n\nC #ifndef \n\nThe #ifndef preprocessor directive checks if macro is not defined by #define. If yes, it executes \nthe code otherwise #else code is executed, if present. \n\nSyntax: \n\n#ifndef MACRO \n\n//code \n\n#endif \n\nSyntax with #else: \n\n#ifndef MACRO \n\n//successful code \n\n#else \n\n//else code \n\n#endif \n\nC #ifndef example \n\nsimple example to use #ifndef preprocessor directive. \n\n#include <stdio.h> \n\n#include <conio.h> \n\n#define INPUT \n\nvoid main() { \n\nint a=0; \n\n#ifndef INPUT \n\na=2; \n\n#else \n\nprintf(\"Enter a:\"); \n\nscanf(\"%d\", &a); \n\nC PROGRAMMING \nPage 178 \n\n\n#endif \n\nprintf(\"Value of a: %d\\n\", a); \n\ngetch(); \n\n} \n\nOutput: \n\nEnter a:5 \n\nValue of a: 5 \n\nif you don't define INPUT, it will execute the code of #ifndef. \n\n#include <stdio.h> \n\n#include <conio.h> \n\nvoid main() { \n\nint a=0; \n\n#ifndef INPUT \n\na=2; \n\n#else \n\nprintf(\"Enter a:\"); \n\nscanf(\"%d\", &a); \n\n#endif \n\nprintf(\"Value of a: %d\\n\", a); \n\ngetch(); \n\n} \n\nOutput: \n\nValue of a: 2 \n\n\n\n\n\nC PROGRAMMING \nPage 179 \n\n\nC #if \n\nThe #if preprocessor directive evaluates the expression or condition. If condition is true, it \nexecutes the code otherwise #elseif or #else or #endif code is executed. \n\nSyntax: \n\n#if expression \n\n//code \n\n#endif \n\nSyntax with #else: \n\n#if expression \n\n//if code \n\n#else \n\n//else code \n\n#endif \n\nSyntax with #elif and #else: \n\n#if expression \n\n//if code \n\n#elif expression \n\n//elif code \n\n#else \n\n//else code \n\n#endif \n\nC #if example \n\n#include <stdio.h> \n\n#include <conio.h> \n\n#define NUMBER 0 \n\nC PROGRAMMING \nPage 180 \n\n\nvoid main() { \n\n#if (NUMBER==0) \n\nprintf(\"Value of Number is: %d\",NUMBER); \n\n#endif \n\ngetch(); \n\n} \n\nOutput: \n\nValue of Number is: 0 \n\nAnother example to understand the #if directive clearly. \n\n#include <stdio.h> \n\n#include <conio.h> \n\n#define NUMBER 1 \n\nvoid main() { \n\nclrscr(); \n\n#if (NUMBER==0) \n\nprintf(\"1 Value of Number is: %d\",NUMBER); \n\n#endif \n\n#if (NUMBER==1) \n\nprintf(\"2 Value of Number is: %d\",NUMBER); \n\n#endif \n\ngetch(); \n\n} \n\nOutput: \n\n2 Value of Number is: 1 \n\n\n\nC PROGRAMMING \nPage 181 \n\n\nC #else \n\nThe #else preprocessor directive evaluates the expression or condition if condition of #if is false. \nIt can be used with #if, #elif, #ifdef and #ifndef directives. \n\nSyntax: \n\n#if expression \n\n//if code \n\n#else \n\n//else code \n\n#endif \n\nSyntax with #elif: \n\n#if expression \n\n//if code \n\n#elif expression \n\n//elif code \n\n#else \n\n//else code \n\n#endif \n\nC #else example \n\n#include <stdio.h> \n\n#include <conio.h> \n\n#define NUMBER 1 \n\nvoid main() { \n\n#if NUMBER==0 \n\nprintf(\"Value of Number is: %d\",NUMBER); \n\n#else \n\nC PROGRAMMING \nPage 182 \n\n\nprint(\"Value of Number is non-zero\"); \n\n#endif \n\ngetch(); \n\n} \n\nOutput: \n\nValue of Number is non-zero \n\nC #error \n\nThe #error preprocessor directive indicates error. The compiler gives fatal error if #error \ndirective is found and skips further compilation process. \n\nC #error example \n\n#include<stdio.h> \n\n#ifndef __MATH_H \n\n#error First include then compile \n\n#else \n\nvoid main(){ \n\nfloat a; \n\na=sqrt(7); \n\nprintf(\"%f\",a); \n\n} \n\n#endif \n\nOutput: \n\nCompile Time Error: First include then compile \n\nif you include math.h, it does not gives error. \n\n#include<stdio.h> \n\n#include<math.h> \n\nC PROGRAMMING \nPage 183 \n\n\n#ifndef __MATH_H \n\n#error First include then compile \n\n#else \n\nvoid main(){ \n\nfloat a; \n\na=sqrt(7); \n\nprintf(\"%f\",a); \n\n} \n\n#endif \n\nOutput: \n\n2.645751 \n\nC #pragma \n\nThe #pragma preprocessor directive is used to provide additional information to the compiler. \nThe #pragma directive is used by the compiler to offer machine or operating-system feature. \n\nSyntax: \n\n#pragma token \n\nDifferent compilers can provide different usage of #pragma directive. \n\nThe turbo C++ compiler supports following #pragma directives. \n\n#pragma argsused \n\n#pragma exit \n\n#pragma hdrfile \n\n#pragma hdrstop \n\n#pragma inline \n\n#pragma option \n\n#pragma saveregs \n\nC PROGRAMMING \nPage 184 \n\n\n#pragma startup \n\n#pragma warn \n\nExample to use #pragma preprocessor directive. \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid func() ; \n\n#pragma startup func \n\n#pragma exit func \n\nvoid main(){ \n\nprintf(\"\\nI am in main\"); \n\ngetch(); \n\n} \n\nvoid func(){ \n\nprintf(\"\\nI am in func\"); \n\ngetch(); \n\n} \n\nOutput: \n\nI am in func \n\nI am in main \n\nI am in func \n\nKEY POINTS TO REMEMBER: \n\n1. Source program is converted into executable code through different processes like \n\nprecompilation, compilation, assembling and linking. \n\n2. Local variables uses stack memory. \n\n3. Dynamic memory allocation functions use the heap memory. \n\nC PROGRAMMING \nPage 185 \n\n\n\n\npreprocessor \nSyntax/Description \n\nMacro \n\nSyntax: #define \nThis macro defines constant value and can be any \nof the basic data types. \n\nHeader file \ninclusion \n\nSyntax: #include <file_name> \nThe source code of the file \u201cfile_name\u201d is included \nin the main program at the specified place. \n\nConditional \ncompilation \n\nSyntax: #ifdef, #endif, #if, #else, #ifndef \nSet of commands are included or excluded in \nsource program before compilation with respect to \nthe condition. \n\nOther directives \n\nSyntax: #undef, #pragma \n#undef is used to undefine a defined macro \nvariable. #Pragma is used to call a function before \nand after main function in a C program. \n\n\n\n\n\n\n\n\n\nDIFFERENCE BETWEEN STACK & HEAP MEMORY IN C LANGUAGE? \n\nStack \nHeap \n\nStack is a memory region where \u201clocal \nvariables\u201d, \u201creturn addresses of function \ncalls\u201d and \u201carguments to functions\u201d are \nhold while C program is executed. \n\nHeap is a memory region \nwhich is used by dynamic \nmemory allocation \nfunctions at run time. \n\nC PROGRAMMING \nPage 186 \n\n\nCPU\u201fs current state is saved in stack \nmemory \n\nLinked list is an example \nwhich uses heap memory. \n\n\n\nDIFFERENCE BETWEEN COMPILERS VS INTERPRETERS IN C LANGUAGE? \n\nCompilers \nInterpreters \n\nCompiler reads the entire source \ncode of the program and converts \nit into binary code. This process \nis called compilation. \n\nBinary code is also referred as \nmachine code, executable, and \nobject code. \n\nInterpreter reads the program \nsource code one line at a time and \nexecuting that line. This process is \ncalled interpretation. \n\nProgram speed is fast. \nProgram speed is slow. \n\nOne time execution. \nExample: C, C++ \n\nInterpretation occurs at every line \nof the program. \nExample: BASIC \n\n\n\n\n\n\n\n\n\nThe following section lists down all the important preprocessor directives \u2212 \n\nDirective \nDescription \n\n#define \nSubstitutes a preprocessor macro. \n\n#include \nInserts a particular header from another file. \n\nC PROGRAMMING \nPage 187 \n\n\n#undef \nUndefines a preprocessor macro. \n\n#ifdef \nReturns true if this macro is defined. \n\n#ifndef \nReturns true if this macro is not defined. \n\n#if \nTests if a compile time condition is true. \n\n#else \nThe alternative for #if. \n\n#elif \n#else and #if in one statement. \n\n#endif \nEnds preprocessor conditional. \n\n#error \nPrints error message on stderr. \n\n#pragma \nIssues special commands to the compiler, using a standardized method. \n\n\n\nThere are three types of preprocessor commands. \n\n1 : macro substitution. \n\n2 : file inclusion. \n\n3 : conditional compilation directives. \n\n\n\n1: Macro Substitution : They are two types of macro substitution. \n\n1 : Macro substitution without arguments. \n\n2 : Macro substitution with arguments. \n\n1 : Macro substitution without arguments : It is a process to substitute the constant or value in \nthe place of an identifier. It is possible to achieve this with the help of directive or macro \ndefinition statement #define . \n\nC PROGRAMMING \nPage 188 \n\n\nSyntax : #define identifier constant or expression \n\n\n\nEx : #define PI 3.142 \n\n#define MAX_MARKS 100 \n\n#define  MIN_MARKS 35 \n\nEx : \n\n#include <stdio.h> \n\n#define height 100 \n\n#define number 3.14 \n\n#define letter 'A' \n\n#define letter_sequence \"ABC\" \n\n#define backslash_char '\\?' \n\nvoid main() \n\n{ \n\nprintf(\"value of height    : %d \\n\", height ); \n\nprintf(\"value of number : %f \\n\", number ); \n\nprintf(\"value of letter : %c \\n\", letter ); \n\nprintf(\"value of letter_sequence : %s \\n\", letter_sequence); \n\nprintf(\"value of backslash_char  : %c \\n\", backslash_char); \n\n} \n\nOUTPUT: \n\nvalue of height : 100 \n\nvalue of number : 3.140000 \n\nvalue of letter : A \n\nvalue of letter_sequence : ABC \n\nC PROGRAMMING \nPage 189 \n\n\nvalue of backslash_char : ? \n\n\n\n\n\nEx : Example of Macro substitution \n\n#include<stdio.h> \n\n#define PI 3.142 \n\nvoid main() \n\n{ \n\nint r; \n\nfloat area; \n\nprintf(\u201cEnter the radius of circle\u201d); \n\nscanf(\u201c%d\u201d,&r); \n\narea=PI*r*r; \n\nprintf(\u201cthe area of a circle is%d\u201d,area); \n\n} \n\n\n\nExample of Macro definition with expressions \n\n#define A (20*10) \n\n#define  B (200-100) \n\nvoid main() \n\n{ \n\nint div; \n\ndiv=A/B; \n\nprintf(\u201cthe division of two numbers%d\u201d,div); \n\n} \n\nC PROGRAMMING \nPage 190 \n\n\nExample of Macro definition with conditional expression \n\n#define IFCONDITION if(a>b) \n\n#define  PRINT printf(\u201cthe value of a is the greatest no\u201d) \n\nvoid main() \n\n{ \n\nint a=100,b=50; \n\nIFCONDITION \n\nPRINT; \n\n} \n\nMacro Substitution with Arguments : \n\nSyntax : #define  identifier(var1,var2,va3,\u2026.varn)string \n\nWhere identifier is the name of macro function with the list of macro formal parameters \nvar1,var2,var3,\u2026varn like the formal parameters in a function definition. \n\nEx :           #define  PROD(x)  (x*x) \n\nvoid main() \n\n{ \n\nint a,mul; \n\nprintf(\u201center the value of a\u201d); \n\nscanf(\u201c%d\u201d,&a); \n\nmul=PROD(a); \n\nprintf(\u201cThe multification of two numbers%d\u201d,mul); \n\n} \n\n2 : FILE INCLUSION : A copying of one file to another files into program. \n\nEx : File inclusion of an external file \u201cadd.c\u201d. \n\n\n\nC PROGRAMMING \nPage 191 \n\n\n#include<stdio.h> \n\n#include add.c \n\nvoid main() \n\n{ \n\nvoid add(); //FUNCTION PROTOTYPE/ DECLARATION. \n\nadd(); //FUNCTION CALLING \n\n} \n\nThe file add1.c contains the function definition as follows. \n\nvoid add() \n\n{ \n\nint a,b,c; \n\nprintf(\u201center two numbers\u201d); \n\nscanf(%d%d\u201d,&a,&b); \n\nc=a+b; \n\nprintf(\u201cc value is:%d\u201d,c); \n\n} \n\n3 : CONDITIONAL COMPILATION DIRECTIVES : C preprocessor also supports number \nof conditional compilation directives as \n\n\n\n1 : #undef     : Undefined a macro \n\n2 : #ifdef      : Tests for a macro definition. \n\n3 : #endif     : Specifies the end of #if. \n\n4 : #if           : Tests compile-time condition. \n\n5 : #else       : Specifies alternative when #if test fails. \n\nThese are used to select a particular segment of code for compilation depending on the \ncondition. \n\nC PROGRAMMING \nPage 192 \n\n\nEXAMPLE PROGRAM FOR CONDITIONAL COMPILATION DIRECTIVES: \n\nA) EXAMPLE PROGRAM FOR #IFDEF, #ELSE AND #ENDIF IN C: \n\n\uf0b7 \n\u201c#ifdef\u201d directive checks whether particular macro is defined or not. If it is defined, \u201cIf\u201d \nclause statements are included in source file. \n\n\uf0b7 \nOtherwise, \u201celse\u201d clause statements are included in source file for compilation and \nexecution. \n\nEx: \n\n#include <stdio.h> \n\n#define RAJU 100 \n\nint main() \n\n{ \n\n#ifdef RAJU \n\nprintf(\"RAJU is defined. So, this line will be added in \" \\ \n\n\"this C file\\n\"); \n\n#else \n\nprintf(\"RAJU is not defined\\n\"); \n\n#endif \n\nreturn 0; \n\n} \n\nOUTPUT: \n\nRAJU is defined. So, this line will be added in this C file \n\n\n\nB) EXAMPLE PROGRAM FOR #IFNDEF AND #ENDIF IN C: \n\n\uf0b7 \n#ifndef exactly acts as reverse as #ifdef directive. If particular macro is not defined, \u201cIf\u201d \nclause statements are included in source file. \n\n\uf0b7 \nOtherwise, else clause statements are included in source file for compilation and \nexecution. \n\nC PROGRAMMING \nPage 193 \n\n\nEx: \n#include <stdio.h> \n#define RAJU 100 \nint main() \n{ \n#ifndef SELVA \n{ \nprintf(\"SELVA is not defined. So, now we are going to \" \\ \n\"define here\\n\"); \n#define SELVA 300 \n} \n#else \nprintf(\"SELVA is already defined in the program\u201d); \n\n#endif \nreturn 0; \n\n} \nOUTPUT: \n\nSELVA is not defined. So, now we are going to define here \n\nC) EXAMPLE PROGRAM FOR #IF, #ELSE AND #ENDIF IN C: \n\n\uf0b7 \n\u201cIf\u201d clause statement is included in source file if given condition is true. \n\n\uf0b7 \nOtherwise, else clause statement is included in source file for compilation and execution. \n\nEx: \n\n#include <stdio.h> \n#define a 100 \nint main() \n{ \n#if (a==100) \nprintf(\"This line will be added in this C file since \" \\ \n\"a \\= 100\\n\"); \n#else \nprintf(\"This line will be added in this C file since \" \\ \n\"a is not equal to 100\\n\"); \n#endif \nreturn 0; \n} \n\n\nOUTPUT: \n\nThis line will be added in this C file since a = 100 \n\nC PROGRAMMING \nPage 194 \n\n\nEXAMPLE PROGRAM FOR UNDEF IN C LANGUAGE: \nThis directive undefines existing macro in the program. \n\nEx: \n\n#include <stdio.h> \n\n#define height 100 \n\nvoid main() \n\n{ \n\nprintf(\"First defined value for height    : %d\\n\",height); \n\n#undef height          // undefining variable \n\n#define height 600     // redefining the same for new value \n\nprintf(\"value of height after undef \\& redefine:%d\",height); \n\n} \n\nOUTPUT: \n\nFirst defined value for height : 100 \n\nvalue of height after undef & redefine : 600 \n\n\n\nEXAMPLE PROGRAM FOR PRAGMA IN C LANGUAGE: \n\nPragma is used to call a function before and after main function in a C program. \n\nEx: \n\n#include <stdio.h> \n\nvoid function1( ); \n\nvoid function2( ); \n\n#pragma startup function1 \n\n#pragma exit function2 \n\n\n\nC PROGRAMMING \nPage 195 \n\n\nint main( ) \n\n{ \n\nprintf ( \"\\n Now we are in main function\" ) ; \n\nreturn 0; \n\n} \n\nvoid function1( ) \n\n{ \n\nprintf(\"\\nFunction1 is called before main function call\"); \n\n} \n\nvoid function2( ) \n\n{ \n\nprintf ( \"\\nFunction2 is called just before end of \" \\ \n\n\"main function\" ) ;\" \n\n} \n\nOUTPUT: \n\nFunction1 is called before main function call \n\nNow we are in main function \n\nFunction2 is called just before end of main function \n\n\n\nEx :          #define TEST 1 \n\nvoid main() \n\n{ \n\n#ifdef  TEST \n\n{ \n\nprintf(\u201cThis is compiled\u201d); \n\nC PROGRAMMING \nPage 196 \n\n\n} \n\n#else \n\n{ \n\nprintf(\u201cThis is not compiled\u201d); \n\n} \n\n#endif \n\n} \n\nEx2 : :     #define FLAG 1 \n\nchar ch; \n\nvoid main() \n\n{ \n\n#if  FLAG \n\n{ \n\nch=\u201ft\u201f; \n\nprintf(\u201cThis is compiled\u201d); \n\n} \n\n#else \n\n{ \n\nch=\u201ff\u201f; \n\nprintf(\u201cThis is not compiled\u201d); \n\n} \n\n#endif \n\n} \n\n\n\n\n\n\n![Image](/src/assets/generated_images/cp_p196_i0.png)\nC PROGRAMMING \nPage 197 \n\n\nPOINTERS: \n\nIntroduction \n\nDefinition: \n\nPointer is a variable that stores/hold address of another variable of same data type/ t is \nalso known as locator or indicator that points to an address of a value. A pointer is a \nderived data type in C \n\n\n\nBenefit of using pointers \n\n\uf0b7 \nPointers are more efficient in handling Array and Structure. \n\n\uf0b7 \nPointer allows references to function and thereby helps in passing of function as \narguments to other function. \n\n\uf0b7 \nIt reduces length and the program execution time. \n\n\uf0b7 \nIt allows C to support dynamic memory management. \n\nDeclaration of Pointer \n\ndata_type* pointer_variable_name; \n\nint* p; \n\nNote: void type pointer works with all data types, but isn't used often. \n\nInitialization of Pointer variable \n\nPointer Initialization is the process of assigning address of a variable to pointer variable. \nPointer variable contains address of variable of same data type \n\nint a = 10 ; \n\nint *ptr ; //pointer declaration \n\nptr = &a ; //pointer initialization \n\nor, \n\n\n![Image](/src/assets/generated_images/cp_p197_i0.png)\nC PROGRAMMING \nPage 198 \n\n\nint *ptr = &a ; //initialization and declaration together \n\nNote :Pointer variable always points to same type of data. \n\nfloat a; \n\nint *ptr; \n\nptr = &a;    //ERROR, type mismatch \n\nAbove statement defines, p as pointer variable of type int. Pointer example \n\n\n\nAs you can see in the above figure, pointer variable stores the address of number variable i.e. \nfff4. The value of number variable is 50. But the address of pointer variable p is aaa3. \n\nBy the help of * ( indirection operator ), we can print the value of pointer variable p. \n\n\n\nReference operator (&) and Dereference operator (*) \n\n& is called reference operator. It gives you the address of a variable. There is another operator \nthat gets you the value from the address, it is called a dereference operator (*). \n\nSymbols used in pointer \n\nSymbol \nName \nDescription \n\n& (ampersand sign) \naddress of operator \ndetermines the address of a variable. \n\n* (asterisk sign) \nindirection operator \naccesses the value at the address. \n\n\n\nC PROGRAMMING \nPage 199 \n\n\nDereferencing of Pointer \n\nOnce a pointer has been assigned the address of a variable. To access the value of variable, \npointer is dereferenced, using the indirection operator *. \n\nint a,*p; \n\na = 10; \n\np = &a; \n\nprintf(\"%d\",*p); //this will print the value of a. \n\nprintf(\"%d\",*&a); //this will also print the value of a. \n\nprintf(\"%u\",&a); //this will print the address of a. \n\nprintf(\"%u\",p); //this will also print the address of a. \n\nprintf(\"%u\",&p); //this will also print the address of p. \n\nKEY POINTS TO REMEMBER ABOUT POINTERS IN C: \n\n\uf0b7 \nNormal variable stores the value whereas pointer variable stores the address of the \nvariable. \n\n\uf0b7 \nThe content of the C pointer always be a whole number i.e. address. \n\n\uf0b7 \nAlways C pointer is initialized to null, i.e. int *p = null. \n\n\uf0b7 \nThe value of null pointer is 0. \n\n\uf0b7 \n& symbol is used to get the address of the variable. \n\n\uf0b7 \n* symbol is used to get the value of the variable that the pointer is pointing to. \n\n\uf0b7 \nIf a pointer in C is assigned to NULL, it means it is pointing to nothing. \n\n\uf0b7 \nTwo pointers can be subtracted to know how many elements are available between these \ntwo pointers. \n\n\uf0b7 \nBut, Pointer addition, multiplication, division are not allowed. \n\n\uf0b7 \nThe size of any pointer is 2 byte (for 16 bit compiler). \n\n\n\n\n\nC PROGRAMMING \nPage 200 \n\n\nExample: \n\n#include <stdio.h> \n\n#include <conio.h> \n\nvoid main(){ \n\nint number=50; \n\nint *p; \n\nclrscr(); \n\np=&number;//stores the address of number variable \n\nprintf(\"Address of number variable is %x \\n\",&number); \n\nprintf(\"Address of p variable is %x \\n\",p); \n\nprintf(\"Value of p variable is %d \\n\",*p); \n\ngetch(); \n\n} \n\nOutput \n\nAddress of number variable is fff4 \n\nAddress of p variable is fff4 \n\nValue of p variable is 50 \n\n\n\n\n\nExample: \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint *ptr, q; \n\nq = 50; \n\nC PROGRAMMING \nPage 201 \n\n\n/* address of q is assigned to ptr */ \n\nptr = &q; \n\n/* display q's value using ptr variable */ \n\nprintf(\"%d\", *ptr); \n\nreturn 0; \n\n} \n\nOutput \n\n50 \n\n\n\nExample: \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint var =10; \n\nint *p; \n\np= &var; \n\nprintf ( \"\\n Address of var is: %u\", &var); \n\nprintf ( \"\\n Address of var is: %u\", p); \n\nprintf ( \"\\n Address of pointer p is: %u\", &p); \n\n/* Note I have used %u for p's value as it should be an address*/ \n\nprintf( \"\\n Value of pointer p is: %u\", p); \n\nprintf ( \"\\n Value of var is: %d\", var); \n\nprintf ( \"\\n Value of var is: %d\", *p); \n\nprintf ( \"\\n Value of var is: %d\", *( &var)); \n\n} \n\nC PROGRAMMING \nPage 202 \n\n\nOutput: \n\nAddress of var is: 00XBBA77 \n\nAddress of var is: 00XBBA77 \n\nAddress of pointer p is: 77221111 \n\nValue of pointer p is: 00XBBA77 \n\nValue of var is: 10 \n\nValue of var is: 10 \n\nValue of var is: 10 \n\nNULL Pointer \n\nA pointer that is not assigned any value but NULL is known as NULL pointer. If you don't have \nany address to be specified in the pointer at the time of declaration, you can assign NULL value. \n\nOr \n\nIt is always a good practice to assign a NULL value to a pointer variable in case you do not have \nan exact address to be assigned. This is done at the time of variable declaration. A pointer that is \nassigned NULL is called a null pointer.int *p=NULL; \n\nNote: The NULL pointer is a constant with a value of zero defined in several standard libraries/ \nin most the libraries, the value of pointer is 0 (zero) \n\nExample: \n\nThe value of ptr is 0 \n\nPointers for Inter \u2010 Function Communication \n\n\n\nPointers to Pointers \n\nPointers can point to other pointers /pointer refers to the address of another pointer. \n\npointer can point to the address of another pointer which points to the address of a value. \n\n\n![Image](/src/assets/generated_images/cp_p202_i0.png)\n\n![Image](/src/assets/generated_images/cp_p202_i1.png)\nC PROGRAMMING \nPage 203 \n\n\n\n\nsyntax of pointer to pointer \n\nint **p2; \n\npointer to pointer example \n\nLet's see an example where one pointer points to the address of another pointer. \n\n\n\nExample: \n\n#include <stdio.h> \n\n#include <conio.h> \n\nvoid main(){ \n\nint number=50; \n\nint *p;//pointer to int \n\nint **p2;//pointer to pointer \n\nclrscr(); \n\np=&number;//stores the address of number variable \n\np2=&p; \n\nprintf(\"Address of number variable is %x \\n\",&number); \n\nprintf(\"Address of p variable is %x \\n\",p); \n\n\n![Image](/src/assets/generated_images/cp_p203_i0.png)\nC PROGRAMMING \nPage 204 \n\n\nprintf(\"Value of *p variable is %d \\n\",*p); \n\nprintf(\"Address of p2 variable is %x \\n\",p2); \n\nprintf(\"Value of **p2 variable is %d \\n\",**p); \n\ngetch(); \n\n} \n\nOutput \n\nAddress of number variable is fff4 \n\nAddress of p variable is fff4 \n\nValue of *p variable is 50 \n\nAddress of p2 variable is fff2 \n\nValue of **p variable is 50 \n\n\n\nArrays and Pointers \n\nWhen an array is declared, compiler allocates sufficient amount of memory to contain all the \nelements of the array. Base address which gives location of the first element is also allocated by \nthe compiler. \n\nSuppose we declare an array arr, \n\nint arr[5]={ 1, 2, 3, 4, 5 }; \n\nAssuming that the base address of arr is 1000 and each integer requires two byte, the five \nelement will be stored as follows \n\n\n\nC PROGRAMMING \nPage 205 \n\n\nHere variable arr will give the base address, which is a constant pointer pointing to the \nelement, arr[0] . Therefore arr is containing the address of arr[0] i.e 1000. \n\narr is equal to &arr[0] // by default \n\nWe can declare a pointer of type int to point to the array arr. \n\nint arr[5]={ 1, 2, 3, 4, 5 }; \n\nint *p; \n\np = arr; \n\nor p = &arr[0];  //both the statements are equivalent. \n\nNow we can access every element of array arr using p++ to move from one element to another. \n\nNOTE : You cannot decrement a pointer once incremented. p-- won't work. \n\nPointer to Array \n\nwe can use a pointer to point to an Array, and then we can use that pointer to access the array. \nLets have an example, \n\nint i; \n\nint a[5] = {1, 2, 3, 4, 5}; \n\nint *p = a; // same as int*p = &a[0] \n\nfor (i=0; i<5; i++) \n\n{ \n\nprintf(\"%d\", *p); \n\np++; \n\n} \n\n\n\n\n\n\n\n\n\n\n![Image](/src/assets/generated_images/cp_p205_i0.png)\n\n![Image](/src/assets/generated_images/cp_p205_i1.png)\nC PROGRAMMING \nPage 206 \n\n\nIn the above program, the pointer *p will print all the values stored in the array one by one. We \ncan also use the Base address ( a in above case) to act as pointer and print all the values. \n\n\n\nRelation between Arrays and Pointers \n\nConsider an array: \n\nint arr[4]; \n\n\n\nIn C programming, name of the array always points to address of the first element of an array. \n\nIn the above example , arr and &arr[0] points to the address of the first element. \n\n&arr[0] is equivalent to arr \n\nSince, the addresses of both are the same, the values of arr and &arr[0] are also the same. \n\narr[0] is equivalent to *arr (value of an address of the pointer) \n\nC PROGRAMMING \nPage 207 \n\n\nSimilarly, \n\n&arr[1] is equivalent to (arr + 1) AND, arr[1] is equivalent to *(arr + 1). \n\n&arr[2] is equivalent to (arr + 2) AND, arr[2] is equivalent to *(arr + 2). \n\n&arr[3] is equivalent to (arr + 3) AND, arr[3] is equivalent to *(arr + 3). \n\n. \n\n. \n\n&arr[i] is equivalent to (arr + i) AND, arr[i] is equivalent to *(arr + i). \n\n\n\nExample: Program to find the sum of six numbers with arrays and pointers \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint i, classes[6],sum = 0; \n\nprintf(\"Enter 6 numbers:\\n\"); \n\nfor(i = 0; i < 6; ++i) \n\n{ \n\n// (classes + i) is equivalent to &classes[i] \n\nscanf(\"%d\",(classes + i)); \n\n// *(classes + i) is equivalent to classes[i] \n\nsum += *(classes + i); \n\n} \n\nprintf(\"Sum = %d\", sum); \n\nreturn 0; \n\n} \n\nOutput \n\nC PROGRAMMING \nPage 208 \n\n\nEnter 6 numbers: \n\n2 \n\n3 \n\n4 \n\n5 \n\n3 \n\n4 \n\nSum = 21 \n\nPointer Arithmetic and Arrays \n\npointer holds address of a value, so there can be arithmetic operations on the pointer variable. \n\nThere are four arithmetic operators that can be used on pointers: \n\no Increment( ++) \n\no Decrement( --) \n\no Addition( +) \n\no Subtraction( -) \n\nIncrement pointer: \n\n1. Incrementing Pointer is generally used in array because we have contiguous memory in \n\narray and we know the contents of next memory location. \n\n2. Incrementing Pointer Variable Depends Upon data type of the Pointer variable. \n\nThe formula of incrementing pointer is given below: \n\nnew_address= current_address + i * size_of(data type) \n\nThree rules should be used to increment pointer \n\nAddress + 1 = Address \n\nAddress++   = Address \n\n\n![Image](/src/assets/generated_images/cp_p208_i0.png)\nC PROGRAMMING \nPage 209 \n\n\n++Address   = Address \n\nPictorial Representation : \n\n\n\nData \nType \n\nOlder Address stored \nin pointer \n\nNext Address stored in pointer after \nincrementing (ptr++) \n\nint \n1000 \n1002 \n\nfloat \n1000 \n1004 \n\nchar \n1000 \n1001 \n\n\n\nNote : \n\n32 bit \n\nFor 32 bit int variable, it will increment to 2 byte. \n\n64 bit \n\nFor 64 bit int variable, it will increment to 4 byte. \n\nExample: \n\n#include <stdio.h> \n\nvoid main(){ \n\nint number=50; \n\nC PROGRAMMING \nPage 210 \n\n\nint *p;//pointer to int \n\np=&number;//stores the address of number variable \n\nprintf(\"Address of p variable is %u \\n\",p); \n\np=p+1; \n\nprintf(\"After increment: Address of p variable is %u \\n\",p); \n\n} \n\nOutput \n\nAddress of p variable is 3214864300 \n\nAfter increment: Address of p variable is 3214864304 \n\nDecrement(--) \n\nLike increment, we can decrement a pointer variable. \n\nformula of decrementing pointer \n\nnew_address= current_address - i * size_of(data type) \n\nExample: \n\n#include <stdio.h> \n\nvoid main(){ \n\nint number=50; \n\nint *p;//pointer to int \n\np=&number;//stores the address of number variable \n\nprintf(\"Address of p variable is %u \\n\",p); \n\np=p-1; \n\nC PROGRAMMING \nPage 211 \n\n\nprintf(\"After decrement: Address of p variable is %u \\n\",p); \n\n} \n\nOutput \n\nAddress of p variable is 3214864300 \n\nAfter decrement: Address of p variable is 3214864296 \n\nAddition(+) \n\nWe can add a value to the pointer variable. \n\nformula of adding value to pointer \n\nnew_address= current_address + (number * size_of(data type)) \n\nNote: \n\n32 bit \n\nFor 32 bit int variable, it will add 2 * number. \n\n64 bit \n\nFor 64 bit int variable, it will add 4 * number. \n\nExample: \n\n#include <stdio.h> \n\nvoid main(){ \n\nint number=50; \n\nint *p;//pointer to int \n\np=&number;//stores the address of number variable \n\nprintf(\"Address of p variable is %u \\n\",p); \n\nC PROGRAMMING \nPage 212 \n\n\np=p+3;   //adding 3 to pointer variable \n\nprintf(\"After adding 3: Address of p variable is %u \\n\",p); \n\n} \n\nOutput \n\nAddress of p variable is 3214864300 \n\nAfter adding 3: Address of p variable is 3214864312 \n\nSubtraction (-) \n\nLike pointer addition, we can subtract a value from the pointer variable. The formula \nof subtracting value from pointer variable. \n\nnew_address= current_address - (number * size_of(data type)) \n\nExample: \n\n#include <stdio.h> \n\nvoid main(){ \n\nint number=50; \n\nint *p;//pointer to int \n\np=&number;//stores the address of number variable \n\nprintf(\"Address of p variable is %u \\n\",p); \n\np=p-3; //subtracting 3 from pointer variable \n\nprintf(\"After subtracting 3: Address of p variable is %u \\n\",p); \n\n} \n\nOutput \n\nC PROGRAMMING \nPage 213 \n\n\nAddress of p variable is 3214864300 \n\nAfter subtracting 3: Address of p variable is 3214864288 \n\nPassing an Array to a Function \n\nIf you want to pass a single-dimension array as an argument in a function, you would have to \ndeclare a formal parameter in one of following three ways and all three declaration methods \nproduce similar results because each tells the compiler that an integer pointer is going to be \nreceived. Similarly, you can pass multi-dimensional arrays as formal parameters. \n\n1) Formal parameters as a pointer \u2013 \nvoid myFunction(int *param) { \n. \n. \n. \n} \n\n2) Formal parameters as a sized array \u2013 \n\nvoid myFunction(int param[10]) { \n. \n. \n. \n} \n\n3) Formal parameters as an unsized array \u2212 \nvoid myFunction(int param[10]) { \n. \n. \n. \n\n} \nExample1: pass an entire array to a function argument \n#include <stdio.h> \n/* function declaration */ \ndouble getAverage(int arr[], int size); \nint main () { \n/* an int array with 5 elements */ \nint balance[5] = {1000, 2, 3, 17, 50}; \n\nC PROGRAMMING \nPage 214 \n\n\ndouble avg; \n\n/* pass pointer to the array as an argument */ \navg = getAverage( balance, 5 ) ; \n/* output the returned value */ \nprintf( \"Average value is: %f \", avg ); \nreturn 0; \n} \ndouble getAverage(int arr[], int size) { \n\nint i; \ndouble avg; \ndouble sum = 0; \n\nfor (i = 0; i < size; ++i) { \nsum += arr[i]; \n} \n\navg = sum / size; \n\nreturn avg; \n} \n\nOutput \nAverage value is: 214.400000 \n\nExample2: pass an entire array to a function argument \n#include <stdio.h> \nmyfuncn( int *var1, int var2) \n{ \nfor(int x=0; x<var2; x++) \n{ \nprintf(\"Value of var_arr[%d] is: %d \\n\", x, *var1); \n/*increment pointer for next element fetch*/ \nvar1++; \n} \n} \n\nC PROGRAMMING \nPage 215 \n\n\n\nint main() \n{ \nint var_arr[] = {11, 22, 33, 44, 55, 66, 77}; \nmyfuncn(&var_arr, 7); \nreturn 0; \n} \nOutput \nValue of var_arr[0] is: 11 \nValue of var_arr[1] is: 22 \nValue of var_arr[2] is: 33 \nValue of var_arr[3] is: 44 \nValue of var_arr[4] is: 55 \nValue of var_arr[5] is: 66 \nValue of var_arr[6] is: 77 \n\nExample: Call by value method \u2013 \n#include <stdio.h> \ndisp( char ch) \n{ \nprintf(\"%c \", ch); \n} \nint main() \n{ \nchar arr[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'I', 'j'}; \nfor (int x=0; x<=10; x++) \n{ \n/* I\u201fm passing each element one by one using subscript*/ \ndisp (arr[x]); \n} \n\nreturn 0; \n} \nOutput: \na b c d e f g h i j \n\nC PROGRAMMING \nPage 216 \n\n\nIn this method of calling a function, the actual arguments gets copied into formal \narguments. In this example actual argument(or parameter) is arr[x] and formal parameter \nis ch. \n\nExample: Call by reference method: Using pointers \n\n#include <stdio.h> \n\ndisp( int *num) \n\n{ \n\nprintf(\"%d \", *num); \n\n} \n\nint main() \n\n{ \n\nint arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; \n\nfor (int i=0; i<=10; i++) \n\n{ \n\n/* I\u201fm passing element\u201fs address*/ \n\ndisp (&arr[i]); \n\n} \n\nreturn 0; \n\n} \n\nOutput: \n\n1 2 3 4 5 6 7 8 9 0 \n\n\n\nC PROGRAMMING \nPage 217 \n\n\nArray of Pointers \n\nAn array of pointers would be an array that holds memory locations. An array of pointers is an \nindexed set of variables in which the variables are pointers (a reference to a location in memory ). \n\nSyntax: \n\ndata_type_name * variable name \n\nExample \n\nint *ptr[MAX]; \n\nArray alpha[] \nPointer a \n\nalpha[0] \n*a \n\nalpha[1] \n*(a+1) \n\nalpha[2] \n*(a+2) \n\nalpha[3] \n*(a+3) \n\nalpha[ n ] \n*(a+ n ) \n\n\n\nExample1: \n\n#include <stdio.h> \n\nconst int MAX = 3; \n\nint main () { \n\nint  var[] = {10, 100, 200}; \n\nint i, *ptr[MAX]; \n\nfor ( i = 0; i < MAX; i++) { \n\nC PROGRAMMING \nPage 218 \n\n\nptr[i] = &var[i]; /* assign the address of integer. */ \n\n} \n\nfor ( i = 0; i < MAX; i++) { \n\nprintf(\"Value of var[%d] = %d\\n\", i, *ptr[i] ); \n\n} \n\nreturn 0; \n\n} \n\nOutput \n\nValue of var[0] = 10 \n\nValue of var[1] = 100 \n\nValue of var[2] = 200 \n\nExample2: \n\n#include <stdio.h> \n#include <conio.h> \nmain() { \nclrscr(); \nint *array[3]; \nint x = 10, y = 20, z = 30; \nint i; \narray[0] = &x; \narray[1] = &y; \narray[2] = &z; \nfor (i=0; i< 3; i++) { \nprintf(\"The value of %d= %d ,address is %u\\t \\n\", i, *(array[i]), \narray[i]); \n} \ngetch(); \n\n\n![Image](/src/assets/generated_images/cp_p218_i0.png)\nC PROGRAMMING \nPage 219 \n\n\nreturn 0; \n} \n\nOutput \n\n\n\nExample3: \n\n#include <stdio.h> \n\nconst int MAX = 4; \n\nint main () { \n\nchar *names[] = { \n\n\"Zara Ali\", \n\n\"Hina Ali\", \n\n\"Nuha Ali\", \n\n\"Sara Ali\" \n\n}; \n\nint i = 0; \n\nfor ( i = 0; i < MAX; i++) { \n\nprintf(\"Value of names[%d] = %s\\n\", i, names[i] ); \n\n} \n\nreturn 0; \n\n} \n\nC PROGRAMMING \nPage 220 \n\n\nOutput: \n\nValue of names[0] = Zara Ali \n\nValue of names[1] = Hina Ali \n\nValue of names[2] = Nuha Ali \n\nValue of names[3] = Sara Ali \n\nExample4: \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nchar *fruit[] = { \n\n\"watermelon\", \n\n\"banana\", \n\n\"pear\", \n\n\"apple\", \n\n\"coconut\", \n\n\"grape\", \n\n\"blueberry\" \n\n}; \n\nint x; \n\nfor(x=0;x<7;x++) \n\nputs(fruit[x]); \n\nC PROGRAMMING \nPage 221 \n\n\nreturn(0); \n\n} \n\nPointers to Void  and to Functions \n\nPointers to Void \n\nNote: \n\n1. Suppose we have to declare integer pointer, character pointer and float pointer then we \n\nneed to declare 3 pointer variables. \n\n2. Instead of declaring different types of pointer variable it is feasible to declare single \n\npointer variable which can act as integer pointer,character pointer. \n\nA pointer variable declared using a particular data type can not  hold the location address of \nvariables of other data types. It is invalid and will result in a compilation error. \n\nEx:- char  *ptr; \n\nint  var1; \n\nptr=&var1; // This is invalid because \u201eptr\u201f is a character pointer variable. \n\nHere comes the importance of a \u201cvoid pointer\u201d. A void pointer is nothing but a pointer \nvariable declared using the reserved word in C \u201evoid\u201f. \n\nVoid Pointer Basics : \n\n3. In C General Purpose Pointer is called as void Pointer. \n\n4. It does not have any data type associated with it \n\n5. It can store address of any type of variable \n\n6. A void pointer is a C convention for a raw address. \n\n7. The compiler has no idea what type of object a void Pointer really points to ? \n\n\n\n\n\nC PROGRAMMING \nPage 222 \n\n\n\n\nVoid pointer: A void pointer is a pointer that has no associated data type with it. A void pointer \ncan hold address of any type and can be typcasted to any type. Special type of pointer called \nvoid pointer or general purpose pointer . \n\nDeclaration of void pointer \n\nvoid * pointer_name; \n\nVoid pointer example \n\nvoid *ptr;    // ptr is declared as Void pointer \n\nchar cnum; \n\nint inum; \n\nfloat fnum; \n\nptr = &cnum;  // ptr has address of character data \n\nptr = &inum;  // ptr has address of integer data \n\nptr = &fnum;  // ptr has address of float data \n\n\n\nAdvantages of void pointers: \n\n1) malloc() and calloc() return void * type and this allows these functions to be used to allocate \nmemory of any data type (just because of void *) \n\nint main(void) \n\n{ \n\n// Note that malloc() returns void * which can be \n\n// typecasted to any type like int *, char *, .. \n\nC PROGRAMMING \nPage 223 \n\n\nint *x = malloc(sizeof(int) * n); \n\n} \n\n2) void pointers in C are used to implement generic functions in C. \n\nNote: \n\n1) void pointers cannot be dereferenced. For example the following program doesn\u201ft compile. \n\n#include<stdio.h> \n\nint main() \n\n{ \n\nint a = 10; \n\nvoid *ptr = &a; \n\nprintf(\"%d\", *ptr); \n\nreturn 0; \n\n} \nOutput: \n\nCompiler Error: 'void*' is not a pointer-to-object type \n\nThe following program compiles and runs fine. \n\n#include<stdio.h> \n\nint main() \n\n{ \n\nint a = 10; \n\nvoid *ptr = &a; \n\nprintf(\"%d\", *(int *)ptr); \n\nreturn 0; \n\n} \n\nC PROGRAMMING \nPage 224 \n\n\nOutput: \n\n10 \n\nSummary : Void Pointer \n\nScenario \nBehavior \n\nWhen We assign address of integer variable to \nvoid pointer \n\nVoid Pointer Becomes Integer \nPointer \n\nWhen We assign address of character variable to \nvoid pointer \n\nVoid Pointer Becomes Character \nPointer \n\nWhen We assign address of floating variable to \nvoid pointer \n\nVoid Pointer Becomes Floating \nPointer \n\n\n\n\n\nPointers to functions/ Function Pointers \n\n\uf0d8 A pointer to a function points to the address of the executable code of the function. \n\n\uf0d8 We can use pointers to call functions and to pass functions as arguments to other \n\nfunctions. \n\n\uf0d8 We cannot perform pointer arithmetic on pointers to functions. \n\n\uf0d8 The type of a pointer to a function is based on both the return type and parameter types of \n\nthe function. \n\n\uf0d8 A declaration of a pointer to a function must have the pointer name in parentheses. \n\n\uf0d8 The function call operator () has a higher precedence than the dereference operator *. \n\nWithout them, the compiler interprets the statement as a function that returns a pointer to \na specified return type. \n\n\n\ndeclare Pointer to function? \n\n<function return type>(*<Pointer_name>)(function argument list) \n\nFor example \u2013 \n\nFor example: \n\n\n\n1) int *f(int a); /*  function f returning an int   *  */ \n\nC PROGRAMMING \nPage 225 \n\n\n\n\nIn this declaration, f is interpreted as a function that takes an int as argument, and returns a \npointer to an int. \n\n\n\n2) double  (*p2f)(double, char) \n\nHere double is a return type of function, p2f is pointer name & (double, char) is an argument list \nfor the function. Which means the first argument for this function should be double and the \nsecond one would be of char type. \n\n\n\nExample: \n\n#include<stdio.h> \n\nint sum (int num1, int num2) \n\n{ \n\nreturn sum1+sum2; \n\n} \n\nint main() \n\n{ \n\nint (*f2p) (int, int); \n\nf2p = sum; \n\nint op1 = f2p (10, 13); \n\nint op2 = sum (10, 13); \n\nprintf(\"Output 1 \u2013 for function call via Pointer: %d\",op1); \n\nprintf(\"Output2 \u2013 for direct function call: %d\", op2); \n\nreturn 0; \n\n} \n\nOutput: \n\nOutput 1 \u2013 for function call via Pointer: 23 \n\nOutput2 \u2013 for direct function call: 23 \n\nYou would have noticed that the output of both the statements is same \n\u2013 \nf2p(10, 13) == sum(10, 13) \n\nwhich means in generic sense you can write it out as: \n\npointer_name(argument list) == function(same argument list) \n\nC PROGRAMMING \nPage 226 \n\n\nwherein pointer_name is declared as: \n\nreturn_type(*pointer_name)(argument list); \n\npointer_name = function_name(argument list); \n\n\n\nMemory Allocation Functions \n\nThe concept of dynamic memory allocation in c language enables the C programmer to \nallocate memory at runtime . \n\nOr \n\nThe process of allocating memory at runtime is known as dynamic memory allocation . Library \nroutines known as \"memory management functions\" are used for allocating and freeing memory \nduring execution of a program. These functions are defined in stdlib.h . \n\nDynamic memory allocation in c language is possible by 4 functions of stdlib.h header file. \n\n1. malloc() \n\n2. calloc() \n\n3. realloc() \n\n4. free() \n\n\n\n\n\nDifference between static memory allocation and dynamic memory allocation. \n\nstatic memory allocation \ndynamic memory allocation \n\nmemory is allocated at compile time. \nmemory is allocated at run time. \n\nmemory \ncan't \nbe \nincreased \nwhile \nexecuting program. \n\nmemory \ncan \nbe \nincreased \nwhile \nexecuting program. \n\nused in array. \nused in linked list. \n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 227 \n\n\nMethods used for dynamic memory allocation. \n\nmalloc() \nallocates single block of requested memory. \n\ncalloc() \nallocates multiple block of requested memory. \n\nrealloc() \nreallocates the memory occupied by malloc() or calloc() functions. \n\nfree() \nfrees the dynamically allocated memory. \n\n\n\n\n\nNote: Dynamic memory allocation related function can be applied for any data type that's why \ndynamic memory allocation related functions return void*. \n\nMemory Allocation Process \n\nGlobal variables, static variables \nand \nprogram \ninstructions \nget \ntheir \nmemory \nin permanent storage area whereas local variables are stored in area called Stack . The memory \nspace between these two region is known as Heap area. This region is used for dynamic memory \nallocation during execution of the program. The size of heap keep changing. \n\n\n\n\n\nmalloc() \n\nmalloc stands for \"memory allocation\". \n\nThe malloc() function allocates single block of requested memory  at runtime. This function \nreserves a block of memory of given size and returns a pointer of type void. This means that we \ncan assign it to any type of pointer using typecasting. It doesn't initialize memory at execution \ntime, so it has garbage value initially. If it fails to locate enough space (memory) it returns a \nNULL pointer. \n\nsyntax \n\nptr=(cast-type*)malloc(byte-size) \n\n\n\nExample \n\nint *x; \n\nx = (int*)malloc(100 * sizeof(int)); //memory space allocated to variable x \n\nfree(x);                    //releases the memory allocated to variable x \n\n\n\nC PROGRAMMING \nPage 228 \n\n\nThis statement will allocate either 200 or 400 according to size of int 2 or 4 bytes respectively \nand the pointer points to the address of first byte of memory. \n\nExample \n\n#include <stdio.h> \n\n#include <stdlib.h> \n\nint main() \n\n{ \n\nint num, i, *ptr, sum = 0; \n\nprintf(\"Enter number of elements: \"); \n\nscanf(\"%d\", &num); \n\nptr = (int*) malloc(num * sizeof(int));  //memory allocated using malloc \n\nif(ptr == NULL) \n\n{ \n\nprintf(\"Error! memory not allocated.\"); \n\nexit(0); \n\n} \n\nprintf(\"Enter elements of array: \"); \n\nfor(i = 0; i < num; ++i) \n\n{ \n\nscanf(\"%d\", ptr + i); \n\nsum += *(ptr + i); \n\n} \n\nprintf(\"Sum = %d\", sum); \n\nfree(ptr); \n\nreturn 0; \n\n} \n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 229 \n\n\ncalloc() \n\ncalloc stands for \"contiguous allocation\". \n\nCalloc() is another memory allocation function that is used for allocating memory at \nruntime. calloc function is normally used for allocating memory to derived data types such \nas arrays and structures . The calloc() function allocates multiple block of requested memory. \n\nIt initially initialize (sets) all bytes to zero.If it fails to locate enough space( memory)  it returns a \nNULL pointer. The only difference between malloc() and calloc() is that, malloc() allocates \nsingle block of memory whereas calloc() allocates multiple blocks of memory each of same size. \n\nSyntax \n\nptr = (cast-type*)calloc(n/number, element-size); \n\ncalloc() required 2 arguments of type count, size-type. \n\nCount will provide number of elements; size-type is data type size \n\nExample \n\nint *arr; \n\narr=( int *)calloc(10, sizeof ( int )); \n// 20 byte \n\ncahr*str; \n\nstr=( char *)calloc(50, siceof( char )); // 50 byte \n\n\n\nExample \n\nstruct employee \n\n{ \n\nchar *name; \n\nint salary; \n\n}; \n\ntypedef struct employee emp; \n\nemp *e1; \n\ne1 = (emp*)calloc(30,sizeof(emp)); \n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 230 \n\n\nExample \n\n#include <stdio.h> \n\n#include <stdlib.h> \n\nint main() \n\n{ \n\nint num, i, *ptr, sum = 0; \n\nprintf(\"Enter number of elements: \"); \n\nscanf(\"%d\", &num); \n\nptr = (int*) calloc(num, sizeof(int)); \n\nif(ptr == NULL) \n\n{ \n\nprintf(\"Error! memory not allocated.\"); \n\nexit(0); \n\n} \n\nprintf(\"Enter elements of array: \"); \n\nfor(i = 0; i < num; ++i) \n\n{ \n\nscanf(\"%d\", ptr + i); \n\nsum += *(ptr + i); \n\n} \n\nprintf(\"Sum = %d\", sum); \n\nfree(ptr); \n\nreturn 0; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 231 \n\n\nDiffrence between malloc() and calloc() \n\ncalloc() \nmalloc() \n\ncalloc() initializes the allocated memory with \n0 value. \n\nmalloc() initializes the allocated memory with garbage \nvalues. \n\nNumber of arguments is 2 \nNumber of argument is 1 \n\nSyntax : \n\n(cast_type *)calloc(blocks , size_of_block); \n\nSyntax : \n\n(cast_type *)malloc(Size_in_bytes); \n\n\n\n\n\nrealloc() : changes memory size that is already allocated to a variable. \n\nOr \n\nIf the previously allocated memory is insufficient or more than required, you can change the \npreviously allocated memory size using realloc(). \n\n\uf0b7 \nIf memory is not sufficient for malloc() or calloc(), you can reallocate the memory by \nrealloc() function. In short, it changes the memory size. By using realloc() we can create \nthe memory dynamically at middle stage. Generally by using realloc() we can \nreallocation the memory. Realloc() required 2 arguments of type void*, size_type. Void* \nwill indicates previous block base address, size-type is data type size. Realloc() will \ncreates the memory in bytes format and initial value is garbage. \n\n\n\nsyntax \n\nptr=realloc(ptr, new-size) \n\nExample \n\nint *x; \n\nx=(int*)malloc(50 * sizeof(int)); \n\nx=(int*)realloc(x,100); //allocated a new memory to variable x \n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 232 \n\n\nExample \n\nvoid *realloc( void *, size-type); \n\nint *arr; \n\narr=( int *)calloc(5, sizeof ( int )); \n\n..... \n\n........ \n\n.... \n\narr=( int *)realloc(arr, sizeof ( int )*10); \n\nExample: \n\n#include <stdio.h> \n\n#include <stdlib.h> \n\nint main() \n\n{ \n\nint *ptr, i , n1, n2; \n\nprintf(\"Enter size of array: \"); \n\nscanf(\"%d\", &n1); \n\nptr = (int*) malloc(n1 * sizeof(int)); \n\nprintf(\"Address of previously allocated memory: \"); \n\nfor(i = 0; i < n1; ++i) \n\nprintf(\"%u\\t\",ptr + i); \n\nprintf(\"\\nEnter new size of array: \"); \n\nscanf(\"%d\", &n2); \n\nptr = realloc(ptr, n2); \n\nfor(i = 0; i < n2; ++i) \n\nprintf(\"%u\\t\", ptr + i); \n\nreturn 0; \n\n} \n\n\n\n\n\n\n\nC PROGRAMMING \nPage 233 \n\n\nfree() \n\nWhen your program comes out, operating system automatically release all the memory allocated \nby your program but as a good practice when you are not in need of memory anymore then you \nshould release that memory by calling the function free(). \n\nThe memory occupied by malloc() or calloc() functions must be released by calling free() \nfunction. Otherwise, it will consume memory until program exit. \n\nOr \n\nDynamically allocated memory created with either calloc() or malloc() doesn't get freed on its \nown. You must explicitly use free() to release the space. \n\nSyntax: \n\nfree(ptr); \n\n\n\nExample \n\n#include <stdio.h> \n\n#include <stdlib.h> \n\nint main() \n\n{ \n\nint num, i, *ptr, sum = 0; \n\n\n\nprintf(\"Enter number of elements: \"); \n\nscanf(\"%d\", &num); \n\n\n\nptr = (int*) malloc(num * sizeof(int));  //memory allocated using malloc \n\nif(ptr == NULL) \n\n{ \n\nprintf(\"Error! memory not allocated.\"); \n\nexit(0); \n\n} \n\nprintf(\"Enter elements of array: \"); \n\nfor(i = 0; i < num; ++i) \n\n{ \n\nscanf(\"%d\", ptr + i); \n\nC PROGRAMMING \nPage 234 \n\n\nsum += *(ptr + i); \n\n} \n\nprintf(\"Sum = %d\", sum); \n\nfree(ptr); \n\nreturn 0; \n\n} \n\n\n\nCommand \u2010 Line Arguments: \n\nIt is possible to pass some values from the command line to your C programs when they are \nexecuted. These values are called command line arguments and many times they are important \nfor your program especially when you want to control your program from outside instead of hard \ncoding those values inside the code. \n\nThe arguments passed from command line are called command line arguments. These arguments \nare handled by main() function. \n\nTo support command line argument, you need to change the structure of main() function \n\nSyntax: \n\nint main( int argc, char *argv[] ) \n\nHere, argc counts the number of arguments. It counts the file name as the first argument. \n\nThe argv[] contains the total number of arguments. The first argument is the file name always. \n\n\n\nExample1 \n\n#include <stdio.h> \n\nint main( int argc, char *argv[] )  { \n\nif( argc == 2 ) { \n\nprintf(\"The argument supplied is %s\\n\", argv[1]); \n\n} \n\nelse if( argc > 2 ) { \n\nprintf(\"Too many arguments supplied.\\n\"); \n\n} \n\nelse { \n\nprintf(\"One argument expected.\\n\"); \n\n} \n\nC PROGRAMMING \nPage 235 \n\n\n} \n\nOutput \n\n\n\n\n\nExample2 \n\n#include <stdio.h> \n\nvoid main(int argc, char *argv[] )  { \n\nprintf(\"Program name is: %s\\n\", argv[0]); \n\nif(argc < 2){ \n\nprintf(\"No argument passed through command line.\\n\"); \n\n} \n\nelse{ \n\nprintf(\"First argument is: %s\\n\", argv[1]); \n\n} \n\n} \n\nOutput \n\nprogram.exe hello \n\nProgram name is: program \n\nFirst argument is: hello \n\nNote \n\nBut if you pass many arguments within double quote, all arguments will be treated as a single \nargument only. \n\nExample \n\n./program \"hello c how r u\" \n\nProgram name is: program \n\nFirst argument is: hello c how r u \n\nYou can write your program to print all the arguments. In this program, we are printing \nonly argv[1], that is why it is printing only one argument. \n\n\n\n\n\n\n\nC PROGRAMMING \nPage 236 \n\n\nExample3 \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main(int argc, char* argv[]) \n\n{ \n\nint i; \n\nclrscr(); \n\nprintf(\"Total number of arguments: %d\",argc); \n\nfor(i=0;i< argc;i++) \n\n{ \n\nprintf(\"\\n %d argument: %s\",i,argv[i]); \n\ngetch(); \n\n} \n\n} \n\n\n\nOutput \n\nC:/TC/BIN>TCC mycmd.c \n\nC:/TC/BIN>mycmd 10 20 \n\nNumber of Arguments: 3 \n\n0 arguments c:/tc/bin/mycmd.exe \n\n1 arguments: 10 \n\n2 arguments: 20 \n\nNote: In above output we passed two arguments but is show \"Number of Arguments: 3\" \nbecause argc take Number of arguments in the command line including program name. So here \ntwo arguments and one program name (mycmd.exe) total 3 arguments. \n\n\n\n\n![Image](/src/assets/generated_images/cp_p236_i0.png)\nC PROGRAMMING \nPage 237 \n\n\n\n\n\n\nExample4: \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main(int argc, char* argv[]) \n\n{ \n\nclrscr(); \n\nprintf(\"\\n Program name  : %s \\n\", argv[0]); \n\nprintf(\"1st arg  : %s \\n\", argv[1]); \n\nprintf(\"2nd arg  : %s \\n\", argv[2]); \n\nprintf(\"3rd arg  : %s \\n\", argv[3]); \n\nprintf(\"4th arg  : %s \\n\", argv[4]); \n\nprintf(\"5th arg  : %s \\n\", argv[5]); \n\ngetch(); \n\n} \n\nOutput \n\nC:/TC/BIN>TCC mycmd.c \n\nC:/TC/BIN>mycmd this is a program \n\nC PROGRAMMING \nPage 238 \n\n\nProgram name : c:/tc/bin/mycmd.c \n\n1st arg : this \n\n2nd arg : is \n\n3rd arg : a \n\n4th arg : program \n\n5th arg : (null) \n\nExplanation: In the above example. \n\nargc      =   5 \n\nargv[0]   =   \"mycmd\" \n\nargv[1]   =   \"this\" \n\nargv[2]   =   \"is\" \n\nargv[3]   =   \"a\" \n\nargv[4]   =   \"program\" \n\nargv[5]   =   NULL \n\nWhy command line arguments program not directly run form TC IDE \n\nCommand line arguments related programs are not execute directly from TC IDE because \narguments can not be passed. \n\nEdit Command Line Argument Program \n\nTo Edit the Command Line Argument Program use edit Command. \n\nSyntax \n\nC:/cprogram>edit mycmd.c \n\n\n\nUNIT IV \n\nSTRUCTURES, UNIONS, ENUMERATIONS AND TYPEDEF \n\n\n\nStructure Definition \n\nStructure is a user defined data type which hold or store heterogeneous/different types data item \nor element in a single variable. It is a Combination of primitive and derived data type. \n\nor \n\nC PROGRAMMING \nPage 239 \n\n\nA structure is a collection of one or more data items of different data types, grouped together \nunder a single name. \n\nVariables inside the structure are called members of structure. \n\nEach element of a structure is called a member. \n\nstruct keyword is used to define/create a structure. struct define a new data type which is a \ncollection of different type of data. \n\nSyntax \n\nstruct structure_name /tag name \n\n{ \n\ndata_type member1; \n\ndata_type member2; \n\n. \n\n. \n\ndata_type member n; \n\n}; \n\nNote: Don't forget the semicolon }; in the ending line. \n\n\n\n\n\n\n\nExample \n\nstruct employee \n\n{   int id; \n\nchar name[50]; \n\nfloat salary; \n\n}; \n\n\n![Image](/src/assets/generated_images/cp_p239_i0.png)\nC PROGRAMMING \nPage 240 \n\n\nHere, struct is \nthe \nkeyword, employee is \nthe \ntag \nname \nof \nstructure; id , name and salary are the members or fields of the structure. Let's \nunderstand it by the diagram given below: \n\n\n\n\n\n\n\nSyntax to create structure variable \n\nstruct tagname/structure_name variable; \n\n\n\nDeclaring structure variable \n\nWe can declare variable for the structure, so that we can access the member of structure easily. \nThere are two ways to declare structure variable: \n\n1. By struct keyword within main() function/ Declaring Structure variables separately \n\n2. By declaring variable at the time of defining structure/ Declaring Structure Variables \n\nwith Structure definition \n\n1st way: \n\nLet's see the example to declare structure variable by struct keyword. It should be declared \nwithin the main function. \n\n\n\nstruct employee \n\n{ int id; \n\nC PROGRAMMING \nPage 241 \n\n\nchar name[50]; \n\nfloat salary; \n\n}; \n\nNow write given code inside the main() function. \n\nstruct employee e1, e2; \n\n\n\n2nd way: \n\nLet's see another way to declare variable at the time of defining structure. \n\nstruct employee \n\n{ int id; \n\nchar name[50]; \n\nfloat salary; \n\n}e1,e2; \n\n\n\nWhich approach is good \n\nBut if no. of variable are not fixed, use 1st approach. It provides you flexibility to declare the \nstructure variable many times. \n\nIf no. of variables are fixed, use 2nd approach. It saves your code to declare variable in main() \nfunction. \n\n\n\nStructure Initialization \n\nstructure variable can also be initialized at compile time. \n\nstruct Patient \n\n{ \n\nfloat height; \n\nint weight; \n\nC PROGRAMMING \nPage 242 \n\n\nint age; \n\n}; \n\n\n\nstruct Patient p1 = { 180.75 , 73, 23 }; //initialization \n\nor \n\nstruct patient p1; \n\np1.height = 180.75; //initialization of each member separately \n\np1.weight = 73; \n\np1.age = 23; \n\nAccessing  Structures/ Accessing members of structure \n\nThere are two ways to access structure members: \n\n1. By . (member or dot operator) \n\n2. By -> (structure pointer operator) \n\nWhen the variable is normal type then go for struct to member operator. \n\nWhen the variable is pointer type then go for pointer to member operator. \n\n\n\nAny member of a structure can be accessed as: \n\nstructure_variable_name.member_name \n\nExample \n\nstruct book \n\n{ \n\nchar name[20]; \n\nchar author[20]; \n\nint pages; \n\n}; \n\nC PROGRAMMING \nPage 243 \n\n\nstruct book b1; \n\nfor accessing the structure members from the above example \n\n\n\nb1.name, b1.author, b1.pages: \n\nExample \n\nstruct emp \n\n{ \n\nint id; \n\nchar name[36]; \n\nint sal; \n\n}; \n\nsizeof(struct emp) \n// --> 40 byte (2byte+36byte+2byte) \n\nExample of Structure in C \n\n#include<stdio.h> \n\n#include<conio.h> \n\nstruct emp \n\n{ \n\nint id; \n\nchar name[36]; \n\nfloat sal; \n\n}; \n\nvoid main() \n\n{ \n\nstruct emp e; \n\nclrscr(); \n\nprintf(\"Enter employee Id, Name, Salary: \"); \n\nC PROGRAMMING \nPage 244 \n\n\nscanf(\"%d\",&e.id); \n\nscanf(\"%s\",&e.name); \n\nscanf(\"%f\",&e.sal); \n\n\n\nprintf(\"Id: %d\",e.id); \n\nprintf(\"\\nName: %s\",e.name); \n\nprintf(\"\\nSalary: %f\",e.sal); \n\ngetch(); \n\n} \n\nOutput \n\nOutput: Enter employee Id, Name, Salary: 5 Spidy 45000 \n\nId : 05 \n\nName: Spidy \n\nSalary: 45000.00 \n\n\n\nExample \n\n#include <stdio.h> \n\n#include <string.h> \n\nstruct employee \n\n{ int id; \n\nchar name[50]; \n\n}e1;  //declaring e1 variable for structure \n\nint main( ) \n\n{ \n\n//store first employee information \n\nC PROGRAMMING \nPage 245 \n\n\ne1.id=101; \n\nstrcpy(e1.name, \"Sonoo Jaiswal\");//copying string into char array \n\n//printing first employee information \n\nprintf( \"employee 1 id : %d\\n\", e1.id); \n\nprintf( \"employee 1 name : %s\\n\", e1.name); \n\nreturn 0; \n\n} \n\nOutput: \n\nemployee 1 id : 101 \n\nemployee 1 name : Sonoo Jaiswal \n\nDifference Between Array and Structure \n\n1 Array is collection of homogeneous data. \nStructure is the collection of \nheterogeneous data. \n\n2 Array data are access using index. \nStructure elements are access using . \noperator. \n\n3 Array allocates static memory. \nStructures allocate dynamic memory. \n\n4 Array element access takes less time than \n\nstructures. \n\nStructure elements takes more time than \nArray. \n\n\n\n\n\nNested Structures \n\nstructure can have another structure as a member. There are two ways to define nested structure \nin c language: \n\n1. By separate structure \n\n2. By Embedded structure \n\n1) Separate structure \n\nWe can create 2 structures, but dependent structure should be used inside the main structure as a \nmember. Let's see the code of nested structure. \n\nC PROGRAMMING \nPage 246 \n\n\nstruct Date \n\n{ \n\nint dd; \n\nint mm; \n\nint yyyy; \n\n}; \n\n\n\nstruct Employee \n\n{ \n\nint id; \n\nchar name[20]; \n\nstruct Date doj; \n\n}emp1; \n\n2) Embedded structure \n\nstruct Employee \n\n{ \n\nint id; \n\nchar name[20]; \n\nstruct Date \n\n{ \n\nint dd; \n\nint mm; \n\nint yyyy; \n\n}doj; \n\n}emp1; \n\nC PROGRAMMING \nPage 247 \n\n\nAccessing Nested Structure \n\nWe can access the member of nested structure by Outer_Structure.Nested_Structure.member as \ngiven below: \n\ne1.doj.dd \n\ne1.doj.mm \n\ne1.doj.yyyy \n\n\n\nArrays of Structures \n\nArray of structures to store much information of different data types. Each element of the array \nrepresenting a structure variable. The array of structures is also known as collection of \nstructures. \n\nEx : if you want to handle more records within one structure, we need not specify the number of \nstructure variable. Simply we can use array of structure variable to store them in one structure \nvariable. \n\nExample : struct employee emp[5]; \n\nExample of structure with array that stores information of 5 students and prints it. \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\nstruct student{ \n\nint rollno; \n\nchar name[10]; \n\n}; \n\nvoid main(){ \n\nint i; \n\nstruct student st[5]; \n\nclrscr(); \n\nC PROGRAMMING \nPage 248 \n\n\nprintf(\"Enter Records of 5 students\"); \n\nfor (i=0;i<5;i++){ \n\nprintf(\"\\nEnter Rollno:\"); \n\nscanf(\"%d\",&st[i].rollno); \n\nprintf(\"\\nEnter Name:\"); \n\nscanf(\"%s\",&st[i].name); \n\n} \n\nprintf(\"\\nStudent Information List:\"); \n\nfor (i=0;i<5;i++){ \n\nprintf(\"\\nRollno:%d, Name:%s\",st[i].rollno,st[i].name); \n\n} \n\ngetch(); \n\n} \n\nOutput: \n\nEnter Records of 5 students \n\nEnter Rollno:1 \n\nEnter Name:Sonoo \n\nEnter Rollno:2 \n\nEnter Name:Ratan \n\nEnter Rollno:3 \n\nEnter Name:Vimal \n\nEnter Rollno:4 \n\nEnter Name:James \n\nEnter Rollno:5 \n\nEnter Name:Sarfraz \n\nC PROGRAMMING \nPage 249 \n\n\nStudent Information List: \n\nRollno:1, Name:Sonoo \n\nRollno:2, Name:Ratan \n\nRollno:3, Name:Vimal \n\nRollno:4, Name:James \n\nRollno:5, Name:Sarfraz \n\n\n\nStructures and Functions \n\nA structure can be passed as a function argument just like any other variable. This raises a few \npractical issues. \n\nPASSING STRUCTURE TO FUNCTION IN C: \n\nIt can be done in below 3 ways. \n\n1. Passing structure to a function by value \n\n2. Passing structure to a function by address(reference) \n\n3. No need to pass a structure \u2013 Declare structure variable as global \n\n. \n\n\n\nThe general format of sending a copy of a structure to the called function is: \n\n\n\n\n\nFunction_name(structure_variable_name); \n\n\n\nThe called function takes the following form: \n\n\n\n\n\ndata_type function_name(struct tag_name var) \n\n\n\n{ \n\nC PROGRAMMING \nPage 250 \n\n\n\n\n\n---------- \n\n\n\n\n---------- \n\n\n\n\nreturn(exp); \n\n\n\n} \n\n\n\nPASSING STRUCTURE TO FUNCTION IN C BY VALUE: \n\n#include <stdio.h> \n\n#include <string.h> \n\nstruct student \n\n{ \n\nint id; \n\nchar name[20]; \n\nfloat percentage; \n\n}; \n\nvoid func(struct student record); \n\nint main() \n\n{ \n\nstruct student record; \n\nrecord.id=1; \n\nstrcpy(record.name, \"Raju\"); \n\nrecord.percentage = 86.5; \n\nfunc(record); \n\nreturn 0; \n\n} \n\nvoid func(struct student record) \n\nC PROGRAMMING \nPage 251 \n\n\n{ \n\nprintf(\" Id is: %d \\n\", record.id); \n\nprintf(\" Name is: %s \\n\", record.name); \n\nprintf(\" Percentage is: %f \\n\", record.percentage); \n\n} \n\nOutput \n\nId is: 1 \n\nName is: Raju \n\nPercentage is: 86.500000 \n\nPASSING STRUCTURE TO FUNCTION IN C BY ADDRESS: \n\n#include <stdio.h> \n\n#include <string.h> \n\nstruct student \n\n{ \n\nint id; \n\nchar name[20]; \n\nfloat percentage; \n\n}; \n\nvoid func(struct student *record); \n\nint main() \n\n{ \n\nstruct student record; \n\nrecord.id=1; \n\nstrcpy(record.name, \"Raju\"); \n\nrecord.percentage = 86.5; \n\nC PROGRAMMING \nPage 252 \n\n\nfunc(&record); \n\nreturn 0; \n\n} \n\nvoid func(struct student *record) \n\n{ \n\nprintf(\" Id is: %d \\n\", record->id); \n\nprintf(\" Name is: %s \\n\", record->name); \n\nprintf(\" Percentage is: %f \\n\", record->percentage); \n\n} \n\n\n\nEXAMPLE PROGRAM TO DECLARE A STRUCTURE VARIABLE AS GLOBAL IN \nC: \n\n#include <stdio.h> \n\n#include <string.h> \n\nstruct student \n\n{ \n\nint id; \n\nchar name[20]; \n\nfloat percentage; \n\n}; \n\nstruct student record; // Global declaration of structure \n\nvoid structure_demo(); \n\nint main() \n\n{ \n\nrecord.id=1; \n\nC PROGRAMMING \nPage 253 \n\n\nstrcpy(record.name, \"Raju\"); \n\nrecord.percentage = 86.5; \n\n\n\nstructure_demo(); \n\nreturn 0; \n\n} \n\n\n\nvoid structure_demo() \n\n{ \n\nprintf(\" Id is: %d \\n\", record.id); \n\nprintf(\" Name is: %s \\n\", record.name); \n\nprintf(\" Percentage is: %f \\n\", record.percentage); \n\n} \n\n\n\n\n\n\n\nPassing a copy of entire structure to a function \n\nstruct std \n\n{ \n\nint no; \n\nfloat avg; \n\n}; \n\nstruct std a; \n\nvoid fun(struct std p); \n\nvoid main() \n\nC PROGRAMMING \nPage 254 \n\n\n{ \n\nclrscr(); \n\na.no=12; \n\na.avg=13.76; \n\nfun(a); \n\ngetch(); \n\n} \n\nvoid fun(struct std p) \n\n{ \n\nprintf(\"number is%d\\n\",p.no); \n\nprintf(\"average is%f\\n\",p.avg); \n\n} \n\n\n\n\n\n\n\n\n\nPassing Structures through Pointers \n\nExample \n\n#include <stdio.h> \n\n#include <string.h> \n\nstruct student \n\n{ \n\nint id; \n\nchar name[30]; \n\nfloat percentage; \n\nC PROGRAMMING \nPage 255 \n\n\n}; \n\nint main() \n\n{ \n\nint i; \n\nstruct student record1 = {1, \"Raju\", 90.5}; \n\nstruct student *ptr; \n\nptr = &record1; \n\nprintf(\"Records of STUDENT1: \\n\"); \n\nprintf(\"  Id is: %d \\n\", ptr->id); \n\nprintf(\"  Name is: %s \\n\", ptr->name); \n\nprintf(\"  Percentage is: %f \\n\\n\", ptr->percentage); \n\n\n\nreturn 0; \n\n} \n\nOUTPUT: \n\nRecords \nof \nSTUDENT1: \nId \nis: \n1 \nName is: Raju \n\n\nPercentage is: 90.500000 \n\n\n\nSelf \u2010 referential Structures \n\nA structure consists of at least a pointer member pointing to the same structure is known as a \nself-referential structure. A self referential structure is used to create data structures like linked \nlists, stacks, etc. Following is an example of this kind of structure: \n\n\n\nC PROGRAMMING \nPage 256 \n\n\nA self-referential structure is one of the data structures which refer to the pointer to (points) to \nanother structure of the same type. For example, a linked list is supposed to be a self-referential \ndata structure. The next node of a node is being pointed, which is of the same struct type. For \nexample, \n\n\nSyntax : struct tag_name \n\n{ \n\ntype member1; \n\ntype membere2; \n\n:             : \n\n:             : \n\ntypeN memberN; \n\nstruct tag_name *name; \n\n} \n\n\n\nWhere *name refers to the name of a pointer variable. \n\n\n\nEx: \n\nstruct emp \n\n{ \n\nint code; \n\nstruct emp *name; \n\n} \n\n\n\nUnions \n\nA union is a special data type available in C that allows to store different data types in the same \nmemory location. \n\n\n![Image](/src/assets/generated_images/cp_p256_i0.png)\nC PROGRAMMING \nPage 257 \n\n\nUnions are conceptually similar to structures . The syntax of union is also similar to that of \nstructure. The only difference is in terms of storage. In structure each member has its own \nstorage location, whereas all members of union use a single shared memory location which is \nequal to the size of its largest data member. \n\nWe can access only one member of union at a time . We can\u201ft access all member values at the \nsame time in union. But, structure can access all member values at the same time. This is \nbecause, Union allocates one common storage space for all its members. Where as Structure \nallocates storage space for all its members separately. \n\n\n\n\n\n\n![Image](/src/assets/generated_images/cp_p257_i0.png)\nC PROGRAMMING \nPage 258 \n\n\n\n\nsyntax \n\nunion union_name \n\n{ \n\ndata_type member1; \n\ndata_type member2; \n\n. \n\n. \n\ndata_type memeberN; \n\n}; \n\nExample \n\nunion employee \n\n{   int id; \n\nchar name[50]; \n\nfloat salary; \n\n}; \n\nExample \n\nC PROGRAMMING \nPage 259 \n\n\n#include <stdio.h> \n\n#include <string.h> \n\nunion employee \n\n{ int id; \n\nchar name[50]; \n\n}e1;  //declaring e1 variable for union \n\nint main( ) \n\n{ \n\n//store first employee information \n\ne1.id=101; \n\nstrcpy(e1.name, \"Sonoo Jaiswal\");//copying string into char array \n\n//printing first employee information \n\nprintf( \"employee 1 id : %d\\n\", e1.id); \n\nprintf( \"employee 1 name : %s\\n\", e1.name); \n\nreturn 0; \n\n} \n\nOutput: \n\nemployee 1 id : 1869508435 \n\nemployee 1 name : Sonoo Jaiswal \n\nAs you can see, id gets garbage value because name has large memory size. So only name will \nhave actual value. \n\nExample \n\n#include <stdio.h> \n\n#include <conio.h> \n\nunion item \n\nC PROGRAMMING \nPage 260 \n\n\n{ \n\nint a; \n\nfloat b; \n\nchar ch; \n\n}; \n\nint main( ) \n\n{ \n\nunion item it; \n\nit.a = 12; \n\nit.b = 20.2; \n\nit.ch='z'; \n\nclrscr(); \n\nprintf(\"%d\\n\",it.a); \n\nprintf(\"%f\\n\",it.b); \n\nprintf(\"%c\\n\",it.ch); \n\ngetch(); \n\nreturn 0; \n\n} \n\nOutput \n\n-26426 \n\n20.1999 \n\nz \n\nAs you can see here, the values of a and b get corrupted and only variable c prints the expected \nresult. Because in union , the only member whose value is currently stored will have the memory. \n\n\n\nC PROGRAMMING \nPage 261 \n\n\nDifference between Structure and Union \n\n\n\nStructure \nUnion \n\n1 For defining structure use \n\nstruct keyword. \nFor defining union we use union keyword \n\n2 Structure \noccupies \nmore \nmemory space than union. \nUnion occupies less memory space than Structure. \n\n3 \n\nIn Structure we can access \nall members of structure at a \ntime. \n\nIn union we can access only one member of union at a time. \n\n4 \n\nStructure allocates separate \nstorage space for its every \nmembers. \n\nUnion allocates one common storage space for its all \nmembers. Union find which member need more memory \nthan other member, then it allocate that much space \n\nBit \u2010 Fields \n\nSyntax \n\nstruct { \n\ntype [member_name] : width ; \n\n}; \n\nThe following table describes the variable elements of a bit field \u2212 \n\nElements \nDescription \n\ntype \nAn integer type that determines how a bit-field's value is interpreted. \nThe type may be int, signed int, or unsigned int. \n\nmember_name \nThe name of the bit-field. \n\nwidth \nThe number of bits in the bit-field. The width must be less than or equal \nto the bit width of the specified type. \n\nC PROGRAMMING \nPage 262 \n\n\n\n\nThe variables defined with a predefined width are called bit fields . A bit field can hold more \nthan a single bit; for example, if you need a variable to store a value from 0 to 7, then you can \ndefine a bit field with a width of 3 bits as follows \u2212 \n\nstruct { \n\nunsigned int age : 3; \n\n} Age; \n\nThe above structure definition instructs the C compiler that the age variable is going to use only \n3 bits to store the value. If you try to use more than 3 bits, then it will not allow you to do so. Let \nus try the following example \u2013 \n\n#include <stdio.h> \n\n#include <string.h> \n\nstruct { \n\nunsigned int age : 3; \n\n} Age; \n\nint main( ) { \n\nAge.age = 4; \n\nprintf( \"Sizeof( Age ) : %d\\n\", sizeof(Age) ); \n\nprintf( \"Age.age : %d\\n\", Age.age ); \n\nAge.age = 7; \n\nprintf( \"Age.age : %d\\n\", Age.age ); \n\nAge.age = 8; \n\nprintf( \"Age.age : %d\\n\", Age.age ); \n\nreturn 0; \n\n} \n\nOutput \n\nSizeof( Age ) : 4 \n\nC PROGRAMMING \nPage 263 \n\n\nAge.age : 4 \n\nAge.age : 7 \n\nAge.age : 0 \n\ntypedef \n\nThe typedef is a keyword that allows the programmer to create a new data type name for an \nexisting data type. So, the purpose of typedef is to redefine the name of an existing variable type. \n\nSyntax \n\ntypedef  datatype alias_name; \n\nExample of typedef \n\n#include<stdio.h> \n\n#include<conio.h> \n\ntypedef int Intdata; // Intdata is alias name of int \n\nvoid main() \n\n{ \n\nint a=10; \n\nIntegerdata b=20; \n\ntypedef Intdata Integerdata; // Integerdata is again alias name of Intdata \n\nIntegerdata s; \n\nclrscr(); \n\ns=a+b; \n\nprintf(\"\\n Sum:= %d\",s); \n\ngetch(); \n\n} \n\nOutput \n\nSum: 20 \n\nC PROGRAMMING \nPage 264 \n\n\n\n\n\n\n\n\nAdvantages of typedef : \n\n\n\n1 : Provides a meaningful way of declaring the variable. \n\n2 : Increase the readability of the program. \n\n\n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main() \n\n{ \n\ntypedef int digits; \n\ndigits a,b,sum; \n\nclrscr(); \n\nprintf(\"Enter a and b values:\"); \n\nscanf(\"%d%d\",&a,&b); \n\nsum=a+b; \n\nprintf(\"The sum is:%d\",sum); \n\ngetch(); \n\n} \n\n\n\n\n![Image](/src/assets/generated_images/cp_p264_i0.png)\nC PROGRAMMING \nPage 265 \n\n\n\n\n\n\nNote : By using typedef only we can create the alias name and it is under control of compiler. \n\n\n\nApplication of typedef \n\ntypedef can be used to give a name to user defined data type as well. Lets see its use with \nstructures. \n\ntypedef struct \n\n{ \n\ntype member1; \n\ntype member2; \n\ntype member3; \n\n} type_name ; \n\n\n\nC PROGRAMMING \nPage 266 \n\n\nHere type_name represents the stucture definition associated with it. Now this type_name can \nbe used to declare a variable of this stucture type. \n\ntype_name t1, t2 ; \n\nExample of structure definition using typedef \n\n#include<stdio.h> \n\n#include<conio.h> \n\n#include<string.h> \n\ntypedef struct employee \n\n{ \n\nchar  name[50]; \n\nint   salary; \n\n} emp ; \n\nvoid main( ) \n\n{ \n\nemp e1; \n\nprintf(\"\\nEnter Employee record\\n\"); \n\nprintf(\"\\nEmployee name\\t\"); \n\nscanf(\"%s\",e1.name); \n\nprintf(\"\\nEnter Employee salary \\t\"); \n\nscanf(\"%d\",&e1.salary); \n\nprintf(\"\\nstudent name is %s\",e1.name); \n\nprintf(\"\\nroll is %d\",e1.salary); \n\ngetch(); \n\n} \n\n\n\nC PROGRAMMING \nPage 267 \n\n\ntypedef and Pointers \n\ntypedef can be used to give an alias name to pointers also. Here we have a case in which use of \ntypedef is beneficial during pointer declaration. \n\nIn Pointers * binds to the right and not the left. \n\nint* x, y ; \n\nBy this declaration statement, we are actually declaring x as a pointer of type int, whereas y will \nbe declared as a plain integer. \n\ntypedef int* IntPtr ; \n\nIntPtr x, y, z; \n\nBut if we use typedef like in above example, we can declare any number of pointers in a single \nstatement. \n\nNOTE : If you do not have any prior knowledge of pointers, do study Pointers first. \n\n\n\nEnumerations \n\nAn enum is a keyword, it is an user defined data type. All properties of integer are applied on \nEnumeration data type so size of the enumerator data type is 2 byte. It work like the Integer. \n\nIt is used for creating an user defined data type of integer. Using enum we can create sequence of \ninteger constant value. \n\nSyntax \n\nenum tagname {value1, value2, value3,....}; \n\n\uf0b7 \nIn above syntax enum is a keyword. It is a user defiend data type. \n\n\uf0b7 \nIn above syntax tagname is our own variable. tagname is any variable name. \n\n\uf0b7 \nvalue1, value2, value3,.... are create set of enum values. \n\n\n![Image](/src/assets/generated_images/cp_p267_i0.png)\nC PROGRAMMING \nPage 268 \n\n\n\n\nIt is start with 0 (zero) by default and value is incremented by 1 for the sequential identifiers in \nthe list. If constant one value is not initialized then by default sequence will be start from zero \nand next to generated value should be previous constant value one. \n\nExample of Enumeration in C \n\n#include<stdio.h> \n\n#include<conio.h> \n\nenum ABC {x,y,z}; \n\nvoid main() \n\n{ \n\nint a; \n\nclrscr(); \n\na=x+y+z; \n//0+1+2 \n\nprintf(\"Sum: %d\",a); \n\ngetch(); \n\n} \n\nOutput \n\nSum: 3 \n\nExample of Enumeration in C \n\n#include<stdio.h> \n\nC PROGRAMMING \nPage 269 \n\n\n#include<conio.h> \n\nenum week {sun, mon, tue, wed, thu, fri, sat}; \n\nvoid main() \n\n{ \n\nenum week today; \n\ntoday=tue; \n\nprintf(\"%d day\",today+1); \n\ngetch(); \n\n} \n\nOutput \n\n3 day \n\nExample of Enumeration in C \n\n#include<stdio.h> \n\n#include<conio.h> \n\nenum week {sun, mon, tue, wed, thu, fri, sat}; \n\nvoid main() \n\n{ \n\nfor (i=sun; i<=sat; i++) \n\n{ \n\nprintf(\"%d \",i); \n\n} \n\ngetch(); \n\n} \n\nOutput \n\nIn above code replace sun, mon, tue,.... with Equivalent numeric value 0, 1, 2,... \n\nC PROGRAMMING \nPage 270 \n\n\nUNIT \u2013 V \n\nFILE \n\nWhy files are needed? \n\n\uf0b7 \nWhen a program is terminated, the entire data is lost. Storing in a file will preserve your \ndata even if the program terminates. \n\n\uf0b7 \nIf you have to enter a large number of data, it will take a lot of time to enter them all. \nHowever, if you have a file containing all the data, you can easily access the contents of \nthe file using few commands in C. \n\n\uf0b7 \nYou can easily move your data from one computer to another without any changes. \n\nFile I/O: - \n\nSometimes it is necessary to store the data in a manner that can be later retrieved and displayed \neither in a part or in whole. This medium is usually a \u201cfile\u201d on the disk. File I/O can be handled \nby using different functions. \n\na) Formatted functions :- The file input function fscanf( ) and the file output function fprintf( ) \nare called formatted file I/O functions. \n\nb)Unformatted functions: - The input functions like getc( ), getw( ), and fread( ) are called \nunformatted file input functions and putc( ), putw( ), and fwrite( ) functions are unformatted file \noutput functions. Each and every function is having its own syntax and meaning. \n\nFile streams:- Stream is either reading or writing of data. The streams are designed to allow the \nuser to access the files efficiently. A stream is a file or physical device like key board, printer, \nmonitor, etc., The FILE object uses these devices. When a C program is started, the operating \nsystem is responsible for opening three streams: standard input stream ( stdin ), standard output \nstream ( stdout ), standard error( stderr ).Normally the stdin is connected to the keyboard, the \nstdout and stderr are connected to the monitor. \n\nFiles \n\nFile is a collection of bytes that is stored on secondary storage devices like Hard disk. \n\nOR \n\nA file represents a sequence of bytes on the disk where a group of related data is stored. File is \ncreated for permanent storage of data. It is a ready made structure. \n\nNote: \n\nC PROGRAMMING \nPage 271 \n\n\nAll files related function are available in stdio.h header file. \n\nTypes of Files \n\nWhen dealing with files, there are two types of files you should know about: \n\n1. Text files \n\n2. Binary files \n\n1. Text files \n\nText files are the normal .txt files that you can easily create using Notepad or any simple text \neditors. \n\nWhen you open those files, you'll see all the contents within the file as plain text. You can easily \nedit or delete the contents. \n\nThey take minimum effort to maintain, are easily readable, and provide least security and takes \nbigger storage space. \n\n2. Binary files \n\nBinary files are mostly the .bin files in your computer. \n\nInstead of storing data in plain text, they store it in the binary form (0's and 1's). \n\nThey can hold higher amount of data, are not readable easily and provides a better security than \ntext files. \n\n\n\nFile Operations \n\nIn C, you can perform four major operations on the file, either text or binary: \n\n\uf0b7 \nNaming a file/Creation of new file \n\n\uf0b7 \nOpening an existing file \n\n\uf0b7 \nReading data from file \n\n\uf0b7 \nWriting data into file \n\n\uf0b7 \nClosing a file \n\nSteps for processing a file \n\n\uf0d8 Declare a file pointer \n\uf0d8 open a file using fopen() function \n\uf0d8 Process the file using suitable file functions. \n\uf0d8 close the file using fclose() function. \n\nC PROGRAMMING \nPage 272 \n\n\nDeclaration of a file \n\nWhen working with files, you need to declare a pointer of type file. This declaration is needed \nfor communication between the file and program. \n\nSyntax \n\nFILE *fp ; \n\nOpening a file - for creation and edit \n\nThe fopen() function is used to create a new file or to open an existing file. \n\nGeneral Syntax : \n\nfp = fopen(\"fileopen\",\"mode\") \n\nFor Example: \n\nfopen(\"E:\\\\cprogram\\\\newprogram.txt\",\"w\"); \n\nfopen(\"E:\\\\cprogram\\\\oldprogram.bin\",\"rb\"); \n\nClosing a File \n\nThe file (both text and binary) should be closed after reading/writing. \n\nClosing a file is performed using library function fclose(). \n\nfclose(fptr); //fptr is the file pointer associated with file to be closed. \n\nFile Opening Modes \n\nMode \nDescription \n\nr \nopens a text file in read mode \n\nw \nopens a text file in write mode \n\na \nopens a text file in append mode \n\nr+ \nopens a text file in read and write mode \n\nw+ \nopens a text file in read and write mode \n\na+ \nopens a text file in read and write mode \n\nrb \nopens a binary file in read mode \n\nC PROGRAMMING \nPage 273 \n\n\nwb \nopens a binary file in write mode \n\nab \nopens a binary file in append mode \n\nrb+ \nopens a binary file in read and write mode \n\nwb+ \nopens a binary file in read and write mode \n\nab+ \nopens a binary file in read and write mode \n\n\n\nDifference between Append and Write Mode \n\nWrite (w) mode and Append (a) mode, while opening a file are almost the same. Both are used to \nwrite in a file. In both the modes, new file is created if it doesn't exists already. \n\nThe only difference they have is, when you open a file in the write mode, the file is reset, \nresulting in deletion of any data already present in the file. While in append mode this will not \nhappen. Append mode is used to append or add data to the existing data of file(if any). Hence, \nwhen you open a file in Append(a) mode, the cursor is positioned at the end of the present data in \nthe file. \n\nFormatted File I/O Functions \n\nSyntax of fprintf is \n\nfprintf (fp, \u201ccontrol string\u201d, list); \n\nExample: fprintf(fp1, \u201c%s %d\u201d, name, age); \n\nSyntax of fscanf  is, \n\nfscanf(fp, \u201ccontrol string\u201d, list); \n\nExample : fscanf(fp, \u201c%s %d\u201d, name, & age); \n\n\n\nNote: \n\n\uf0d8 fscanf is used to read list of items from a file \n\n\uf0d8 fprintf is used to write a list of items to a file. \n\n\n\nNote: \n\nEOF \u2013 End of file (when EOF encountered the reading / writing should be terminated) \n\nC PROGRAMMING \nPage 274 \n\n\n\n\nExample: \n\n#include <stdio.h> \n\nmain(){ \n\nFILE *fp; \n\nfp = fopen(\"file.txt\", \"w\");//opening file \n\nfprintf(fp, \"Hello file by fprintf...\\n\");//writing data into file \n\nfclose(fp);//closing file \n\n} \n\n\n\nExample 1: Write to a text file using fprintf() \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint num; \n\nFILE *fptr; \n\nfptr = fopen(\"C:\\\\program.txt\",\"w\"); \n\nif(fptr == NULL) \n\n{ \n\nprintf(\"Error!\"); \n\nexit(1); \n\n} \n\nprintf(\"Enter num: \"); \n\nscanf(\"%d\",&num); \n\nfprintf(fptr,\"%d\",num); \n\nfclose(fptr); \n\nreturn 0; \n\n} \n\nC PROGRAMMING \nPage 275 \n\n\n\n\nExample 2: Read from a text file using fscanf() \n\n#include <stdio.h> \n\nint main() \n\n{ \n\nint num; \n\nFILE *fptr; \n\nif ((fptr = fopen(\"C:\\\\program.txt\",\"r\")) == NULL){ \n\nprintf(\"Error! opening file\"); \n\n// Program exits if the file pointer returns NULL. \n\nexit(1); \n\n} \n\nfscanf(fptr,\"%d\", &num); \n\nprintf(\"Value of n=%d\", num); \n\nfclose(fptr); \n\nreturn 0; \n\n} \n\n\n\n\n\nInput/Output Operation on files \n\nTo perform Input/Output Operation on files we need below functions. \n\nS.No Function Operation \nSyntax \n\n1 \ngetc() \nRead a character from a file \ngetc( fp) \n\n\n\n2 \nputc() \nWrite a character in file \nputc(c, fp) \n\n\n\nC PROGRAMMING \nPage 276 \n\n\n3 \nfprintf() \nTo write set of data in file \nfprintf(fp, \"control string\", list) \n\n\n\n4 \nfscanf() \nTo read set of data from file. \nfscanf(fp, \"control string\", list) \n\n\n\n5 \ngetw() \nTo read an integer from a file. \ngetw(fp) \n\n\n\n6 \nputw() \nTo write an integer in file. \nputw(integer, fp) \n\n\n\nUnformatted  File I/O Functions \n\nfputc() function \n\nThe fputc() function is used to write a single character into file. \n\nputc ( ):- Putting a character in to the file. It works with only character data type. One character \nat a time can write into a file. \n\nEx: char ch =\u201fa\u201f; \n\n\n\n\nputc (ch, fp); \n\nExample: \n\n#include <stdio.h> \n\nmain(){ \n\nFILE *fp; \n\nfp = fopen(\"file1.txt\", \"w\");//opening file \n\nfputc('a',fp);//writing single character into file \n\nfclose(fp);//closing file \n\n} \n\n\n\nfile1.txt \na \n\n\n\nfgetc() function \n\nThe fgetc() function returns/read a single character from the file. It gets a character from the \nstream. It returns EOF at the end of file. \n\nC PROGRAMMING \nPage 277 \n\n\ngetc ( ): getting a character from the file, or reading the file information character by character at \na time, upto the end of the file by using this function. \n\n\n\nEx: \n\nchar ch; \n\n\n\nch = getc (fp); \n\n\n\nExample: \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main(){ \n\nFILE *fp; \n\nchar c; \n\nclrscr(); \n\nfp=fopen(\"myfile.txt\",\"r\"); \n\nwhile ((c=fgetc(fp))!=EOF){ \n\nprintf(\"%c\",c); \n\n} \n\nfclose(fp); \n\ngetch(); \n\n} \n\nmyfile.txt \n\nthis is simple text message \n\nfputs() \n\nThe fputs() function writes a line of characters into file \n\nExample: \n\n#include<stdio.h> \n\nC PROGRAMMING \nPage 278 \n\n\n#include<conio.h> \n\nvoid main(){ \n\nFILE *fp; \n\nclrscr(); \n\nfp=fopen(\"myfile2.txt\",\"w\"); \n\nfputs(\"hello c programming\",fp); \n\nfclose(fp); \n\ngetch(); \n\n} \n\nmyfile2.txt \n\nhello c programming \n\n\n\nfgets() \n\nThe fgets() function reads a line of characters from file. \n\nExample: \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main(){ \n\nFILE *fp; \n\nchar text[300]; \n\nclrscr(); \n\nfp=fopen(\"myfile2.txt\",\"r\"); \n\nprintf(\"%s\",fgets(text,200,fp)); \n\n\n\nfclose(fp); \n\nC PROGRAMMING \nPage 279 \n\n\ngetch(); \n\n} \n\nOutput: \n\nhello c programming \n\n\n\nThe  getw  and  putw  functions: \n\nThese are integer oriented functions. These are similar to above functions and are used to read \nand write integer values. These are useful when we deal with only integer data. The general \nformat is \n\nputw ( ): putting  or writing  of an integer value to a file. \n\nputw (integer , fp); \n\nEx: \n\nint  x = 5; \n\n\n\nputw(x,fp); \n\n\n\ngetw ( ): getting or reading integer value from  a file. \n\n\n\nEx: \n\nint x; \n\n\n\nx = getw (fp); \n\n\n\nFile Positioning Functions \n\nfseek() \n\nThe fseek() function is used to set the file pointer to the specified offset. It is used to write data \ninto file at desired location. \n\nsyntax : \n\nfseek(FILE * stream, long int offset, int whence) \n\nC PROGRAMMING \nPage 280 \n\n\nThe first parameter stream is the pointer to the file. The second parameter is the position of the \nrecord to be found, and the third parameter specifies the location where the offset starts. \n\nDifferent Whence in fseek \n\nWhence \nMeaning \n\nSEKK_SET \nStarts the offset from the beginning of the file. \n\nSEKK_END \nStarts the offset from the end of the file. \n\nSEKK_CUR \nStarts the offset from the current location of the cursor in the file. \n\n\n\nor \n\nfseek(file pointer, offset, position); \n\n\uf0b7 file pointer is a pointer to the concerned file. \n\n\uf0b7 Offset is a number or variable of type long, it specifies the number of positions (bytes) to \n\nbe moved from the location specified. If offset is positive number, then moving forward \nor negative meaning move backwards. \n\n\uf0b7 Position is a n integer number and it specifies from which position the file pointer to be \n\nmoved. Position can take one of the following three values. \n\n0 \nbeginning of file \n1 \ncurrent position \n2 \nend of file \n\nEg: \nfseek (fp, 0L,0); \n- \ngo to the beginning of the file. (Similar to rewind). \n\nfseek (fp, 0L,1); \n- \nStay at current position (Rarely used) \nfseek (fp, 0L,2); \n-go to the end of the file, past the last character of the file. \n\n\n\n\nExample: \n\n#include <stdio.h> \n\nvoid main(){ \n\nC PROGRAMMING \nPage 281 \n\n\nFILE *fp; \n\nfp = fopen(\"myfile.txt\",\"w+\"); \n\nfputs(\"This is javatpoint\", fp); \n\nfseek( fp, 7, SEEK_SET ); \n\nfputs(\"sonoo jaiswal\", fp); \n\nfclose(fp); \n\n} \n\nmyfile.txt \n\nThis is sonoo jaiswal \n\n\n\n\n\n\n\nrewind() \n\nThis function places the file pointer to the beginning of the file, irrespective of where it is present \nright now. It takes file pointer as an argument. \n\nSyntax: \n\nrewind( fp); \n\nExample: \n\nFile: file.txt \n\nthis is a simple text \n\n\n\nExample: \n\n#include<stdio.h> \n\n#include<conio.h> \n\nvoid main(){ \n\nC PROGRAMMING \nPage 282 \n\n\nFILE *fp; \n\nchar c; \n\nclrscr(); \n\nfp=fopen(\"file.txt\",\"r\"); \n\nwhile((c=fgetc(fp))!=EOF){ \n\nprintf(\"%c\",c); \n\n} \n\nrewind(fp);//moves the file pointer at beginning of the file \n\nwhile((c=fgetc(fp))!=EOF){ \n\nprintf(\"%c\",c); \n\n} \n\nfclose(fp); \n\ngetch(); \n\n} \n\nOutput: \n\nthis is a simple textthis is a simple text \n\nAs you can see, rewind() function moves the file pointer at beginning of the file that is why \"this \nis simple text\" is printed 2 times. If you don't call rewind() function, \"this is simple text\" will be \nprinted only once. \n\n\n\nftell() \n\nThe ftell() function returns the current file position of the specified stream. We can use ftell() \nfunction to get the total size of a file after moving file pointer at the end of file. We can use \nSEEK_END constant to move the file pointer at the end of file. \n\nsyntax: \n\nn = ftell(fp); \n\nn would give the relative offset(in bytes). \n\nC PROGRAMMING \nPage 283 \n\n\nExample: \n\n#include <stdio.h> \n\n#include <conio.h> \n\nvoid main (){ \n\nFILE *fp; \n\nint length; \n\nclrscr(); \n\nfp = fopen(\"file.txt\", \"r\"); \n\nfseek(fp, 0, SEEK_END); \n\nlength = ftell(fp); \n\nfclose(fp); \n\nprintf(\"Size of file: %d bytes\", length); \n\ngetch(); \n\n} \n\n\n\nOutput: \n\nSize of file: 21 bytes \n\nINBUILT FUNCTIONS FOR FILE HANDLING IN C LANGUAGE: \n\nFile \nhandling functions \nDescription \n\nfopen () \n\nfopen () function creates a new file or opens \nan existing file. \n\nfclose () \nfclose () function closes an opened file. \n\ngetw () \ngetw () function reads an integer from file. \n\nC PROGRAMMING \nPage 284 \n\n\nputw () \nputw () functions writes an integer to file. \n\nfgetc () \nfgetc () function reads a character from file. \n\nfputc () \nfputc () functions write a character to file. \n\ngets () \ngets () function reads line from keyboard. \n\nputs () \nputs () function writes line to o/p screen. \n\nfgets () \n\nfgets () function reads string from a file, one \nline at a time. \n\nfputs () \nfputs () function writes string to a file. \n\nfeof () \nfeof () function finds end of file. \n\nfgetchar () \n\nfgetchar () function reads a character from \nkeyboard. \n\nfprintf () \n\nfprintf () function writes formatted data to a \nfile. \n\nfscanf () \n\nfscanf () function reads formatted data from a \nfile. \n\nfputchar () \n\nfputchar () function writes a character onto \nthe output screen from keyboard input. \n\nfseek () \n\nfseek () function moves file pointer position \nto given location. \n\nSEEK_SET \n\nSEEK_SET moves file pointer position to the \nbeginning of the file. \n\nC PROGRAMMING \nPage 285 \n\n\nSEEK_CUR \n\nSEEK_CUR moves file pointer position to \ngiven location. \n\nSEEK_END \n\nSEEK_END moves file pointer position to \nthe end of file. \n\nftell () \n\nftell () function gives current position of file \npointer. \n\nrewind () \n\nrewind () function moves file pointer position \nto the beginning of the file. \n\ngetc () \ngetc () function reads character from file. \n\ngetch () \n\ngetch () function reads character from \nkeyboard. \n\ngetche () \n\ngetche () function reads character from \nkeyboard and echoes to o/p screen. \n\ngetchar () \n\ngetchar () function reads character from \nkeyboard. \n\nputc () \nputc () function writes a character to file. \n\nputchar () \n\nputchar () function writes a character to \nscreen. \n\nprintf () \n\nprintf () function writes formatted data to \nscreen. \n\nsprinf () \n\nsprinf () function writes formatted output to \nstring. \n\nscanf () \n\nscanf () function reads formatted data from \n\nC PROGRAMMING \nPage 286 \n\n\nkeyboard. \n\nsscanf () \n\nsscanf () function Reads formatted input from \na string. \n\nremove () \nremove () function deletes a file. \n\nfflush () \nfflush () function flushes a file. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 287 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 288 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 289 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC PROGRAMMING \nPage 290 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "createdAt": "2026-02-17"
}