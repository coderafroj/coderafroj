{
  "title": "Classes and methods",
  "slug": "thinkpython2-classes-and-methods",
  "description": "Module from thinkpython2.pdf: Classes and methods",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Classes and methods\n\n\n\nAlthough we are using some of Python\u2019s object-oriented features, the programs from the \nlast two chapters are not really object-oriented because they don\u2019t represent the relation- \nships between programmer-de\ufb01ned types and the functions that operate on them. The next \nstep is to transform those functions into methods that make the relationships explicit. \n\nCode examples from this chapter are available from https://thinkpython.com/code/ \nTime2.py , and solutions to the exercises are in https://thinkpython.com/code/Point2_ \nsoln.py . \n\n17.1 \nObject-oriented features \n\nPython is an object-oriented programming language , which means that it provides fea- \ntures that support object-oriented programming, which has these de\ufb01ning characteristics: \n\n\u2022 Programs include class and method de\ufb01nitions. \n\n\u2022 Most of the computation is expressed in terms of operations on objects. \n\n\u2022 Objects often represent things in the real world, and methods often correspond to the \nways things in the real world interact. \n\nFor example, the Time class de\ufb01ned in Chapter 16 corresponds to the way people record \nthe time of day, and the functions we de\ufb01ned correspond to the kinds of things people do \nwith times. Similarly, the Point and Rectangle classes in Chapter 15 correspond to the \nmathematical concepts of a point and a rectangle. \n\nSo far, we have not taken advantage of the features Python provides to support object- \noriented programming. These features are not strictly necessary; most of them provide \nalternative syntax for things we have already done. But in many cases, the alternative is \nmore concise and more accurately conveys the structure of the program. \n\nFor example, in Time1.py there is no obvious connection between the class de\ufb01nition and \nthe function de\ufb01nitions that follow. With some examination, it is apparent that every func- \ntion takes at least one Time object as an argument. \n\n162 \nChapter 17. Classes and methods \n\nThis observation is the motivation for methods ; a method is a function that is associated \nwith a particular class. We have seen methods for strings, lists, dictionaries and tuples. In \nthis chapter, we will de\ufb01ne methods for programmer-de\ufb01ned types. \n\nMethods are semantically the same as functions, but there are two syntactic differences: \n\n\u2022 Methods are de\ufb01ned inside a class de\ufb01nition in order to make the relationship be- \ntween the class and the method explicit. \n\n\u2022 The syntax for invoking a method is different from the syntax for calling a function. \n\nIn the next few sections, we will take the functions from the previous two chapters and \ntransform them into methods. This transformation is purely mechanical; you can do it by \nfollowing a sequence of steps. If you are comfortable converting from one form to another, \nyou will be able to choose the best form for whatever you are doing. \n\n17.2 \nPrinting objects \n\nIn Chapter 16, we de\ufb01ned a class named Time and in Section 16.1, you wrote a function \nnamed print_time : \n\nclass Time: \n\"\"\"Represents the time of day.\"\"\" \n\ndef print_time(time): \nprint('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)) \n\nTo call this function, you have to pass a Time object as an argument: \n\n>>> start = Time() \n>>> start.hour = 9 \n>>> start.minute = 45 \n>>> start.second = 00 \n>>> print_time(start) \n09:45:00 \n\nTo make print_time a method, all we have to do is move the function de\ufb01nition inside the \nclass de\ufb01nition. Notice the change in indentation. \n\nclass Time: \ndef print_time(time): \nprint('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)) \n\nNow there are two ways to call print_time . The \ufb01rst (and less common) way is to use \nfunction syntax: \n\n>>> Time.print_time(start) \n09:45:00 \n\nIn this use of dot notation, Time is the name of the class, and print_time is the name of the \nmethod. start is passed as a parameter. \n\nThe second (and more concise) way is to use method syntax: \n\n>>> start.print_time() \n09:45:00 \n\n17.3. Another example \n163 \n\nIn this use of dot notation, print_time is the name of the method (again), and start is \nthe object the method is invoked on, which is called the subject . Just as the subject of \na sentence is what the sentence is about, the subject of a method invocation is what the \nmethod is about. \n\nInside the method, the subject is assigned to the \ufb01rst parameter, so in this case start is \nassigned to time . \n\nBy convention, the \ufb01rst parameter of a method is called self , so it would be more common \nto write print_time like this: \n\nclass Time: \ndef print_time(self): \nprint('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)) \n\nThe reason for this convention is an implicit metaphor: \n\n\u2022 The syntax for a function call, print_time(start) , suggests that the function is the \nactive agent. It says something like, \u201cHey print_time ! Here\u2019s an object for you to \nprint.\u201d \n\n\u2022 In object-oriented programming, the objects are the active agents. A method invoca- \ntion like start.print_time() says \u201cHey start ! Please print yourself.\u201d \n\nThis change in perspective might be more polite, but it is not obvious that it is useful. In the \nexamples we have seen so far, it may not be. But sometimes shifting responsibility from the \nfunctions onto the objects makes it possible to write more versatile functions (or methods), \nand makes it easier to maintain and reuse code. \n\nAs an exercise, rewrite time_to_int (from Section 16.4) as a method. You might be tempted \nto rewrite int_to_time as a method, too, but that doesn\u2019t really make sense because there \nwould be no object to invoke it on. \n\n17.3 \nAnother example \n\nHere\u2019s a version of increment (from Section 16.3) rewritten as a method: \n\n# inside class Time: \n\ndef increment(self, seconds): \nseconds += self.time_to_int() \nreturn int_to_time(seconds) \n\nThis version assumes that time_to_int is written as a method. Also, note that it is a pure \nfunction, not a modi\ufb01er. \n\nHere\u2019s how you would invoke increment : \n\n>>> start.print_time() \n09:45:00 \n>>> end = start.increment(1337) \n>>> end.print_time() \n10:07:17 \n\n164 \nChapter 17. Classes and methods \n\nThe subject, start , gets assigned to the \ufb01rst parameter, self . The argument, 1337 , gets \nassigned to the second parameter, seconds . \n\nThis mechanism can be confusing, especially if you make an error. For example, if you \ninvoke increment with two arguments, you get: \n\n>>> end = start.increment(1337, 460) \nTypeError: increment() takes 2 positional arguments but 3 were given \n\nThe error message is initially confusing, because there are only two arguments in paren- \ntheses. But the subject is also considered an argument, so all together that\u2019s three. \n\nBy the way, a positional argument is an argument that doesn\u2019t have a parameter name; \nthat is, it is not a keyword argument. In this function call: \n\nsketch(parrot, cage, dead=True) \n\nparrot and cage are positional, and dead is a keyword argument. \n\n17.4 \nA more complicated example \n\nRewriting is_after (from Section 16.1) is slightly more complicated because it takes two \nTime objects as parameters. In this case it is conventional to name the \ufb01rst parameter self \nand the second parameter other : \n\n# inside class Time: \n\ndef is_after(self, other): \nreturn self.time_to_int() > other.time_to_int() \n\nTo use this method, you have to invoke it on one object and pass the other as an argument: \n\n>>> end.is_after(start) \nTrue \n\nOne nice thing about this syntax is that it almost reads like English: \u201cend is after start?\u201d \n\n17.5 \nThe init method \n\nThe init method (short for \u201cinitialization\u201d) is a special method that gets invoked when an \nobject is instantiated. Its full name is __init__ (two underscore characters, followed by \ninit , and then two more underscores). An init method for the Time class might look like \nthis: \n\n# inside class Time: \n\ndef __init__(self, hour=0, minute=0, second=0): \nself.hour = hour \nself.minute = minute \nself.second = second \n\nIt is common for the parameters of __init__ to have the same names as the attributes. The \nstatement \n\nself.hour = hour \n\n17.6. The __str__ method \n165 \n\nstores the value of the parameter hour as an attribute of self . \n\nThe parameters are optional, so if you call Time with no arguments, you get the default \nvalues. \n\n>>> time = Time() \n>>> time.print_time() \n00:00:00 \n\nIf you provide one argument, it overrides hour : \n\n>>> time = Time (9) \n>>> time.print_time() \n09:00:00 \n\nIf you provide two arguments, they override hour and minute . \n\n>>> time = Time(9, 45) \n>>> time.print_time() \n09:45:00 \n\nAnd if you provide three arguments, they override all three default values. \n\nAs an exercise, write an init method for the Point class that takes x and y as optional \nparameters and assigns them to the corresponding attributes. \n\n17.6 \nThe __str__ method \n\n__str__ is a special method, like __init__ , that is supposed to return a string representa- \ntion of an object. \n\nFor example, here is a str method for Time objects: \n\n# inside class Time: \n\ndef __str__(self): \nreturn '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second) \n\nWhen you print an object, Python invokes the str method: \n\n>>> time = Time(9, 45) \n>>> print(time) \n09:45:00 \n\nWhen I write a new class, I almost always start by writing __init__ , which makes it easier \nto instantiate objects, and __str__ , which is useful for debugging. \n\nAs an exercise, write a str method for the Point class. Create a Point object and print it. \n\n17.7 \nOperator overloading \n\nBy de\ufb01ning other special methods, you can specify the behavior of operators on \nprogrammer-de\ufb01ned types. For example, if you de\ufb01ne a method named __add__ for the \nTime class, you can use the + operator on Time objects. \n\nHere is what the de\ufb01nition might look like: \n\n166 \nChapter 17. Classes and methods \n\n# inside class Time: \n\ndef __add__(self, other): \nseconds = self.time_to_int() + other.time_to_int() \nreturn int_to_time(seconds) \n\nAnd here is how you could use it: \n\n>>> start = Time(9, 45) \n>>> duration = Time(1, 35) \n>>> print(start + duration) \n11:20:00 \n\nWhen you apply the + operator to Time objects, Python invokes __add__ . When you print \nthe result, Python invokes __str__ . So there is a lot happening behind the scenes! \n\nChanging the behavior of an operator so that it works with programmer-de\ufb01ned types is \ncalled operator overloading . For every operator in Python there is a corresponding spe- \ncial method, like __add__ . For more details, see http://docs.python.org/3/reference/ \ndatamodel.html#specialnames . \n\nAs an exercise, write an add method for the Point class. \n\n17.8 \nType-based dispatch \n\nIn the previous section we added two Time objects, but you also might want to add an \ninteger to a Time object. The following is a version of __add__ that checks the type of \nother and invokes either add_time or increment : \n\n# inside class Time: \n\ndef __add__(self, other): \nif isinstance(other, Time): \nreturn self.add_time(other) \nelse: \nreturn self.increment(other) \n\ndef add_time(self, other): \nseconds = self.time_to_int() + other.time_to_int() \nreturn int_to_time(seconds) \n\ndef increment(self, seconds): \nseconds += self.time_to_int() \nreturn int_to_time(seconds) \n\nThe built-in function isinstance takes a value and a class object, and returns True if the \nvalue is an instance of the class. \n\nIf other is a Time object, __add__ invokes add_time . Otherwise it assumes that the param- \neter is a number and invokes increment . This operation is called a type-based dispatch \nbecause it dispatches the computation to different methods based on the type of the argu- \nments. \n\nHere are examples that use the + operator with different types: \n\n17.9. Polymorphism \n167 \n\n>>> start = Time(9, 45) \n>>> duration = Time(1, 35) \n>>> print(start + duration) \n11:20:00 \n>>> print(start + 1337) \n10:07:17 \n\nUnfortunately, this implementation of addition is not commutative. If the integer is the \n\ufb01rst operand, you get \n\n>>> print(1337 + start) \nTypeError: unsupported operand type(s) for +: 'int' and 'instance' \n\nThe problem is, instead of asking the Time object to add an integer, Python is asking an \ninteger to add a Time object, and it doesn\u2019t know how. But there is a clever solution for this \nproblem: the special method __radd__ , which stands for \u201cright-side add\u201d. This method \nis invoked when a Time object appears on the right side of the + operator. Here\u2019s the \nde\ufb01nition: \n\n# inside class Time: \n\ndef __radd__(self, other): \nreturn self.__add__(other) \n\nAnd here\u2019s how it\u2019s used: \n\n>>> print(1337 + start) \n10:07:17 \n\nAs an exercise, write an add method for Points that works with either a Point object or a \ntuple: \n\n\u2022 If the second operand is a Point, the method should return a new Point whose x \ncoordinate is the sum of the x coordinates of the operands, and likewise for the y \ncoordinates. \n\n\u2022 If the second operand is a tuple, the method should add the \ufb01rst element of the tuple \nto the x coordinate and the second element to the y coordinate, and return a new \nPoint with the result. \n\n17.9 \nPolymorphism \n\nType-based dispatch is useful when it is necessary, but (fortunately) it is not always neces- \nsary. Often you can avoid it by writing functions that work correctly for arguments with \ndifferent types. \n\nMany of the functions we wrote for strings also work for other sequence types. For exam- \nple, in Section 11.2 we used histogram to count the number of times each letter appears in \na word. \n\ndef histogram(s): \nd = dict() \nfor c in s: \nif c not in d: \nd[c] = 1 \n\n168 \nChapter 17. Classes and methods \n\nelse: \nd[c] = d[c]+1 \nreturn d \n\nThis function also works for lists, tuples, and even dictionaries, as long as the elements of \ns are hashable, so they can be used as keys in d . \n\n>>> t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam'] \n>>> histogram(t) \n{'bacon': 1, 'egg': 1, 'spam': 4} \n\nFunctions that work with several types are called polymorphic . Polymorphism can fa- \ncilitate code reuse. For example, the built-in function sum , which adds the elements of a \nsequence, works as long as the elements of the sequence support addition. \n\nSince Time objects provide an add method, they work with sum : \n\n>>> t1 = Time(7, 43) \n>>> t2 = Time(7, 41) \n>>> t3 = Time(7, 37) \n>>> total = sum([t1, t2, t3]) \n>>> print(total) \n23:01:00 \n\nIn general, if all of the operations inside a function work with a given type, the function \nworks with that type. \n\nThe best kind of polymorphism is the unintentional kind, where you discover that a func- \ntion you already wrote can be applied to a type you never planned for. \n\n17.10 \nDebugging \n\nIt is legal to add attributes to objects at any point in the execution of a program, but if \nyou have objects with the same type that don\u2019t have the same attributes, it is easy to make \nmistakes. It is considered a good idea to initialize all of an object\u2019s attributes in the init \nmethod. \n\nIf you are not sure whether an object has a particular attribute, you can use the built-in \nfunction hasattr (see Section 15.7). \n\nAnother way to access attributes is the built-in function vars , which takes an object and \nreturns a dictionary that maps from attribute names (as strings) to their values: \n\n>>> p = Point(3, 4) \n>>> vars(p) \n{'y': 4, 'x': 3} \n\nFor purposes of debugging, you might \ufb01nd it useful to keep this function handy: \n\ndef print_attributes(obj): \nfor attr in vars(obj): \nprint(attr, getattr(obj, attr)) \n\nprint_attributes traverses the dictionary and prints each attribute name and its corre- \nsponding value. \n\nThe built-in function getattr takes an object and an attribute name (as a string) and returns \nthe attribute\u2019s value. \n\n17.11. Interface and implementation \n169 \n\n17.11 \nInterface and implementation \n\nOne of the goals of object-oriented design is to make software more maintainable, which \nmeans that you can keep the program working when other parts of the system change, and \nmodify the program to meet new requirements. \n\nA design principle that helps achieve that goal is to keep interfaces separate from imple- \nmentations. For objects, that means that the methods a class provides should not depend \non how the attributes are represented. \n\nFor example, in this chapter we developed a class that represents a time of day. Methods \nprovided by this class include time_to_int , is_after , and add_time . \n\nWe could implement those methods in several ways. The details of the implementation \ndepend on how we represent time. In this chapter, the attributes of a Time object are hour , \nminute , and second . \n\nAs an alternative, we could replace these attributes with a single integer representing the \nnumber of seconds since midnight. This implementation would make some methods, like \nis_after , easier to write, but it makes other methods harder. \n\nAfter you deploy a new class, you might discover a better implementation. If other parts \nof the program are using your class, it might be time-consuming and error-prone to change \nthe interface. \n\nBut if you designed the interface carefully, you can change the implementation without \nchanging the interface, which means that other parts of the program don\u2019t have to change. \n\n17.12 \nGlossary \n\nobject-oriented language: A language that provides features, such as programmer- \nde\ufb01ned types and methods, that facilitate object-oriented programming. \n\nobject-oriented programming: A style of programming in which data and the operations \nthat manipulate it are organized into classes and methods. \n\nmethod: A function that is de\ufb01ned inside a class de\ufb01nition and is invoked on instances of \nthat class. \n\nsubject: The object a method is invoked on. \n\npositional argument: An argument that does not include a parameter name, so it is not a \nkeyword argument. \n\noperator overloading: Changing the behavior of an operator like + so it works with a \nprogrammer-de\ufb01ned type. \n\ntype-based dispatch: A programming pattern that checks the type of an operand and in- \nvokes different functions for different types. \n\npolymorphic: Pertaining to a function that can work with more than one type. \n\n170 \nChapter 17. Classes and methods \n\n17.13 \nExercises \n\nExercise 17.1. Download the code from this chapter from https: // thinkpython. com/ code/ \nTime2. py . Change the attributes of Time to be a single integer representing seconds since mid- \nnight. Then modify the methods (and the function int_to_time ) to work with the new implemen- \ntation. You should not have to modify the test code in main . When you are done, the output should \nbe the same as before. Solution: https: // thinkpython. com/ code/ Time2_ soln. py . \nExercise 17.2. This exercise is a cautionary tale about one of the most common, and dif\ufb01cult to \n\ufb01nd, errors in Python. Write a de\ufb01nition for a class named Kangaroo with the following methods: \n\n1. An __init__ method that initializes an attribute named pouch_contents to an empty list. \n\n2. A method named put_in_pouch that takes an object of any type and adds it to \npouch_contents . \n\n3. A __str__ method that returns a string representation of the Kangaroo object and the con- \ntents of the pouch. \n\nTest your code by creating two Kangaroo objects, assigning them to variables named kanga and \nroo , and then adding roo to the contents of kanga \u2019s pouch. \n\nDownload https: // thinkpython. com/ code/ BadKangaroo. py . It contains a solution to the \nprevious problem with one big, nasty bug. Find and \ufb01x the bug. \n\nIf you get stuck, you can download https: // thinkpython. com/ code/ GoodKangaroo. py , \nwhich explains the problem and demonstrates a solution. \n\n\n## Chapter 18\n\n\n",
  "createdAt": "2026-02-17"
}