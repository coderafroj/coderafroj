{
  "title": "Classes and functions",
  "slug": "thinkpython2-classes-and-functions",
  "description": "Module from thinkpython2.pdf: Classes and functions",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Classes and functions\n\n\n\nNow that we know how to create new types, the next step is to write functions that take \nprogrammer-de\ufb01ned objects as parameters and return them as results. In this chapter I \nalso present \u201cfunctional programming style\u201d and two new program development plans. \n\nCode examples from this chapter are available from https://thinkpython.com/code/ \nTime1.py . Solutions to the exercises are at https://thinkpython.com/code/Time1_soln. \npy . \n\n16.1 \nTime \n\nAs another example of a programmer-de\ufb01ned type, we\u2019ll de\ufb01ne a class called Time that \nrecords the time of day. The class de\ufb01nition looks like this: \n\nclass Time: \n\"\"\"Represents the time of day. \n\nattributes: hour, minute, second \n\"\"\" \n\nWe can create a new Time object and assign attributes for hours, minutes, and seconds: \n\ntime = Time() \ntime.hour = 11 \ntime.minute = 59 \ntime.second = 30 \n\nThe state diagram for the Time object looks like Figure 16.1. \n\nAs an exercise, write a function called print_time that takes a Time object and prints it in \nthe form hour:minute:second . Hint: the format sequence '%.2d' prints an integer using \nat least two digits, including a leading zero if necessary. \n\nWrite a boolean function called is_after that takes two Time objects, t1 and t2 , and re- \nturns True if t1 follows t2 chronologically and False otherwise. Challenge: don\u2019t use an \nif statement. \n\n156 \nChapter 16. Classes and functions \n\n59 \n\n30 \n\nhour \n\nminute \n\nsecond \n\n11 \n\nTime \n\ntime \n\nFigure 16.1: Object diagram. \n\n16.2 \nPure functions \n\nIn the next few sections, we\u2019ll write two functions that add time values. They demonstrate \ntwo kinds of functions: pure functions and modi\ufb01ers. They also demonstrate a develop- \nment plan I\u2019ll call prototype and patch , which is a way of tackling a complex problem by \nstarting with a simple prototype and incrementally dealing with the complications. \n\nHere is a simple prototype of add_time : \n\ndef add_time(t1, t2): \nsum = Time() \nsum.hour = t1.hour + t2.hour \nsum.minute = t1.minute + t2.minute \nsum.second = t1.second + t2.second \nreturn sum \n\nThe function creates a new Time object, initializes its attributes, and returns a reference to \nthe new object. This is called a pure function because it does not modify any of the objects \npassed to it as arguments and it has no effect, like displaying a value or getting user input, \nother than returning a value. \n\nTo test this function, I\u2019ll create two Time objects: start contains the start time of a movie, \nlike Monty Python and the Holy Grail , and duration contains the run time of the movie, \nwhich is one hour 35 minutes. \n\nadd_time \ufb01gures out when the movie will be done. \n\n>>> start = Time() \n>>> start.hour = 9 \n>>> start.minute = 45 \n>>> start.second = \n0 \n\n>>> duration = Time() \n>>> duration.hour = 1 \n>>> duration.minute = 35 \n>>> duration.second = 0 \n\n>>> done = add_time(start, duration) \n>>> print_time(done) \n10:80:00 \n\nThe result, 10:80:00 might not be what you were hoping for. The problem is that this \nfunction does not deal with cases where the number of seconds or minutes adds up to \nmore than sixty. When that happens, we have to \u201ccarry\u201d the extra seconds into the minute \ncolumn or the extra minutes into the hour column. \n\nHere\u2019s an improved version: \n\n16.3. Modi\ufb01ers \n157 \n\ndef add_time(t1, t2): \nsum = Time() \nsum.hour = t1.hour + t2.hour \nsum.minute = t1.minute + t2.minute \nsum.second = t1.second + t2.second \n\nif sum.second >= 60: \nsum.second -= 60 \nsum.minute += 1 \n\nif sum.minute >= 60: \nsum.minute -= 60 \nsum.hour += 1 \n\nreturn sum \n\nAlthough this function is correct, it is starting to get big. We will see a shorter alternative \nlater. \n\n16.3 \nModi\ufb01ers \n\nSometimes it is useful for a function to modify the objects it gets as parameters. In that case, \nthe changes are visible to the caller. Functions that work this way are called modi\ufb01ers . \n\nincrement , which adds a given number of seconds to a Time object, can be written naturally \nas a modi\ufb01er. Here is a rough draft: \n\ndef increment(time, seconds): \ntime.second += seconds \n\nif time.second >= 60: \ntime.second -= 60 \ntime.minute += 1 \n\nif time.minute >= 60: \ntime.minute -= 60 \ntime.hour += 1 \n\nThe \ufb01rst line performs the basic operation; the remainder deals with the special cases we \nsaw before. \n\nIs this function correct? What happens if seconds is much greater than sixty? \n\nIn that case, it is not enough to carry once; we have to keep doing it until time.second is \nless than sixty. One solution is to replace the if statements with while statements. That \nwould make the function correct, but not very ef\ufb01cient. As an exercise, write a correct \nversion of increment that doesn\u2019t contain any loops. \n\nAnything that can be done with modi\ufb01ers can also be done with pure functions. In fact, \nsome programming languages only allow pure functions. There is some evidence that \nprograms that use pure functions are faster to develop and less error-prone than programs \nthat use modi\ufb01ers. But modi\ufb01ers are convenient at times, and functional programs tend to \nbe less ef\ufb01cient. \n\n158 \nChapter 16. Classes and functions \n\nIn general, I recommend that you write pure functions whenever it is reasonable and resort \nto modi\ufb01ers only if there is a compelling advantage. This approach might be called a \nfunctional programming style . \n\nAs an exercise, write a \u201cpure\u201d version of increment that creates and returns a new Time \nobject rather than modifying the parameter. \n\n16.4 \nPrototyping versus planning \n\nThe development plan I am demonstrating is called \u201cprototype and patch\u201d. For each func- \ntion, I wrote a prototype that performed the basic calculation and then tested it, patching \nerrors along the way. \n\nThis approach can be effective, especially if you don\u2019t yet have a deep understanding \nof the problem. \nBut incremental corrections can generate code that is unnecessarily \ncomplicated\u2014since it deals with many special cases\u2014and unreliable\u2014since it is hard to \nknow if you have found all the errors. \n\nAn alternative is designed development , in which high-level insight into the problem can \nmake the programming much easier. In this case, the insight is that a Time object is really \na three-digit number in base 60 (see http://en.wikipedia.org/wiki/Sexagesimal ). The \nsecond attribute is the \u201cones column\u201d, the minute attribute is the \u201csixties column\u201d, and the \nhour attribute is the \u201cthirty-six hundreds column\u201d. \n\nWhen we wrote add_time and increment , we were effectively doing addition in base 60, \nwhich is why we had to carry from one column to the next. \n\nThis observation suggests another approach to the whole problem\u2014we can convert Time \nobjects to integers and take advantage of the fact that the computer knows how to do \ninteger arithmetic. \n\nHere is a function that converts Times to integers: \n\ndef time_to_int(time): \nminutes = time.hour * 60 + time.minute \nseconds = minutes * 60 + time.second \nreturn seconds \n\nAnd here is a function that converts an integer to a Time (recall that divmod divides the \ufb01rst \nargument by the second and returns the quotient and remainder as a tuple). \n\ndef int_to_time(seconds): \ntime = Time() \nminutes, time.second = divmod(seconds, 60) \ntime.hour, time.minute = divmod(minutes, 60) \nreturn time \n\nYou might have to think a bit, and run some tests, to convince yourself that these functions \nare correct. One way to test them is to check that time_to_int(int_to_time(x)) == x for \nmany values of x . This is an example of a consistency check. \n\nOnce you are convinced they are correct, you can use them to rewrite add_time : \n\ndef add_time(t1, t2): \nseconds = time_to_int(t1) + time_to_int(t2) \nreturn int_to_time(seconds) \n\n16.5. Debugging \n159 \n\nThis version is shorter than the original, and easier to verify. \nAs an exercise, rewrite \nincrement using time_to_int and int_to_time . \n\nIn some ways, converting from base 60 to base 10 and back is harder than just dealing with \ntimes. Base conversion is more abstract; our intuition for dealing with time values is better. \n\nBut if we have the insight to treat times as base 60 numbers and make the investment of \nwriting the conversion functions ( time_to_int and int_to_time ), we get a program that \nis shorter, easier to read and debug, and more reliable. \n\nIt is also easier to add features later. For example, imagine subtracting two Times to \ufb01nd \nthe duration between them. The naive approach would be to implement subtraction with \nborrowing. Using the conversion functions would be easier and more likely to be correct. \n\nIronically, sometimes making a problem harder (or more general) makes it easier (because \nthere are fewer special cases and fewer opportunities for error). \n\n16.5 \nDebugging \n\nA Time object is well-formed if the values of minute and second are between 0 and 60 \n(including 0 but not 60) and if hour is positive. hour and minute should be integer values, \nbut we might allow second to have a fraction part. \n\nRequirements like these are called invariants because they should always be true. To put \nit a different way, if they are not true, something has gone wrong. \n\nWriting code to check invariants can help detect errors and \ufb01nd their causes. For example, \nyou might have a function like valid_time that takes a Time object and returns False if it \nviolates an invariant: \n\ndef valid_time(time): \nif time.hour < 0 or time.minute < 0 or time.second < 0: \nreturn False \nif time.minute >= 60 or time.second >= 60: \nreturn False \nreturn True \n\nAt the beginning of each function you could check the arguments to make sure they are \nvalid: \n\ndef add_time(t1, t2): \nif not valid_time(t1) or not valid_time(t2): \nraise ValueError('invalid Time object in add_time') \nseconds = time_to_int(t1) + time_to_int(t2) \nreturn int_to_time(seconds) \n\nOr you could use an assert statement , which checks a given invariant and raises an excep- \ntion if it fails: \n\ndef add_time(t1, t2): \nassert valid_time(t1) and valid_time(t2) \nseconds = time_to_int(t1) + time_to_int(t2) \nreturn int_to_time(seconds) \n\nassert statements are useful because they distinguish code that deals with normal condi- \ntions from code that checks for errors. \n\n160 \nChapter 16. Classes and functions \n\n16.6 \nGlossary \n\nprototype and patch: A development plan that involves writing a rough draft of a pro- \ngram, testing, and correcting errors as they are found. \n\ndesigned development: A development plan that involves high-level insight into the \nproblem and more planning than incremental development or prototype develop- \nment. \n\npure function: A function that does not modify any of the objects it receives as arguments. \nMost pure functions are fruitful. \n\nmodi\ufb01er: A function that changes one or more of the objects it receives as arguments. Most \nmodi\ufb01ers are void; that is, they return None . \n\nfunctional programming style: A style of program design in which the majority of func- \ntions are pure. \n\ninvariant: A condition that should always be true during the execution of a program. \n\nassert statement: A statement that checks a condition and raises an exception if it fails. \n\n16.7 \nExercises \n\nCode examples from this chapter are available from https://thinkpython.com/code/ \nTime1.py ; solutions to the exercises are available from https://thinkpython.com/code/ \nTime1_soln.py . \nExercise 16.1. Write a function called mul_time that takes a Time object and a number and returns \na new Time object that contains the product of the original Time and the number. \n\nThen use mul_time to write a function that takes a Time object that represents the \ufb01nishing time \nin a race, and a number that represents the distance, and returns a Time object that represents the \naverage pace (time per mile). \nExercise 16.2. The datetime module provides time objects that are similar to the Time objects \nin this chapter, but they provide a rich set of methods and operators. Read the documentation at \nhttp: // docs. python. org/ 3/ library/ datetime. html . \n\n1. Use the datetime module to write a program that gets the current date and prints the day of \nthe week. \n\n2. Write a program that takes a birthday as input and prints the user\u2019s age and the number of \ndays, hours, minutes and seconds until their next birthday. \n\n3. For two people born on different days, there is a day when one is twice as old as the other. \nThat\u2019s their Double Day. Write a program that takes two birth dates and computes their \nDouble Day. \n\n4. For a little more challenge, write the more general version that computes the day when one \nperson is n times older than the other. \n\nSolution: https: // thinkpython. com/ code/ double. py \n\n\n## Chapter 17\n\n\n",
  "createdAt": "2026-02-17"
}