{
  "title": "Classes and objects",
  "slug": "thinkpython2-classes-and-objects",
  "description": "Module from thinkpython2.pdf: Classes and objects",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Classes and objects\n\n\n\nAt this point you know how to use functions to organize code and built-in types to organize \ndata. The next step is to learn \u201cobject-oriented programming\u201d, which uses programmer- \nde\ufb01ned types to organize both code and data. Object-oriented programming is a big topic; \nit will take a few chapters to get there. \n\nCode examples from this chapter are available from https://thinkpython.com/code/ \nPoint1.py ; solutions to the exercises are available from https://thinkpython.com/code/ \nPoint1_soln.py . \n\n15.1 \nProgrammer-de\ufb01ned types \n\nWe have used many of Python\u2019s built-in types; now we are going to de\ufb01ne a new type. As \nan example, we will create a type called Point that represents a point in two-dimensional \nspace. \n\nIn mathematical notation, points are often written in parentheses with a comma separating \nthe coordinates. For example, ( 0, 0 ) represents the origin, and ( x , y ) represents the point x \nunits to the right and y units up from the origin. \n\nThere are several ways we might represent points in Python: \n\n\u2022 We could store the coordinates separately in two variables, x and y . \n\n\u2022 We could store the coordinates as elements in a list or tuple. \n\n\u2022 We could create a new type to represent points as objects. \n\nCreating a new type is more complicated than the other options, but it has advantages that \nwill be apparent soon. \n\nA programmer-de\ufb01ned type is also called a class . A class de\ufb01nition looks like this: \n\nclass Point: \n\"\"\"Represents a point in 2-D space.\"\"\" \n\n148 \nChapter 15. Classes and objects \n\nx \n\ny \n\n3.0 \n\n4.0 \n\nblank \nPoint \n\nFigure 15.1: Object diagram. \n\nThe header indicates that the new class is called Point . The body is a docstring that ex- \nplains what the class is for. You can de\ufb01ne variables and methods inside a class de\ufb01nition, \nbut we will get back to that later. \n\nDe\ufb01ning a class named Point creates a class object . \n\n>>> Point \n<class '__main__.Point'> \n\nBecause Point is de\ufb01ned at the top level, its \u201cfull name\u201d is __main__.Point . \n\nThe class object is like a factory for creating objects. To create a Point, you call Point as if it \nwere a function. \n\n>>> blank = Point() \n>>> blank \n<__main__.Point object at 0xb7e9d3ac> \n\nThe return value is a reference to a Point object, which we assign to blank . \n\nCreating a new object is called instantiation , and the object is an instance of the class. \n\nWhen you print an instance, Python tells you what class it belongs to and where it is stored \nin memory (the pre\ufb01x 0x means that the following number is in hexadecimal). \n\nEvery object is an instance of some class, so \u201cobject\u201d and \u201cinstance\u201d are interchangeable. \nBut in this chapter I use \u201cinstance\u201d to indicate that I am talking about a programmer- \nde\ufb01ned type. \n\n15.2 \nAttributes \n\nYou can assign values to an instance using dot notation: \n\n>>> blank.x = 3.0 \n>>> blank.y = 4.0 \n\nThis syntax is similar to the syntax for selecting a variable from a module, such as math.pi \nor string.whitespace . In this case, though, we are assigning values to named elements of \nan object. These elements are called attributes . \n\nAs a noun, \u201cAT-trib-ute\u201d is pronounced with emphasis on the \ufb01rst syllable, as opposed to \n\u201ca-TRIB-ute\u201d, which is a verb. \n\nFigure 15.1 is a state diagram that shows the result of these assignments. A state diagram \nthat shows an object and its attributes is called an object diagram . \n\nThe variable blank refers to a Point object, which contains two attributes. Each attribute \nrefers to a \ufb02oating-point number. \n\nYou can read the value of an attribute using the same syntax: \n\n15.3. Rectangles \n149 \n\n>>> blank.y \n4.0 \n>>> x = blank.x \n>>> x \n3.0 \n\nThe expression blank.x means, \u201cGo to the object blank refers to and get the value of x .\u201d In \nthe example, we assign that value to a variable named x . There is no con\ufb02ict between the \nvariable x and the attribute x . \n\nYou can use dot notation as part of any expression. For example: \n\n>>> '(%g, %g)' % (blank.x, blank.y) \n'(3.0, 4.0)' \n>>> distance = math.sqrt(blank.x**2 + blank.y**2) \n>>> distance \n5.0 \n\nYou can pass an instance as an argument in the usual way. For example: \n\ndef print_point(p): \nprint('(%g, %g)' % (p.x, p.y)) \n\nprint_point takes a point as an argument and displays it in mathematical notation. To \ninvoke it, you can pass blank as an argument: \n\n>>> print_point(blank) \n(3.0, 4.0) \n\nInside the function, p is an alias for blank , so if the function modi\ufb01es p , blank changes. \n\nAs an exercise, write a function called distance_between_points that takes two Points as \narguments and returns the distance between them. \n\n15.3 \nRectangles \n\nSometimes it is obvious what the attributes of an object should be, but other times you have \nto make decisions. For example, imagine you are designing a class to represent rectangles. \nWhat attributes would you use to specify the location and size of a rectangle? You can ig- \nnore angle; to keep things simple, assume that the rectangle is either vertical or horizontal. \n\nThere are at least two possibilities: \n\n\u2022 You could specify one corner of the rectangle (or the center), the width, and the \nheight. \n\n\u2022 You could specify two opposing corners. \n\nAt this point it is hard to say whether either is better than the other, so we\u2019ll implement the \n\ufb01rst one, just as an example. \n\nHere is the class de\ufb01nition: \n\n150 \nChapter 15. Classes and objects \n\ny \n\n0.0 \nx \n\n0.0 \n\nwidth \n100.0 \n\ncorner \n\n200.0 \nPoint \n\nRectangle \n\nbox \n\nheight \n\nFigure 15.2: Object diagram. \n\nclass Rectangle: \n\"\"\"Represents a rectangle. \n\nattributes: width, height, corner. \n\"\"\" \n\nThe docstring lists the attributes: width and height are numbers; corner is a Point object \nthat speci\ufb01es the lower-left corner. \n\nTo represent a rectangle, you have to instantiate a Rectangle object and assign values to the \nattributes: \n\nbox = Rectangle() \nbox.width = 100.0 \nbox.height = 200.0 \nbox.corner = Point() \nbox.corner.x = 0.0 \nbox.corner.y = 0.0 \n\nThe expression box.corner.x means, \u201cGo to the object box refers to and select the attribute \nnamed corner ; then go to that object and select the attribute named x .\u201d \n\nFigure 15.2 shows the state of this object. An object that is an attribute of another object is \nembedded . \n\n15.4 \nInstances as return values \n\nFunctions can return instances. For example, find_center takes a Rectangle as an argu- \nment and returns a Point that contains the coordinates of the center of the Rectangle : \n\ndef find_center(rect): \np = Point() \np.x = rect.corner.x + rect.width/2 \np.y = rect.corner.y + rect.height/2 \nreturn p \n\nHere is an example that passes box as an argument and assigns the resulting Point to \ncenter : \n\n>>> center = find_center(box) \n>>> print_point(center) \n(50, 100) \n\n15.5. Objects are mutable \n151 \n\n15.5 \nObjects are mutable \n\nYou can change the state of an object by making an assignment to one of its attributes. For \nexample, to change the size of a rectangle without changing its position, you can modify \nthe values of width and height : \n\nbox.width = box.width + 50 \nbox.height = box.height + 100 \n\nYou can also write functions that modify objects. For example, grow_rectangle takes a \nRectangle object and two numbers, dwidth and dheight , and adds the numbers to the \nwidth and height of the rectangle: \n\ndef grow_rectangle(rect, dwidth, dheight): \nrect.width += dwidth \nrect.height += dheight \n\nHere is an example that demonstrates the effect: \n\n>>> box.width, box.height \n(150.0, 300.0) \n>>> grow_rectangle(box, 50, 100) \n>>> box.width, box.height \n(200.0, 400.0) \n\nInside the function, rect is an alias for box , so when the function modi\ufb01es rect , box \nchanges. \n\nAs an exercise, write a function named move_rectangle that takes a Rectangle and two \nnumbers named dx and dy . It should change the location of the rectangle by adding dx to \nthe x coordinate of corner and adding dy to the y coordinate of corner . \n\n15.6 \nCopying \n\nAliasing can make a program dif\ufb01cult to read because changes in one place might have \nunexpected effects in another place. It is hard to keep track of all the variables that might \nrefer to a given object. \n\nCopying an object is often an alternative to aliasing. The copy module contains a function \ncalled copy that can duplicate any object: \n\n>>> p1 = Point() \n>>> p1.x = 3.0 \n>>> p1.y = 4.0 \n\n>>> import copy \n>>> p2 = copy.copy(p1) \n\np1 and p2 contain the same data, but they are not the same Point. \n\n>>> print_point(p1) \n(3, 4) \n>>> print_point(p2) \n(3, 4) \n>>> p1 is p2 \nFalse \n\n152 \nChapter 15. Classes and objects \n\ny \n\n0.0 \nx \n\n0.0 \n\nwidth \n\nheight \n\n100.0 \n\ncorner \n\n200.0 \n\nbox \n100.0 \n\n200.0 \n\nwidth \n\nheight \n\ncorner \n\nbox2 \n\nFigure 15.3: Object diagram. \n\n>>> p1 == p2 \nFalse \n\nThe is operator indicates that p1 and p2 are not the same object, which is what we ex- \npected. But you might have expected == to yield True because these points contain the \nsame data. In that case, you will be disappointed to learn that for instances, the default \nbehavior of the == operator is the same as the is operator; it checks object identity, not \nobject equivalence. That\u2019s because for programmer-de\ufb01ned types, Python doesn\u2019t know \nwhat should be considered equivalent. At least, not yet. \n\nIf you use copy.copy to duplicate a Rectangle, you will \ufb01nd that it copies the Rectangle \nobject but not the embedded Point. \n\n>>> box2 = copy.copy(box) \n>>> box2 is box \nFalse \n>>> box2.corner is box.corner \nTrue \n\nFigure 15.3 shows what the object diagram looks like. \nThis operation is called a shallow \ncopy because it copies the object and any references it contains, but not the embedded \nobjects. \n\nFor most applications, \nthis is not what you want. \nIn this example, \ninvoking \ngrow_rectangle on one of the Rectangles would not affect the other, but invoking \nmove_rectangle on either would affect both! This behavior is confusing and error-prone. \n\nFortunately, the copy module provides a method named deepcopy that copies not only the \nobject but also the objects it refers to, and the objects they refer to, and so on. You will not \nbe surprised to learn that this operation is called a deep copy . \n\n>>> box3 = copy.deepcopy(box) \n>>> box3 is box \nFalse \n>>> box3.corner is box.corner \nFalse \n\nbox3 and box are completely separate objects. \n\nAs an exercise, write a version of move_rectangle that creates and returns a new Rectangle \ninstead of modifying the old one. \n\n15.7 \nDebugging \n\nWhen you start working with objects, you are likely to encounter some new exceptions. If \nyou try to access an attribute that doesn\u2019t exist, you get an AttributeError : \n\n15.8. Glossary \n153 \n\n>>> p = Point() \n>>> p.x = 3 \n>>> p.y = 4 \n>>> p.z \nAttributeError: Point instance has no attribute 'z' \nIf you are not sure what type an object is, you can ask: \n>>> type(p) \n<class '__main__.Point'> \nYou can also use isinstance to check whether an object is an instance of a class: \n>>> isinstance(p, Point) \nTrue \nIf you are not sure whether an object has a particular attribute, you can use the built-in \nfunction hasattr : \n>>> hasattr(p, 'x') \nTrue \n>>> hasattr(p, 'z') \nFalse \nThe \ufb01rst argument can be any object; the second argument is a string that contains the name \nof the attribute. \n\nYou can also use a try statement to see if the object has the attributes you need: \ntry: \nx = p.x \nexcept AttributeError: \nx = 0 \nThis approach can make it easier to write functions that work with different types; more \non that topic is coming up in Section 17.9. \n\n15.8 \nGlossary \n\nclass: A programmer-de\ufb01ned type. A class de\ufb01nition creates a new class object. \n\nclass object: An object that contains information about a programmer-de\ufb01ned type. The \nclass object can be used to create instances of the type. \n\ninstance: An object that belongs to a class. \n\ninstantiate: To create a new object. \n\nattribute: One of the named values associated with an object. \n\nembedded object: An object that is stored as an attribute of another object. \n\nshallow copy: To copy the contents of an object, including any references to embedded \nobjects; implemented by the copy function in the copy module. \n\ndeep copy: To copy the contents of an object as well as any embedded objects, and any \nobjects embedded in them, and so on; implemented by the deepcopy function in the \ncopy module. \n\nobject diagram: A diagram that shows objects, their attributes, and the values of the at- \ntributes. \n\n154 \nChapter 15. Classes and objects \n\n15.9 \nExercises \n\nExercise 15.1. Write a de\ufb01nition for a class named Circle with attributes center and radius , \nwhere center is a Point object and radius is a number. \n\nInstantiate a Circle object that represents a circle with its center at ( 150, 100 ) and radius 75. \n\nWrite a function named point_in_circle that takes a Circle and a Point and returns True if the \nPoint lies in or on the boundary of the circle. \n\nWrite a function named rect_in_circle that takes a Circle and a Rectangle and returns True if \nthe Rectangle lies entirely in or on the boundary of the circle. \n\nWrite a function named rect_circle_overlap that takes a Circle and a Rectangle and returns \nTrue if any of the corners of the Rectangle fall inside the Circle. Or as a more challenging version, \nreturn True if any part of the Rectangle falls inside the Circle. \n\nSolution: https: // thinkpython. com/ code/ Circle. py . \nExercise 15.2. Write a function called draw_rect that takes a Turtle object and a Rectangle and \nuses the Turtle to draw the Rectangle. See Chapter 4 for examples using Turtle objects. \n\nWrite a function called draw_circle that takes a Turtle and a Circle and draws the Circle. \n\nSolution: https: // thinkpython. com/ code/ draw. py . \n\n\n## Chapter 16\n\n\n",
  "createdAt": "2026-02-17"
}