{
  "title": "Inheritance",
  "slug": "thinkpython2-inheritance",
  "description": "Module from thinkpython2.pdf: Inheritance",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Inheritance\n\n\n\nThe language feature most often associated with object-oriented programming is inheri- \ntance . Inheritance is the ability to de\ufb01ne a new class that is a modi\ufb01ed version of an ex- \nisting class. In this chapter I demonstrate inheritance using classes that represent playing \ncards, decks of cards, and poker hands. \n\nIf you don\u2019t play poker, you can read about it at http://en.wikipedia.org/wiki/Poker , \nbut you don\u2019t have to; I\u2019ll tell you what you need to know for the exercises. \n\nCode examples from this chapter are available from https://thinkpython.com/code/ \nCard.py . \n\n18.1 \nCard objects \n\nThere are \ufb01fty-two cards in a deck, each of which belongs to one of four suits and one of \nthirteen ranks. The suits are Spades, Hearts, Diamonds, and Clubs (in descending order in \nbridge). The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King. Depending on \nthe game that you are playing, an Ace may be higher than King or lower than 2. \n\nIf we want to de\ufb01ne a new object to represent a playing card, it is obvious what the at- \ntributes should be: rank and suit . It is not as obvious what type the attributes should be. \nOne possibility is to use strings containing words like 'Spade' for suits and 'Queen' for \nranks. One problem with this implementation is that it would not be easy to compare cards \nto see which had a higher rank or suit. \n\nAn alternative is to use integers to encode the ranks and suits. In this context, \u201cencode\u201d \nmeans that we are going to de\ufb01ne a mapping between numbers and suits, or between \nnumbers and ranks. This kind of encoding is not meant to be a secret (that would be \n\u201cencryption\u201d). \n\nFor example, this table shows the suits and the corresponding integer codes: \n\nSpades \n7\u2192 \n3 \nHearts \n7\u2192 \n2 \nDiamonds \n7\u2192 \n1 \nClubs \n7\u2192 \n0 \n\n172 \nChapter 18. Inheritance \n\nThis code makes it easy to compare cards; because higher suits map to higher numbers, we \ncan compare suits by comparing their codes. \n\nThe mapping for ranks is fairly obvious; each of the numerical ranks maps to the corre- \nsponding integer, and for face cards: \n\nJack \n7\u2192 \n11 \nQueen \n7\u2192 \n12 \nKing \n7\u2192 \n13 \n\nI am using the 7\u2192 symbol to make it clear that these mappings are not part of the Python \nprogram. They are part of the program design, but they don\u2019t appear explicitly in the code. \n\nThe class de\ufb01nition for Card looks like this: \n\nclass Card: \n\"\"\"Represents a standard playing card.\"\"\" \n\ndef __init__(self, suit=0, rank=2): \nself.suit = suit \nself.rank = rank \n\nAs usual, the init method takes an optional parameter for each attribute. The default card \nis the 2 of Clubs. \n\nTo create a Card, you call Card with the suit and rank of the card you want. \n\nqueen_of_diamonds = Card(1, 12) \n\n18.2 \nClass attributes \n\nIn order to print Card objects in a way that people can easily read, we need a mapping \nfrom the integer codes to the corresponding ranks and suits. A natural way to do that is \nwith lists of strings. We assign these lists to class attributes : \n\n# inside class Card: \n\nsuit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] \nrank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7', \n'8', '9', '10', 'Jack', 'Queen', 'King'] \n\ndef __str__(self): \nreturn '%s of %s' % (Card.rank_names[self.rank], \nCard.suit_names[self.suit]) \n\nVariables like suit_names and rank_names , which are de\ufb01ned inside a class but outside \nof any method, are called class attributes because they are associated with the class object \nCard . \n\nThis term distinguishes them from variables like suit and rank , which are called instance \nattributes because they are associated with a particular instance. \n\nBoth kinds of attribute are accessed using dot notation. For example, in __str__ , self \nis a Card object, and self.rank is its rank. \nSimilarly, Card is a class object, and \nCard.rank_names is a list of strings associated with the class. \n\n18.3. Comparing cards \n173 \n\nlist \n\nsuit_names \n\nlist \n\nrank_names \n\nCard \n\ntype \n\n1 \n\n11 \n\nsuit \n\nrank \n\ncard1 \n\nCard \n\nFigure 18.1: Object diagram. \n\nEvery card has its own suit and rank , but there is only one copy of suit_names and \nrank_names . \n\nPutting it all together, the expression Card.rank_names[self.rank] means \u201cuse the at- \ntribute rank from the object self as an index into the list rank_names from the class Card , \nand select the appropriate string.\u201d \n\nThe \ufb01rst element of rank_names is None because there is no card with rank zero. By includ- \ning None as a place-keeper, we get a mapping with the nice property that the index 2 maps \nto the string '2' , and so on. To avoid this tweak, we could have used a dictionary instead \nof a list. \n\nWith the methods we have so far, we can create and print cards: \n\n>>> card1 = Card(2, 11) \n>>> print(card1) \nJack of Hearts \n\nFigure 18.1 is a diagram of the Card class object and one Card instance. Card is a class \nobject; its type is type . card1 is an instance of Card , so its type is Card . To save space, I \ndidn\u2019t draw the contents of suit_names and rank_names . \n\n18.3 \nComparing cards \n\nFor built-in types, there are relational operators ( < , > , == , etc.) that compare values and de- \ntermine when one is greater than, less than, or equal to another. For programmer-de\ufb01ned \ntypes, we can override the behavior of the built-in operators by providing a method named \n__lt__ , which stands for \u201cless than\u201d. \n\n__lt__ takes two parameters, self and other , and returns True if self is strictly less than \nother . \n\nThe correct ordering for cards is not obvious. For example, which is better, the 3 of Clubs \nor the 2 of Diamonds? One has a higher rank, but the other has a higher suit. In order to \ncompare cards, you have to decide whether rank or suit is more important. \n\nThe answer might depend on what game you are playing, but to keep things simple, we\u2019ll \nmake the arbitrary choice that suit is more important, so all of the Spades outrank all of the \nDiamonds, and so on. \n\n174 \nChapter 18. Inheritance \n\nWith that decided, we can write __lt__ : \n\n# inside class Card: \n\ndef __lt__(self, other): \n# check the suits \nif self.suit < other.suit: return True \nif self.suit > other.suit: return False \n\n# suits are the same... check ranks \nreturn self.rank < other.rank \n\nYou can write this more concisely using tuple comparison: \n\n# inside class Card: \n\ndef __lt__(self, other): \nt1 = self.suit, self.rank \nt2 = other.suit, other.rank \nreturn t1 < t2 \n\nAs an exercise, write an __lt__ method for Time objects. You can use tuple comparison, \nbut you also might consider comparing integers. \n\n18.4 \nDecks \n\nNow that we have Cards, the next step is to de\ufb01ne Decks. Since a deck is made up of cards, \nit is natural for each Deck to contain a list of cards as an attribute. \n\nThe following is a class de\ufb01nition for Deck . The init method creates the attribute cards and \ngenerates the standard set of \ufb01fty-two cards: \n\nclass Deck: \n\ndef __init__(self): \nself.cards = [] \nfor suit in range(4): \nfor rank in range(1, 14): \ncard = Card(suit, rank) \nself.cards.append(card) \n\nThe easiest way to populate the deck is with a nested loop. The outer loop enumerates the \nsuits from 0 to 3. The inner loop enumerates the ranks from 1 to 13. Each iteration creates \na new Card with the current suit and rank, and appends it to self.cards . \n\n18.5 \nPrinting the deck \n\nHere is a __str__ method for Deck : \n\n# inside class Deck: \n\ndef __str__(self): \nres = [] \n\n18.6. Add, remove, shuf\ufb02e and sort \n175 \n\nfor card in self.cards: \nres.append(str(card)) \nreturn '\\n'.join(res) \n\nThis method demonstrates an ef\ufb01cient way to accumulate a large string: building a list \nof strings and then using the string method join . The built-in function str invokes the \n__str__ method on each card and returns the string representation. \n\nSince we invoke join on a newline character, the cards are separated by newlines. Here\u2019s \nwhat the result looks like: \n\n>>> deck = Deck() \n>>> print(deck) \nAce of Clubs \n2 of Clubs \n3 of Clubs \n... \n10 of Spades \nJack of Spades \nQueen of Spades \nKing of Spades \n\nEven though the result appears on 52 lines, it is one long string that contains newlines. \n\n18.6 \nAdd, remove, shuf\ufb02e and sort \n\nTo deal cards, we would like a method that removes a card from the deck and returns it. \nThe list method pop provides a convenient way to do that: \n\n# inside class Deck: \n\ndef pop_card(self): \nreturn self.cards.pop() \n\nSince pop removes the last card in the list, we are dealing from the bottom of the deck. \n\nTo add a card, we can use the list method append : \n\n# inside class Deck: \n\ndef add_card(self, card): \nself.cards.append(card) \n\nA method like this that uses another method without doing much work is sometimes called \na veneer . The metaphor comes from woodworking, where a veneer is a thin layer of good \nquality wood glued to the surface of a cheaper piece of wood to improve the appearance. \n\nIn this case add_card is a \u201cthin\u201d method that expresses a list operation in terms appropriate \nfor decks. It improves the appearance, or interface, of the implementation. \n\nAs another example, we can write a Deck method named shuffle using the function \nshuffle from the random module: \n\n# inside class Deck: \n\ndef shuffle(self): \nrandom.shuffle(self.cards) \n\n176 \nChapter 18. Inheritance \n\nDon\u2019t forget to import random . \n\nAs an exercise, write a Deck method named sort that uses the list method sort to sort the \ncards in a Deck . sort uses the __lt__ method we de\ufb01ned to determine the order. \n\n18.7 \nInheritance \n\nInheritance is the ability to de\ufb01ne a new class that is a modi\ufb01ed version of an existing class. \nAs an example, let\u2019s say we want a class to represent a \u201chand\u201d, that is, the cards held by \none player. A hand is similar to a deck: both are made up of a collection of cards, and both \nrequire operations like adding and removing cards. \n\nA hand is also different from a deck; there are operations we want for hands that don\u2019t \nmake sense for a deck. For example, in poker we might compare two hands to see which \none wins. In bridge, we might compute a score for a hand in order to make a bid. \n\nThis relationship between classes\u2014similar, but different\u2014lends itself to inheritance. To \nde\ufb01ne a new class that inherits from an existing class, you put the name of the existing \nclass in parentheses: \n\nclass Hand(Deck): \n\"\"\"Represents a hand of playing cards.\"\"\" \n\nThis de\ufb01nition indicates that Hand inherits from Deck ; that means we can use methods like \npop_card and add_card for Hands as well as Decks. \n\nWhen a new class inherits from an existing one, the existing one is called the parent and \nthe new class is called the child . \n\nIn this example, Hand inherits __init__ from Deck , but it doesn\u2019t really do what we want: \ninstead of populating the hand with 52 new cards, the init method for Hands should ini- \ntialize cards with an empty list. \n\nIf we provide an init method in the Hand class, it overrides the one in the Deck class: \n\n# inside class Hand: \n\ndef __init__(self, label=''): \nself.cards = [] \nself.label = label \n\nWhen you create a Hand, Python invokes this init method, not the one in Deck . \n\n>>> hand = Hand('new hand') \n>>> hand.cards \n[] \n>>> hand.label \n'new hand' \n\nThe other methods are inherited from Deck , so we can use pop_card and add_card to deal \na card: \n\n>>> deck = Deck() \n>>> card = deck.pop_card() \n>>> hand.add_card(card) \n>>> print(hand) \nKing of Spades \n\n18.8. Class diagrams \n177 \n\nA natural next step is to encapsulate this code in a method called move_cards : \n\n# inside class Deck: \n\ndef move_cards(self, hand, num): \nfor i in range(num): \nhand.add_card(self.pop_card()) \n\nmove_cards takes two arguments, a Hand object and the number of cards to deal. It modi- \n\ufb01es both self and hand , and returns None . \n\nIn some games, cards are moved from one hand to another, or from a hand back to the \ndeck. You can use move_cards for any of these operations: self can be either a Deck or a \nHand, and hand , despite the name, can also be a Deck . \n\nInheritance is a useful feature. Some programs that would be repetitive without inheritance \ncan be written more elegantly with it. Inheritance can facilitate code reuse, since you can \ncustomize the behavior of parent classes without having to modify them. In some cases, \nthe inheritance structure re\ufb02ects the natural structure of the problem, which makes the \ndesign easier to understand. \n\nOn the other hand, inheritance can make programs dif\ufb01cult to read. When a method is \ninvoked, it is sometimes not clear where to \ufb01nd its de\ufb01nition. The relevant code may be \nspread across several modules. Also, many of the things that can be done using inheritance \ncan be done as well or better without it. \n\n18.8 \nClass diagrams \n\nSo far we have seen stack diagrams, which show the state of a program, and object dia- \ngrams, which show the attributes of an object and their values. These diagrams represent \na snapshot in the execution of a program, so they change as the program runs. \n\nThey are also highly detailed; for some purposes, too detailed. A class diagram is a more \nabstract representation of the structure of a program. Instead of showing individual ob- \njects, it shows classes and the relationships between them. \n\nThere are several kinds of relationship between classes: \n\n\u2022 Objects in one class might contain references to objects in another class. For example, \neach Rectangle contains a reference to a Point, and each Deck contains references to \nmany Cards. This kind of relationship is called HAS-A , as in, \u201ca Rectangle has a \nPoint.\u201d \n\n\u2022 One class might inherit from another. This relationship is called IS-A , as in, \u201ca Hand \nis a kind of a Deck.\u201d \n\n\u2022 One class might depend on another in the sense that objects in one class take ob- \njects in the second class as parameters, or use objects in the second class as part of a \ncomputation. This kind of relationship is called a dependency . \n\nA class diagram is a graphical representation of these relationships. For example, Fig- \nure 18.2 shows the relationships between Card , Deck and Hand . \n\n178 \nChapter 18. Inheritance \n\nHand \n\nDeck \n* \nCard \n\nFigure 18.2: Class diagram. \n\nThe arrow with a hollow triangle head represents an IS-A relationship; in this case it indi- \ncates that Hand inherits from Deck. \n\nThe standard arrow head represents a HAS-A relationship; in this case a Deck has refer- \nences to Card objects. \n\nThe star ( * ) near the arrow head is a multiplicity ; it indicates how many Cards a Deck has. \nA multiplicity can be a simple number, like 52 , a range, like 5..7 or a star, which indicates \nthat a Deck can have any number of Cards. \n\nThere are no dependencies in this diagram. They would normally be shown with a dashed \narrow. Or if there are a lot of dependencies, they are sometimes omitted. \n\nA more detailed diagram might show that a Deck actually contains a list of Cards, but \nbuilt-in types like list and dict are usually not included in class diagrams. \n\n18.9 \nDebugging \n\nInheritance can make debugging dif\ufb01cult because when you invoke a method on an object, \nit might be hard to \ufb01gure out which method will be invoked. \n\nSuppose you are writing a function that works with Hand objects. You would like it to \nwork with all kinds of Hands, like PokerHands, BridgeHands, etc. If you invoke a method \nlike shuffle , you might get the one de\ufb01ned in Deck , but if any of the subclasses override \nthis method, you\u2019ll get that version instead. This behavior is usually a good thing, but it \ncan be confusing. \n\nAny time you are unsure about the \ufb02ow of execution through your program, the sim- \nplest solution is to add print statements at the beginning of the relevant methods. \nIf \nDeck.shuffle prints a message that says something like Running Deck.shuffle , then as \nthe program runs it traces the \ufb02ow of execution. \n\nAs an alternative, you could use this function, which takes an object and a method name \n(as a string) and returns the class that provides the de\ufb01nition of the method: \n\ndef find_defining_class(obj, meth_name): \nfor ty in type(obj).mro(): \nif meth_name in ty.__dict__: \nreturn ty \n\nHere\u2019s an example: \n\n>>> hand = Hand() \n>>> find_defining_class(hand, 'shuffle') \n<class '__main__.Deck'> \n\n18.10. Data encapsulation \n179 \n\nSo the shuffle method for this Hand is the one in Deck . \n\nfind_defining_class uses the mro method to get the list of class objects (types) that will be \nsearched for methods. \u201cMRO\u201d stands for \u201cmethod resolution order\u201d, which is the sequence \nof classes Python searches to \u201cresolve\u201d a method name. \n\nHere\u2019s a design suggestion: when you override a method, the interface of the new method \nshould be the same as the old. It should take the same parameters, return the same type, \nand obey the same preconditions and postconditions. If you follow this rule, you will \ufb01nd \nthat any function designed to work with an instance of a parent class, like a Deck, will also \nwork with instances of child classes like a Hand and PokerHand. \n\nIf you violate this rule, which is called the \u201cLiskov substitution principle\u201d, your code will \ncollapse like (sorry) a house of cards. \n\n18.10 \nData encapsulation \n\nThe previous chapters demonstrate a development plan we might call \u201cobject-oriented \ndesign\u201d. We identi\ufb01ed objects we needed\u2014like Point , Rectangle and Time \u2014and de\ufb01ned \nclasses to represent them. In each case there is an obvious correspondence between the \nobject and some entity in the real world (or at least a mathematical world). \n\nBut sometimes it is less obvious what objects you need and how they should interact. In \nthat case you need a different development plan. In the same way that we discovered \nfunction interfaces by encapsulation and generalization, we can discover class interfaces \nby data encapsulation . \n\nMarkov analysis, from Section 13.8, provides a good example. \nIf you download my \ncode from https://thinkpython.com/code/markov.py , you\u2019ll see that it uses two global \nvariables\u2014 suffix_map and prefix \u2014that are read and written from several functions. \n\nsuffix_map = {} \nprefix = () \n\nBecause these variables are global, we can only run one analysis at a time. If we read two \ntexts, their pre\ufb01xes and suf\ufb01xes would be added to the same data structures (which makes \nfor some interesting generated text). \n\nTo run multiple analyses, and keep them separate, we can encapsulate the state of each \nanalysis in an object. Here\u2019s what that looks like: \n\nclass Markov: \n\ndef __init__(self): \nself.suffix_map = {} \nself.prefix = () \n\nNext, we transform the functions into methods. For example, here\u2019s process_word : \n\ndef process_word(self, word, order=2): \nif len(self.prefix) < order: \nself.prefix += (word,) \nreturn \n\n180 \nChapter 18. Inheritance \n\ntry: \nself.suffix_map[self.prefix].append(word) \nexcept KeyError: \n# if there is no entry for this prefix, make one \nself.suffix_map[self.prefix] = [word] \n\nself.prefix = shift(self.prefix, word) \n\nTransforming a program like this\u2014changing the design without changing the behavior\u2014is \nanother example of refactoring (see Section 4.7). \n\nThis example suggests a development plan for designing objects and methods: \n\n1. Start by writing functions that read and write global variables (when necessary). \n\n2. Once you get the program working, look for associations between global variables \nand the functions that use them. \n\n3. Encapsulate related variables as attributes of an object. \n\n4. Transform the associated functions into methods of the new class. \n\nAs an exercise, download my Markov code from https://thinkpython.com/code/ \nmarkov.py , and follow the steps described above to encapsulate the global variables \nas attributes of a new class called Markov . Solution: https://thinkpython.com/code/ \nmarkov2.py . \n\n18.11 \nGlossary \n\nencode: To represent one set of values using another set of values by constructing a map- \nping between them. \n\nclass attribute: An attribute associated with a class object. Class attributes are de\ufb01ned \ninside a class de\ufb01nition but outside any method. \n\ninstance attribute: An attribute associated with an instance of a class. \n\nveneer: A method or function that provides a different interface to another function with- \nout doing much computation. \n\ninheritance: The ability to de\ufb01ne a new class that is a modi\ufb01ed version of a previously \nde\ufb01ned class. \n\nparent class: The class from which a child class inherits. \n\nchild class: A new class created by inheriting from an existing class; also called a \u201csub- \nclass\u201d. \n\nIS-A relationship: A relationship between a child class and its parent class. \n\nHAS-A relationship: A relationship between two classes where instances of one class con- \ntain references to instances of the other. \n\ndependency: A relationship between two classes where instances of one class use in- \nstances of the other class, but do not store them as attributes. \n\n18.12. Exercises \n181 \n\nclass diagram: A diagram that shows the classes in a program and the relationships be- \ntween them. \n\nmultiplicity: A notation in a class diagram that shows, for a HAS-A relationship, how \nmany references there are to instances of another class. \n\ndata encapsulation: A program development plan that involves a prototype using global \nvariables and a \ufb01nal version that makes the global variables into instance attributes. \n\n18.12 \nExercises \n\nExercise 18.1. For the following program, draw a UML class diagram that shows these classes and \nthe relationships among them. \n\nclass PingPongParent: \npass \n\nclass Ping(PingPongParent): \ndef __init__(self, pong): \nself.pong = pong \n\nclass Pong(PingPongParent): \ndef __init__(self, pings=None): \nif pings is None: \nself.pings = [] \nelse: \nself.pings = pings \n\ndef add_ping(self, ping): \nself.pings.append(ping) \n\npong = Pong() \nping = Ping(pong) \npong.add_ping(ping) \nExercise 18.2. Write a Deck method called deal_hands that takes two parameters, the number of \nhands and the number of cards per hand. It should create the appropriate number of Hand objects, \ndeal the appropriate number of cards per hand, and return a list of Hands. \nExercise 18.3. The following are the possible hands in poker, in increasing order of value and \ndecreasing order of probability: \n\npair: two cards with the same rank \n\ntwo pair: two pairs of cards with the same rank \n\nthree of a kind: three cards with the same rank \n\nstraight: \ufb01ve cards with ranks in sequence (aces can be high or low, so Ace-2-3-4-5 is a straight \nand so is 10-Jack-Queen-King-Ace , but Queen-King-Ace-2-3 is not.) \n\n\ufb02ush: \ufb01ve cards with the same suit \n\nfull house: three cards with one rank, two cards with another \n\n182 \nChapter 18. Inheritance \n\nfour of a kind: four cards with the same rank \n\nstraight \ufb02ush: \ufb01ve cards in sequence (as de\ufb01ned above) and with the same suit \n\nThe goal of these exercises is to estimate the probability of drawing these various hands. \n\n1. Download the following \ufb01les from https: // thinkpython. com/ code : \n\nCard.py : A complete version of the Card , Deck and Hand classes in this chapter. \n\nPokerHand.py : An incomplete implementation of a class that represents a poker hand, and \nsome code that tests it. \n\n2. If you run PokerHand.py , it deals seven 7-card poker hands and checks to see if any of them \ncontains a \ufb02ush. Read this code carefully before you go on. \n\n3. Add methods to PokerHand.py named has_pair , has_twopair , etc. that return True or \nFalse according to whether or not the hand meets the relevant criteria. Your code should \nwork correctly for \u201chands\u201d that contain any number of cards (although 5 and 7 are the most \ncommon sizes). \n\n4. Write a method named classify that \ufb01gures out the highest-value classi\ufb01cation for a hand \nand sets the label attribute accordingly. For example, a 7-card hand might contain a \ufb02ush \nand a pair; it should be labeled \u201c\ufb02ush\u201d. \n\n5. When you are convinced that your classi\ufb01cation methods are working, the next step is to esti- \nmate the probabilities of the various hands. Write a function in PokerHand.py that shuf\ufb02es \na deck of cards, divides it into hands, classi\ufb01es the hands, and counts the number of times \nvarious classi\ufb01cations appear. \n\n6. Print a table of the classi\ufb01cations and their probabilities. Run your program with larger and \nlarger numbers of hands until the output values converge to a reasonable degree of accu- \nracy. Compare your results to the values at http: // en. wikipedia. org/ wiki/ Hand_ \nrankings . \n\nSolution: https: // thinkpython. com/ code/ PokerHandSoln. py . \n\n\n## Chapter 19\n\n\n",
  "createdAt": "2026-02-17"
}