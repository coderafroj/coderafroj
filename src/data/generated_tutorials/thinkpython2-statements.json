{
  "title": "statements",
  "slug": "thinkpython2-statements",
  "description": "Module from thinkpython2.pdf: statements",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# statements\n\n\n\nOne of the most powerful features of a programming language is the ability to manipulate \nvariables . A variable is a name that refers to a value. \n\n2.1 \nAssignment statements \n\nAn assignment statement creates a new variable and gives it a value: \n>>> message = 'And now for something completely different' \n>>> n = 17 \n>>> pi = 3.1415926535897932 \nThis example makes three assignments. The \ufb01rst assigns a string to a new variable named \nmessage ; the second gives the integer 17 to n ; the third assigns the (approximate) value of \n\u03c0 to pi . \n\nA common way to represent variables on paper is to write the name with an arrow pointing \nto its value. This kind of \ufb01gure is called a state diagram because it shows what state each \nof the variables is in (think of it as the variable\u2019s state of mind). Figure 2.1 shows the result \nof the previous example. \n\n2.2 \nVariable names \n\nProgrammers generally choose names for their variables that are meaningful\u2014they docu- \nment what the variable is used for. \n\nmessage \n\nn \n\npi \n\n17 \n\n\u2019And now for something completely different\u2019 \n\n3.1415926535897932 \n\nFigure 2.1: State diagram. \n\n10 \nChapter 2. Variables, expressions and statements \n\nVariable names can be as long as you like. They can contain both letters and numbers, but \nthey can\u2019t begin with a number. It is legal to use uppercase letters, but it is conventional to \nuse only lower case for variables names. \n\nThe underscore character, _ , can appear in a name. It is often used in names with multiple \nwords, such as your_name or airspeed_of_unladen_swallow . \n\nIf you give a variable an illegal name, you get a syntax error: \n\n>>> 76trombones = 'big parade' \nSyntaxError: invalid syntax \n>>> more@ = 1000000 \nSyntaxError: invalid syntax \n>>> class = 'Advanced Theoretical Zymurgy' \nSyntaxError: invalid syntax \n\n76trombones is illegal because it begins with a number. more@ is illegal because it contains \nan illegal character, @ . But what\u2019s wrong with class ? \n\nIt turns out that class is one of Python\u2019s keywords . The interpreter uses keywords to \nrecognize the structure of the program, and they cannot be used as variable names. \n\nPython 3 has these keywords: \n\nFalse \nclass \nfinally \nis \nreturn \nNone \ncontinue \nfor \nlambda \ntry \nTrue \ndef \nfrom \nnonlocal \nwhile \nand \ndel \nglobal \nnot \nwith \nas \nelif \nif \nor \nyield \nassert \nelse \nimport \npass \nbreak \nexcept \nin \nraise \n\nYou don\u2019t have to memorize this list. In most development environments, keywords are \ndisplayed in a different color; if you try to use one as a variable name, you\u2019ll know. \n\n2.3 \nExpressions and statements \n\nAn expression is a combination of values, variables, and operators. A value all by itself is \nconsidered an expression, and so is a variable, so the following are all legal expressions: \n\n>>> 42 \n42 \n>>> n \n17 \n>>> n + 25 \n42 \n\nWhen you type an expression at the prompt, the interpreter evaluates it, which means that \nit \ufb01nds the value of the expression. In this example, n has the value 17 and n + 25 has the \nvalue 42. \n\nA statement is a unit of code that has an effect, like creating a variable or displaying a \nvalue. \n\n>>> n = 17 \n>>> print(n) \n\n2.4. Script mode \n11 \n\nThe \ufb01rst line is an assignment statement that gives a value to n . The second line is a print \nstatement that displays the value of n . \n\nWhen you type a statement, the interpreter executes it, which means that it does whatever \nthe statement says. In general, statements don\u2019t have values. \n\n2.4 \nScript mode \n\nSo far we have run Python in interactive mode , which means that you interact directly \nwith the interpreter. Interactive mode is a good way to get started, but if you are working \nwith more than a few lines of code, it can be clumsy. \n\nThe alternative is to save code in a \ufb01le called a script and then run the interpreter in script \nmode to execute the script. By convention, Python scripts have names that end with .py . \n\nIf you know how to create and run a script on your computer, you are ready to go. Oth- \nerwise I recommend using PythonAnywhere again. I have posted instructions for running \nin script mode at http://tinyurl.com/thinkpython2e . \n\nBecause Python provides both modes, you can test bits of code in interactive mode before \nyou put them in a script. But there are differences between interactive mode and script \nmode that can be confusing. \n\nFor example, if you are using Python as a calculator, you might type \n\n>>> miles = 26.2 \n>>> miles * 1.61 \n42.182 \n\nThe \ufb01rst line assigns a value to miles , but it has no visible effect. The second line is an ex- \npression, so the interpreter evaluates it and displays the result. It turns out that a marathon \nis about 42 kilometers. \n\nBut if you type the same code into a script and run it, you get no output at all. In script \nmode an expression, all by itself, has no visible effect. Python evaluates the expression, but \nit doesn\u2019t display the result. To display the result, you need a print statement like this: \n\nmiles = 26.2 \nprint(miles * 1.61) \n\nThis behavior can be confusing at \ufb01rst. To check your understanding, type the following \nstatements in the Python interpreter and see what they do: \n\n5 \nx = 5 \nx + 1 \n\nNow put the same statements in a script and run it. What is the output? Modify the script \nby transforming each expression into a print statement and then run it again. \n\n2.5 \nOrder of operations \n\nWhen an expression contains more than one operator, the order of evaluation depends \non the order of operations . For mathematical operators, Python follows mathematical \nconvention. The acronym PEMDAS is a useful way to remember the rules: \n\n12 \nChapter 2. Variables, expressions and statements \n\n\u2022 P arentheses have the highest precedence and can be used to force an expression to \nevaluate in the order you want. Since expressions in parentheses are evaluated \ufb01rst, \n2 * (3-1) is 4, and (1+1)**(5-2) is 8. You can also use parentheses to make an \nexpression easier to read, as in (minute * 100) / 60 , even if it doesn\u2019t change the \nresult. \n\n\u2022 E xponentiation has the next highest precedence, so 1 + 2**3 is 9, not 27, and 2 * \n3**2 is 18, not 36. \n\n\u2022 M ultiplication and D ivision have higher precedence than A ddition and S ubtraction. \nSo 2*3-1 is 5, not 4, and 6+4/2 is 8, not 5. \n\n\u2022 Operators with the same precedence are evaluated from left to right (except exponen- \ntiation). So in the expression degrees / 2 * pi , the division happens \ufb01rst and the \nresult is multiplied by pi . To divide by 2 \u03c0 , you can use parentheses or write degrees \n/ 2 / pi . \n\nI don\u2019t work very hard to remember the precedence of operators. If I can\u2019t tell by looking \nat the expression, I use parentheses to make it obvious. \n\n2.6 \nString operations \n\nIn general, you can\u2019t perform mathematical operations on strings, even if the strings look \nlike numbers, so the following are illegal: \n\n'chinese'-'food' \n'eggs'/'easy' \n'third'*'a charm' \n\nBut there are two exceptions, + and * . \n\nThe + operator performs string concatenation , which means it joins the strings by linking \nthem end-to-end. For example: \n\n>>> first = 'throat' \n>>> second = 'warbler' \n>>> first + second \nthroatwarbler \n\nThe * operator also works on strings; it performs repetition. For example, 'Spam'*3 is \n'SpamSpamSpam' . If one of the values is a string, the other has to be an integer. \n\nThis use of + and * makes sense by analogy with addition and multiplication. Just as 4*3 \nis equivalent to 4+4+4 , we expect 'Spam'*3 to be the same as 'Spam'+'Spam'+'Spam' , and \nit is. On the other hand, there is a signi\ufb01cant way in which string concatenation and repe- \ntition are different from integer addition and multiplication. Can you think of a property \nthat addition has that string concatenation does not? \n\n2.7 \nComments \n\nAs programs get bigger and more complicated, they get more dif\ufb01cult to read. Formal \nlanguages are dense, and it is often dif\ufb01cult to look at a piece of code and \ufb01gure out what \nit is doing, or why. \n\n2.8. Debugging \n13 \n\nFor this reason, it is a good idea to add notes to your programs to explain in natural lan- \nguage what the program is doing. These notes are called comments , and they start with \nthe # symbol: \n# compute the percentage of the hour that has elapsed \npercentage = (minute * 100) / 60 \nIn this case, the comment appears on a line by itself. You can also put comments at the end \nof a line: \npercentage = (minute * 100) / 60 \n# percentage of an hour \nEverything from the # to the end of the line is ignored\u2014it has no effect on the execution of \nthe program. \n\nComments are most useful when they document non-obvious features of the code. It is \nreasonable to assume that the reader can \ufb01gure out what the code does; it is more useful to \nexplain why . \n\nThis comment is redundant with the code and useless: \nv = 5 \n# assign 5 to v \nThis comment contains useful information that is not in the code: \nv = 5 \n# velocity in meters/second. \nGood variable names can reduce the need for comments, but long names can make com- \nplex expressions hard to read, so there is a tradeoff. \n\n2.8 \nDebugging \n\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and semantic \nerrors. It is useful to distinguish between them in order to track them down more quickly. \n\nSyntax error: \u201cSyntax\u201d refers to the structure of a program and the rules about that struc- \nture. For example, parentheses have to come in matching pairs, so (1 + 2) is legal, \nbut 8) is a syntax error . \n\nIf there is a syntax error anywhere in your program, Python displays an error mes- \nsage and quits, and you will not be able to run the program. During the \ufb01rst few \nweeks of your programming career, you might spend a lot of time tracking down \nsyntax errors. As you gain experience, you will make fewer errors and \ufb01nd them \nfaster. \n\nRuntime error: The second type of error is a runtime error, so called because the error does \nnot appear until after the program has started running. These errors are also called \nexceptions because they usually indicate that something exceptional (and bad) has \nhappened. \n\nRuntime errors are rare in the simple programs you will see in the \ufb01rst few chapters, \nso it might be a while before you encounter one. \n\nSemantic error: The third type of error is \u201csemantic\u201d, which means related to meaning. \nIf there is a semantic error in your program, it will run without generating error \nmessages, but it will not do the right thing. It will do something else. Speci\ufb01cally, it \nwill do what you told it to do. \n\nIdentifying semantic errors can be tricky because it requires you to work backward \nby looking at the output of the program and trying to \ufb01gure out what it is doing. \n\n14 \nChapter 2. Variables, expressions and statements \n\n2.9 \nGlossary \n\nvariable: A name that refers to a value. \n\nassignment: A statement that assigns a value to a variable. \n\nstate diagram: A graphical representation of a set of variables and the values they refer to. \n\nkeyword: A reserved word that is used to parse a program; you cannot use keywords like \nif , def , and while as variable names. \n\noperand: One of the values on which an operator operates. \n\nexpression: A combination of variables, operators, and values that represents a single re- \nsult. \n\nevaluate: To simplify an expression by performing the operations in order to yield a single \nvalue. \n\nstatement: A section of code that represents a command or action. So far, the statements \nwe have seen are assignments and print statements. \n\nexecute: To run a statement and do what it says. \n\ninteractive mode: A way of using the Python interpreter by typing code at the prompt. \n\nscript mode: A way of using the Python interpreter to read code from a script and run it. \n\nscript: A program stored in a \ufb01le. \n\norder of operations: Rules governing the order in which expressions involving multiple \noperators and operands are evaluated. \n\nconcatenate: To join two operands end-to-end. \n\ncomment: Information in a program that is meant for other programmers (or anyone read- \ning the source code) and has no effect on the execution of the program. \n\nsyntax error: An error in a program that makes it impossible to parse (and therefore im- \npossible to interpret). \n\nexception: An error that is detected while the program is running. \n\nsemantics: The meaning of a program. \n\nsemantic error: An error in a program that makes it do something other than what the \nprogrammer intended. \n\n2.10 \nExercises \n\nExercise 2.1. Repeating my advice from the previous chapter, whenever you learn a new feature, \nyou should try it out in interactive mode and make errors on purpose to see what goes wrong. \n\n\u2022 We\u2019ve seen that n = 42 is legal. What about 42 = n ? \n\n2.10. Exercises \n15 \n\n\u2022 How about x = y = 1 ? \n\n\u2022 In some languages every statement ends with a semi-colon, ; . What happens if you put a \nsemi-colon at the end of a Python statement? \n\n\u2022 What if you put a period at the end of a statement? \n\n\u2022 In math notation you can multiply x and y like this: xy. What happens if you try that in \nPython? \n\nExercise 2.2. Practice using the Python interpreter as a calculator: \n\n1. The volume of a sphere with radius r is 4 \n\n3 \u03c0 r 3 . What is the volume of a sphere with radius 5? \n\n2. Suppose the cover price of a book is $24.95, but bookstores get a 40% discount. Shipping costs \n$3 for the \ufb01rst copy and 75 cents for each additional copy. What is the total wholesale cost for \n60 copies? \n\n3. If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15 per mile), then 3 miles at \ntempo (7:12 per mile) and 1 mile at easy pace again, what time do I get home for breakfast? \n\n16 \nChapter 2. Variables, expressions and statements \n\n\n## Chapter 3\n\n\n",
  "createdAt": "2026-02-17"
}