{
  "title": "iot",
  "slug": "iot",
  "description": "Notes from iot.pdf",
  "tags": [
    "iot",
    "Premium"
  ],
  "content": "\n![Image](/src/assets/generated_images/iot_p0_i0.png)\n\nInternet of Things \n\n\n## Internet of Things\n\n\nArchitectures, Protocols and Standards \n\nSimone Cirani Caligoo Inc., Chicago, IL, USA \n\nGianluigi Ferrari Department of Engineering and Architecture University of Parma, Parma (PR), Italy \n\nMarco Picone Caligoo Inc., Chicago, IL, USA \n\nLuca Veltri Department of Engineering and Architecture University of Parma, Parma (PR), Italy \n\nThis edition \ufb01rst published 2019 \u00a9 2019 John Wiley & Sons Ltd \n\nAll rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means, electronic, mechanical, photocopying, recording or otherwise, except as permitted by law. Advice on how to obtain permission to reuse material from this title is available at http://www.wiley.com/go/permissions. \n\nThe rights of Simone Cirani, Gianluigi Ferrari, Marco Picone and Luca Veltri to be identi\ufb01ed as the authors of this work has been asserted in accordance with law. \n\nRegistered O\ufb03ces John Wiley & Sons, Inc., 111 River Street, Hoboken, NJ 07030, USA John Wiley & Sons Ltd, The Atrium, Southern Gate, Chichester, West Sussex, PO19 8SQ, UK \n\nEditorial O\ufb03ce The Atrium, Southern Gate, Chichester, West Sussex, PO19 8SQ, UK \n\nFor details of our global editorial o\ufb03ces, customer services, and more information about Wiley products visit us at www.wiley.com. \n\nWiley also publishes its books in a variety of electronic formats and by print-on-demand. Some content that appears in standard print versions of this book may not be available in other formats. \n\nLimit of Liability/Disclaimer of Warranty While the publisher and authors have used their best e\ufb00orts in preparing this work, they make no representations or warranties with respect to the accuracy or completeness of the contents of this work and speci\ufb01cally disclaim all warranties, including without limitation any implied warranties of merchantability or \ufb01tness for a particular purpose. No warranty may be created or extended by sales representatives, written sales materials or promotional statements for this work. The fact that an organization, website, or product is referred to in this work as a citation and/or potential source of further information does not mean that the publisher and authors endorse the information or services the organization, website, or product may provide or recommendations it may make. This work is sold with the understanding that the publisher is not engaged in rendering professional services. The advice and strategies contained herein may not be suitable for your situation. You should consult with a specialist where appropriate. Further, readers should be aware that websites listed in this work may have changed or disappeared between when this work was written and when it is read. Neither the publisher nor authors shall be liable for any loss of pro\ufb01t or any other commercial damages, including but not limited to special, incidental, consequential, or other damages. \n\nLibrary of Congress Cataloging-in-Publication Data \n\nNames: Cirani, Simone, 1982- author. | Ferrari, Gianluigi, 1974- author. | Picone, Marco, 1984- author. | Veltri, Luca, author. Title: Internet of things : architectures, protocols and standards / Simone Cirani, Taneto, Gattatico (RE), Italy, Ph.D., Gianluigi Ferrari, Ph.D., Marco Picone, Gattatico (RE), Italy Ph.D., Luca Veltri, Ph.D., Parma (PR), Italy. Description: First edition. | Hoboken, NJ : Wiley, 2019. | Identi\ufb01ers: LCCN 2018021870 (print) | LCCN 2018028978 (ebook) | ISBN 9781119359685 (Adobe PDF) | ISBN 9781119359708 (ePub) | ISBN 9781119359678 (hardcover) Subjects: LCSH: Internet of things. Classi\ufb01cation: LCC TK5105.8857 (ebook) | LCC TK5105.8857 .C55 2019 (print) | DDC 004.67/8\u2013dc23 LC record available at https://lccn.loc.gov/2018021870 \n\nCover design by Wiley Cover image: \u00a9 shulz/iStockphoto \n\nSet in 10/12pt WarnockPro by SPi Global, Chennai, India \n\n10 9 8 7 6 5 4 3 2 1 \n\n\u201cMachines take me by surprise with great frequency.\u201d (Alan Mathison Turing) \n\nI would like to dedicate this work: To Paola, the love of my life, my hero, my strength. You are what I live for. To my wonderful mom and dad. You have always supported me. You gave me everything. You taught me the value of work and commitment. You gifted me with your love. You are always in my heart and thoughts. To my fantastic sisters, who have always been an example. You believed in me and blessed me with your love, joy, and laughs. To my grandma, you will always have a special place in my heart. You are an incredible inspiration. I miss you. To Jonas, who has taught me the passion for knowledge, exploration, and science. To Emil and Emma, I wish you all the best. I am proud of you. I will never say thanks enough. I love you all. Thanks to Marco, Gianluigi, and Luca, I am really proud and honored to have worked and researched with you. I am so proud of what we have achieved in these years. Finally, thanks to all my colleagues, old and new, who contributed to make this book happen in one way or another. Simone Cirani \n\nTo the women of my life, Anna, So\ufb01a, and Viola: You \ufb01ll my heart and brighten my days. Gianluigi Ferrari \n\nTo Eleonora and my parents, Antonio and Marina, who are always by my side in every choice and decision. A special thanks to all the people who worked with us, supported our vision, and shared the challenges during these years. Marco Picone \n\nTo my family. Luca Veltri \n\nvii \n\nContents \n\nPreface xv \n\n1 Preliminaries, Motivation, and Related Work 1 1.1 What is the Internet of Things? 1 1.2 Wireless Ad-hoc and Sensor Networks: The Ancestors without IP 2 1.3 IoT-enabled Applications 3 1.3.1 Home and Building Automation 3 1.3.2 Smart Cities 4 1.3.3 Smart Grids 4 1.3.4 Industrial IoT 5 1.3.5 Smart Farming 7 \n\n2 Standards 9 2.1 \u201cTraditional\u201d Internet Review 9 2.1.1 Physical/Link Layer 10 2.1.1.1 IEEE 802.3 (Ethernet) 11 2.1.1.2 IEEE 802.11 12 2.1.2 Network Layer 14 2.1.2.1 IPv6 and IPv4 14 2.1.3 Transport Layer 17 2.1.3.1 TCP and UDP 19 2.1.4 Application Layer 21 2.1.4.1 HTTP 21 2.1.4.2 AMQP 22 2.1.4.3 SIP 23 2.2 The Internet of Things 25 \n\nviii Contents \n\n2.2.1 Designing the Architecture of an IP-based Internet of Things 26 2.2.2 Physical/Link Layer 28 2.2.2.1 IEEE 802.15.4 and ZigBee 28 2.2.2.2 Low-power Wi-Fi 30 2.2.2.3 Bluetooth and BLE 31 2.2.2.4 Powerline Communications 32 2.2.3 Network Layer 33 2.2.3.1 The 6LoWPAN Adaptation Layer 34 2.2.4 Transport Layer 34 2.2.5 Application Layer 34 2.2.5.1 CoAP 35 2.2.5.2 CoSIP Protocol Speci\ufb01cation 60 2.3 The Industrial IoT 76 \n\n3 Interoperability 79 3.1 Applications in the IoT 79 3.2 The Verticals: Cloud-based Solutions 80 3.3 REST Architectures: The Web of Things 81 3.3.1 REST: The Web as a Platform 82 3.3.1.1 Resource-oriented Architectures 83 3.3.1.2 REST Architectures 84 3.3.1.3 Representation of Resources 84 3.3.1.4 Resource Identi\ufb01ers 85 3.3.1.5 Statelessness 86 3.3.1.6 Applications as Finite-state Machines 86 3.3.1.7 Hypermedia as the Engine of Application State 86 3.3.2 Richardson Maturity Model 88 3.3.2.1 Level 0: the Swamp of POX 88 3.3.2.2 Level 1: Resources 90 3.3.2.3 Level 2: HTTP Verbs 90 3.3.2.4 Level 3: Hypermedia 95 3.3.2.5 The Meaning of the Levels 97 3.4 The Web of Things 97 3.5 Messaging Queues and Publish/Subscribe Communications 98 3.5.1 Advantages of the Pub/Sub Model 99 3.5.2 Disadvantages of the Pub/Sub Model 100 3.5.3 Message Queue Telemetry Transport 100 3.5.3.1 MQTT versus AMQP 101 \n\nContents ix \n\n3.6 Session Initiation for the IoT 102 3.6.1 Motivations 102 3.6.2 Lightweight Sessions in the IoT 104 3.6.2.1 A Protocol for Constrained Session Initiation 106 3.6.2.2 Session Initiation 106 3.6.2.3 Session Tear-down 108 3.6.2.4 Session Modi\ufb01cation 108 3.7 Performance Evaluation 109 3.7.1 Implementation 109 3.7.2 Experimental Results 111 3.7.3 Conclusions 114 3.8 Optimized Communications: the Dual-network Management Protocol 115 3.8.1 DNMP Motivations 115 3.8.2 Related Work 117 3.8.3 The DNMP Protocol 118 3.8.4 Implementation with IEEE 802.15.4 and IEEE 802.11s 123 3.8.4.1 LPLT Networking 123 3.8.4.2 HPHT Networking 123 3.8.4.3 Node Integration 124 3.8.5 Performance Evaluation 125 3.8.5.1 Experimental Setup 125 3.8.5.2 Operational Limitations of IEEE 802.15.4 126 3.8.6 IEEE 802.15.4-controlled Selective Activation of the IEEE 802.11s Network 129 3.8.7 Conclusions 130 3.9 Discoverability in Constrained Environments 131 3.9.1 CoRE Link Format 131 3.9.1.1 CoRE Link Format: Discovery 132 3.9.1.2 Link Format 133 3.9.1.3 The Interface Description Attribute 135 3.9.2 CoRE Interfaces 135 3.9.2.1 Sensor 136 3.9.2.2 Parameter 137 3.9.2.3 Read-only Parameter 137 3.9.2.4 Actuator 137 3.10 Data Formats: Media Types for Sensor Markup Language 138 3.10.1 JSON Representations 141 3.10.1.1 Single Datapoint 141 \n\nx Contents \n\n3.10.1.2 Multiple Datapoints 142 3.10.1.3 Multiple Measurements 142 \n\n4 Discoverability 145 4.1 Service and Resource Discovery 145 4.2 Local and Large-scale Service Discovery 146 4.2.1 ZeroConf 151 4.2.2 UPnP 152 4.2.3 URI Beacons and the Physical Web 152 4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 154 4.3.1 IoT Gateway 156 4.3.1.1 Proxy Functionality 156 4.3.1.2 Service and Resource Discovery 158 4.3.2 A P2P-based Large-scale Service Discovery Architecture 159 4.3.2.1 Distributed Location Service 160 4.3.2.2 Distributed Geographic Table 161 4.3.2.3 An Architecture for Large-scale Service Discovery based on Peer-to-peer Technologies 162 4.3.3 Zeroconf-based Local Service Discovery for Constrained Environments 167 4.3.3.1 Architecture 167 4.3.3.2 Service Discovery Protocol 168 4.3.4 Implementation Results 170 4.3.4.1 Local Service Discovery 171 4.3.4.2 Large-scale Service Discovery 175 4.4 Lightweight Service Discovery in Low-power IoT Networks 178 4.4.1 E\ufb03cient Forwarding Protocol for Service Discovery 180 4.4.1.1 Multicast through Local Filtered Flooding 181 4.4.2 E\ufb03cient Multiple Unicast Forwarding 183 4.5 Implementation Results 185 \n\n5 Security and Privacy in the IoT 191 5.1 Security Issues in the IoT 192 5.2 Security Mechanisms Overview 196 5.2.1 Traditional vs Lightweight security 196 5.2.1.1 Network Layer 197 5.2.1.2 Transport Layer 199 \n\nContents xi \n\n5.2.1.3 Application Layer 201 5.2.2 Lightweight Cryptography 202 5.2.2.1 Symmetric-key LWC Algorithms 203 5.2.2.2 Public-key (Asymmetric) LWC Algorithms 206 5.2.2.3 Lightweight Cryptographic Hash Functions 210 5.2.2.4 Homomorphic Encryption Schemes 213 5.2.3 Key Agreement, Distribution, and Security Bootstrapping 214 5.2.3.1 Key Agreement Protocols 215 5.2.3.2 Shared Group-key Distribution 215 5.2.3.3 Security Bootstrapping 216 5.2.4 Processing Data in the Encrypted Domain: Secure Data Aggregation 217 5.2.5 Authorization Mechanisms for Secure IoT Services 219 5.3 Privacy Issues in the IoT 222 5.3.1 The Role of Authorization 222 5.3.2 IoT-OAS: Delegation-based Authorization for the Internet of Things 227 5.3.2.1 Architecture 227 5.3.2.2 Granting Access Tokens 229 5.3.2.3 Authorizing Requests 231 5.3.2.4 SP-to-IoT-OAS Communication: Protocol Details 231 5.3.2.5 Con\ufb01guration 232 5.3.3 IoT-OAS Application Scenarios 232 5.3.3.1 Network Broker Communication 233 5.3.3.2 Gateway-based Communication 235 5.3.3.3 End-to-End CoAP Communication 235 5.3.3.4 Hybrid Gateway-based Communication 235 \n\n6 Cloud and Fog Computing for the IoT 237 6.1 Cloud Computing 237 6.2 Big Data Processing Pattern 238 6.3 Big Stream 239 6.3.1 Big-stream-oriented Architecture 243 6.3.2 Graph-based Processing 247 6.3.3 Implementation 251 6.3.3.1 Acquisition Module 251 6.3.3.2 Normalization Module 253 6.3.3.3 Graph Framework 254 6.3.3.4 Application Register Module 255 \n\nxii Contents \n\n6.3.4 Performance Evaluation 257 6.3.5 Solutions and Security Considerations 262 6.4 Big Stream and Security 263 6.4.1 Graph-based Cloud System Security 266 6.4.2 Normalization after a Secure Stream Acquisition with OFS Module 268 6.4.3 Enhancing the Application Register with the IGS Module 269 6.4.4 Securing Streams inside Graph Nodes 273 6.4.5 Evaluation of a Secure Big Stream Architecture 277 6.5 Fog Computing and the IoT 281 6.6 The Role of the IoT Hub 283 6.6.1 Virtualization and Replication 285 6.6.1.1 The IoT Hub 285 6.6.1.2 Operational Scenarios 287 6.6.1.3 Synchronization Protocol 290 \n\n7 The IoT in Practice 303 7.1 Hardware for the IoT 303 7.1.1 Classes of Constrained Devices 305 7.1.2 Hardware Platforms 307 7.1.2.1 TelosB 307 7.1.2.2 Zolertia Z1 307 7.1.2.3 OpenMote 310 7.1.2.4 Arduino 313 7.1.2.5 Intel Galileo 315 7.1.2.6 Raspberry Pi 318 7.2 Software for the IoT 321 7.2.1 OpenWSN 321 7.2.2 TinyOS 322 7.2.3 FreeRTOS 323 7.2.4 TI-RTOS 323 7.2.5 RIOT 324 7.2.6 Contiki OS 325 7.2.6.1 Networking 325 7.2.6.2 Low-power Operation 326 7.2.6.3 Simulation 326 7.2.6.4 Programming Model 327 7.2.6.5 Features 328 \n\nContents xiii \n\n7.3 Vision and Architecture of a Testbed for the Web of Things 328 7.3.1 An All-IP-based Infrastructure for Smart Objects 330 7.3.2 Enabling Interactions with Smart Objects through the IoT Hub 332 7.3.2.1 Integration Challenges 334 7.3.3 Testbed Access and Security 335 7.3.3.1 The Role of Authorization 335 7.3.4 Exploiting the Testbed: WoT Applications for Mobile and Wearable Devices 336 7.3.5 Open Challenges and Future Vision 338 7.4 Wearable Computing for the IoT: Interaction Patterns with Smart Objects in RESTful Environments 340 7.4.1 Shaping the Internet of Things in a Mobile-Centric World 340 7.4.2 Interaction Patterns with Smart Objects through Wearable Devices 342 7.4.2.1 Smart Object Communication Principles 342 7.4.2.2 Interaction Patterns 343 7.4.3 Implementation in a Real-world IoT Testbed 345 7.4.3.1 Future Vision: towards the Tactile Internet 348 7.5 E\ufb00ective Authorization for the Web of Things 349 7.5.1 Authorization Framework Architecture 353 7.5.1.1 System Operations 353 7.5.2 Implementation and Validation 357 \n\nReference 359 \n\nIndex 381 \n\nxv \n\nPreface \n\nThe Internet of Things or, as commonly referred to and now univer- sally used, IoT has two keywords: things and Internet. The very idea of IoT consists allowing things to connect to the (existing) Internet, thus allowing the generation of information and, on the reverse, the inter- action of the virtual world with the physical world. This book does not attempt to be an exhaustive treaty on the subject of IoT. Rather, it tries to present a broad view of the IoT based on the joint research activ- ity at the University of Parma, mainly in the years between 2012 and 2015 (when all the authors were a\ufb03liated with the same Department of Information Engineering), especially in the context of the EU FP7 project CALIPSO (Connect All IP-based Smart Objects!, 2012\u20132014). In particular, we present, in a coherent way, new ideas we had the opportunity to explore in the IoT ecosystem, trying to encompass the presence of heterogeneous communication technologies through uni- fying concepts such as interoperability, discoverability, security, and privacy. On the way, we also touch upon cloud and fog computing (two concepts interwoven with IoT) and conclude with a practical view on IoT (with focus on the physical devices). The intended audience of the book is academic and industrial professionals, with good techni- cal skills in networking technologies. To ease reading, we have tried to provide intuition behind all presented concepts. The contents of the book \ufb02ow from a preliminary overview on the Internet and the IoT, with details on \u201cclassical\u201d protocols, to more technical details. The synopsis of the book can be summarized as fol- lows: The \ufb01rst chapter introduces IoT in general terms and illustrates a few IoT-enabled applications, from home/building automation to smart farming. The second chapter contains an overview of relevant standards (e.g. Constrained Application Protocol, CoAP), presented \n\nxvi Preface \n\naccording to the protocol layers and parallelizing the \u201ctraditional\u201d Internet and the IoT, with a \ufb01nal outlook on industrial IoT. Chapter three focuses on interoperability, a key concept for IoT, highlighting relevant aspects (e.g. Representational State Transfer (REST) archi- tectures and Web of Things) and presenting illustrative applications (e.g. the Dual-network Management Protocol (DNMP) allowing the interaction of IEEE 802.11s and IEEE 802.15.4 networks). At the end of Chapter three, we preliminarily also discuss discoverability in constrained environments (with reference to the CoRE Link Format); this paves the way to Chapter four, which dives into the concept of discoverability (both in terms of service and resource discovery), presenting a few of our research results in this area. Chapter \ufb01ve is dedicated to security and privacy in the IoT, discussing proper mechanisms for IoT in a comparative way with respect to common mechanisms for classical Internet. In Chapter six, we consider cloud and fog computing, discussing concepts such as big stream processing (relevant for cloud-based applications) and the IoT Hub (relevant for fog-based applications). Finally, Chapter seven is an overview of hands-on issues, presenting relevant hardware devices and discussing a Web-of-Things-oriented vision for a test bed implementation. We remark that the speci\ufb01c IoT protocols, algorithms, and archi- tectures considered in this book are \u201crepresentative,\u201d as opposed to \u201cuniversal.\u201d In other words, we set to write this book mainly to pro- vide the reader with our vision on IoT. Our hope is that this book will be interpreted as a starting point and a useful comparative reference for those interested in the continuously evolving subject of the IoT. It is our pleasure to thank all the collaborators and students who were with us during the years of research that have led to this book, collaborating with the Wireless Adhoc and Sensor Networks (WASN) Lab of Department of Information Engineering of the University of Parma, which has lately been \u201crebranded,\u201d owing to this intense research activity, as the IoT Lab at the Department of Engineering and Architecture. We particularly thank, for fundamental contributions, Dr. Laura Belli, Dr. Luca Davoli, Dr. Paolo Medagliani, Dr. Stefano Busanelli, Gabriele Ferrari, Vincent Gay, Dr. J\u00e9r\u00e9mie Leguay, Mattia Antonini, Dr. Andrea Gorrieri, Lorenzo Melegari, and Mirko Mancin. We also thank, for collaborative e\ufb00orts and useful discussions, Dr. Michele Amoretti, Dr. Francesco Zanichelli, Dr. Andrzej Duda, Dr. Simon Duquennoy, Dr. Nicola Iotti, Dr. Andrea G. Forte, and Giovanni Guerri. Finally, we express our sincere gratitude to Wiley \n\nPreface xvii \n\nfor giving us the opportunity to complete this project. In particular, we are indebted to Tiina Wigley, our executive commissioning editor, for showing initial interest in our proposal; we are really indebted to Sandra Grayson, our associate book editor, who has shown remark- able patience and kindness, tolerating our delay and idiosyncrasies throughout the years of writing. \n\nParma, July 2018 Simone Cirani Gianluigi Ferrari Marco Picone Luca Veltri \n\n1 \n\n1 \n\nPreliminaries, Motivation, and Related Work \n\n1.1 What is the Internet of Things? \n\nThe Internet of Things (IoT) encapsulates a vision of a world in which billions of objects with embedded intelligence, communication means, and sensing and actuation capabilities will connect over IP (Internet Protocol) networks. Our current Internet has undergone a fundamental transition, from hardware-driven (computers, \ufb01bers, and Ethernet cables) to market-driven (Facebook, Amazon) opportu- nities. This has come about due to the interconnection of seamingly disjoint intranets with strong horizontal software capabilities. The IoT calls for open environments and an integrated architecture of inter- operable platforms. Smart objects and cyber-physical systems \u2013 or just \u201cthings\u201d \u2013 are the new IoT entities: the objects of everyday life, augmented with micro-controllers, optical and/or radio transceivers, sensors, actuators, and protocol stacks suitable for communication in constrained environments where target hardware has limited resources, allowing them to gather data from the environment and act upon it, and giving them an interface to the physical world. These objects can be worn by users or deployed in the environment. They are usually highly constrained, with limited memory and available energy stores, and they are subject to stringent low-cost requirements. Data storage, processing, and analytics are fundamental requirements, necessary to enrich the raw IoT data and transform them into useful information. According to the \u201cEdge Computing\u201d paradigm, introducing computing resources at the edge of access networks may bring several bene\ufb01ts that are key for IoT scenarios: low latency, real-time capabilities and context-awareness. Edge nodes (servers or micro data-centers on the edge) may act as an interface to data \n\nInternet of Things: Architectures, Protocols and Standards, First Edition. Simone Cirani, Gianluigi Ferrari, Marco Picone, and Luca Veltri. \u00a9 2019 John Wiley & Sons Ltd. Published 2019 by John Wiley & Sons Ltd. \n\n2 1 Preliminaries, Motivation, and Related Work \n\nstreams coming from connected devices, objects, and applications. The stored Big Data can then be processed with new mechanisms, such as machine and deep learning, transforming raw data generated by connected objects into useful information. The useful information will then be disseminated to relevant devices and interested users or stored for further processing and access. \n\n1.2 Wireless Ad-hoc and Sensor Networks: The Ancestors without IP \n\nWireless sensor networks (WSNs) were an emerging application \ufb01eld of microelectronics and communications in the \ufb01rst decade of the twenty-\ufb01rst century. In particular, WSNs promised wide support of interactions between people and their surroundings. The potential of a WSN can be seen in the three words behind the acronym: \n\n\u2022 \u201cWireless\u201d puts the focus on the freedom that the elimination of wires gives, in terms of mobility support and ease of system deploy- ment; \u2022 \u201cSensor\u201d re\ufb02ects the capability of sensing technology to provide the means to perceive and interact \u2014 in a wide sense \u2014 with the world; \u2022 \u201cNetworks\u201d gives emphasis to the possibility of building systems whose functional capabilities are given by a plurality of communi- cating devices, possibly distributed over large areas. \n\nPushed on by early military research, WSNs were di\ufb00erent from traditional networks in terms of the communication paradigm: the address-centric approach used in end-to-end transmissions between speci\ufb01c devices, with explicit indication of both source and destina- tion addresses in each packet, was to be replaced with an alternative (and somewhat new) data-centric approach. This \u201caddress blindness\u201d led to the selection of a suitable data di\ufb00usion strategy \u2013 in other words, communication protocol \u2013 for data-centric networks. The typical network deployment would consist of the sources placed around the areas to be monitored and the sinks located in easily accessible places. The sinks provided adequate storage capacity to hold the data from the sources. Sources might send information to sinks in accordance with di\ufb00erent scheduling policies: periodic (i.e., time-driven), event speci\ufb01c (i.e., event-driven), a reply in response to \n\n1.3 IoT-enabled Applications 3 \n\nrequests coming from sinks (i.e., query-driven), or some combination thereof. Because research focused on the area, WSNs have typically been associated with ad-hoc networks, to the point that the two terms have almost become \u2013 although erroneously so \u2013 synonymous. In particular, ad-hoc networks are de\ufb01ned as general, infrastructure-less, cooperation-based, opportunistic networks, typically customized for speci\ufb01c scenarios and applications. These kinds of networks have to face frequent and random variations of many factors (radio channel, topology, data tra\ufb03c, and so on), implying a need for dynamic management of a large number of parameters in the most e\ufb03cient, e\ufb00ective, and reactive way. To this end, a number of key research problems have been studied, and solutions proposed, in the literature: \n\n\u2022 self-con\ufb01guration and self-organization in infrastructure-less systems; \u2022 support for cooperative operations in systems with heterogenous members; \u2022 multi-hop peer-to-peer communication among network nodes, with e\ufb00ective routing protocols; \u2022 network self-healing behavior providing a su\ufb03cient degree of robustness and reliability; \u2022 seamless mobility management and support of dynamic network topologies. \n\n1.3 IoT-enabled Applications \n\nThe IoT touches every facet of our lives. IoT-enabled applications are found in a large number of scenarios, including: home and building automation, smart cities, smart grids, Industry 4.0, and smart agricul- ture. In each of these areas, the use of a common (IP-oriented) commu- nication protocol stack allows the building of innovative applications. In this section, we provide a concise overview of potential applications in each of these areas. \n\n1.3.1 Home and Building Automation \n\nAs the smart home market has seen growing investment and has continued to mature, ever more home automation applications have \n\n4 1 Preliminaries, Motivation, and Related Work \n\nappeared, each designed for a speci\ufb01c audience. The result has been the creation of several disconnected vertical market segments. Typical examples of increasingly mainstream applications are related to home security and energy e\ufb03ciency and energy saving. Pushed by the inno- vations in light and room control, the IoT will foster the development of endless applications for home automation. For example, a typical example of an area of home automation that is destined to grow in the context of the IoT is in healthcare, namely IoT-enabled solutions for the physically less mobile (among others, the elderly, particulary relevant against a background of aging populations), and for the disabled or chronically ill (for instance, remote health monitoring and air-quality monitoring). In general, building automation solutions are starting to converge and are also moving, from the current applica- tions in luxury, security and comfort, to a wider range of applications and connected solutions; this will create market opportunities. While today\u2019s smart home solutions are fragmented, the IoT is expected to lead to a new level of interoperability between commercial home and building automation solutions. \n\n1.3.2 Smart Cities \n\nCities are complex ecosystems, where quality of life is an important concern. In such urban environments, people, companies and public authorities experience speci\ufb01c needs and demands in domains such as healthcare, media, energy and the environment, safety, and public services. A city is perceived more and more as being like a single \u201cor- ganism\u201d, which needs to be e\ufb03ciently monitored to provide citizens with accurate information. IoT technologies are fundamental to col- lecting data on the city status and disseminating them to citizens. In this context, cities and urban areas represent a critical mass when it comes to shaping the demand for advanced IoT-based services. \n\n1.3.3 Smart Grids \n\nA smart grid is an electrical grid that includes a variety of operational systems, including smart meters, smart appliances, renewable energy resources, and energy-e\ufb03cient resources. Power line communications (PLC) relate to the use of existing electrical cables to transport data and have been investigated for a long time. Power utilities have been using this technology for many years to send or receive (limited amounts of) \n\n1.3 IoT-enabled Applications 5 \n\ndata on the existing power grid. Although PLC is mostly limited by the type of propagation medium, it can use existing wiring in the distribu- tion network. According to EU\u2019s standards and laws, electrical utility companies can use PLC for low bit-rate data transfers (with data rates lower than 50 Kbps) in the 3\u2013148 kHz frequency band. This technol- ogy opens up new opportunities and new forms of interactions among people and things in many application areas, such as smart meter- ing services and energy consumption reporting. This makes PLC an enabler for sensing, control, and automation in large systems spread over relatively wide areas, such as in the smart city and smart grid scenarios. On top of PLC, one can also adopt enabling technologies that can improve smart automation processes, such as the IoT. For instance, the adoption of the PLC technology in industrial scenarios (e.g., remote control in automation and manufacturing companies), paves the way to the \u201cIndustrial IoT\u201d. Several applications have been enabled by PLC technology\u2019s ability to recover from network changes (in terms of repairs and improvements, physical removal, and transfer function) mitigating the fallout on the signal transmission. Nevertheless, it is well known that power lines are far from ideal channels for data transmission (due to inner variations in location, time, frequency band and type of equipment connected to the line). As a result there has been increasing interest in the joint adoption of IoT and PLC paradigms to improve the robustness of communication. This has led to the suggestion of using small, resource-constrained devices (namely, IoT), with pervasive computing capabilities, and internet standard solutions (as proposed by Internet standardization organizations, such as IETF, ETSI and W3C). Such systems can be key components for implementing future smart grids. \n\n1.3.4 Industrial IoT \n\nThe Industrial Internet of Things (IIoT) describes the IoT as used in industries such as manufacturing, logistics, oil and gas, transporta- tion, energy/utilities, mining and metals, aviation and others. These industries represent the majority of gross domestic product among the G20 nations. The IIoT is still at an early stage, similar to where the Internet was in the late 1990s. While the evolution of the consumer Internet over the last two decades provides some important lessons, it is unclear how much of this learning is applicable to the IIoT, given its unique scope and requirements. For example, real-time responses are \n\n6 1 Preliminaries, Motivation, and Related Work \n\noften critical in manufacturing, energy, transportation and healthcare: real time for today\u2019s Internet usually means a few seconds, whereas real time for industrial machines involves sub-millisecond scales. Another important consideration is reliability. The current Internet embodies a \u201cbest e\ufb00ort\u201d approach, which provides acceptable performance for e-commerce or human interactions. However, the failure of the power grid, the air tra\ufb03c control system, or an automated factory for the same length of time would have much more serious consequences. Much attention has been given to the e\ufb00orts of large companies such as Cisco, GE, and Huawei, and government initiatives such as Industrie 4.0 in Germany. For example: \n\n\u2022 GE announced that it realized more than $1 billion in incremental revenues in 2014 by helping customers improve asset performance and business operations through IIoT capabilities and services. \u2022 The German government is sponsoring \u201cIndustrie 4.0\u201d, a multi-year strategic initiative that brings together leaders from the public and private sectors as well as from academia to create a comprehen- sive vision and action plan for applying digital technologies to the German industrial sector. \u2022 Other European countries have their own industrial transformation projects in which the IIoT takes center stage, such as Smart Fac- tory (the Netherlands), Industry 4.0 (Italy), Industry of the Future (France), and others. \u2022 China has also recently launched its \u201cMade in China 2025\u201d strat- egy to promote domestic integration of digital technologies and industrialization. \n\nAs the IIoT gains momentum, one of the biggest bottlenecks faced is the inability to share information between smart devices that may be speaking di\ufb00erent \u201clanguages\u201d. This communication gap stems from the multiple protocols used on factory \ufb02oors. So, while you can put a sensor on a machine to gather data, the ability to push that information across a network and ultimately \u201ctalk\u201d with other systems is a bit more di\ufb03cult. Standardization is therefore a key aspect of the IIoT. The IIoT\u2019s potential payo\ufb00is enormous. Operational e\ufb03ciency is one of its key attractions, and early adopters are focused on these bene\ufb01ts. By introducing automation and more \ufb02exible production techniques, for instance, manufacturers could boost their productivity by as much as 30%. In this context, three IIoT capabilities must be mastered: \n\n1.3 IoT-enabled Applications 7 \n\n\u2022 sensor-driven computing: converting sensed data into insights (using the industrial analytics described below) that operators and systems can act on; \u2022 industrial analytics: turning data from sensors and other sources into actionable insights; \u2022 intelligent machine applications: integrating sensing devices and intelligent components into machines. \n\n1.3.5 Smart Farming \n\nModern agriculture is facing tremendous challenges as it attempts to build a sustainable future across di\ufb00erent regions of the globe. Examples of such challenges include population increase, urban- ization, an increasingly degraded environment, an increasing trend towards consumption of animal proteins, changes in food preferences as a result of aging populations and migration, and of course climate change. A modern agriculture needs to be developed, characterized by the adoption of production processes, technologies and tools derived from scienti\ufb01c advances, and results from research and development activities. Precision farming or smart agriculture is an area with the greatest opportunities for digital development but with the lowest penetra- tion, to date, of digitized solutions. The farming industry will become arguably more important than ever before in the next few decades. It could derive huge bene\ufb01ts from the use of environmental and terres- trial sensors, applications for monitoring the weather, automation for more precise application of fertilizers and pesticides (thus reducing waste of natural resources), and the adoption of planning strategies for maintenance. Smart farming is already becoming common, thanks to the appli- cation of new technologies, such as drones and sensor networks (to collect data) and cloud platforms (to manage the collected data). The set of technologies used in smart farming are as complex as the activities run by farmers, growers, and other stakeholders in the sector. There are is a wide spectrum of possible applications: \ufb02eet management, livestock monitoring, \ufb01sh farming, forest care, indoor city farming, and many more. All of the technologies involved revolve around the concept of the IoT and aim at supporting farmers in their decision processes through decision-support systems. They involve real-time data at a level of granularity not previously possible. This \n\n8 1 Preliminaries, Motivation, and Related Work \n\nenables better decisions to be made, translating into less waste and an increase in e\ufb03ciency. Communication technologies are a key component of smart agricul- ture applications. In particular, wireless communication technologies are attractive, because of the signi\ufb01cant reduction and simpli\ufb01cation in wiring involved. Various wireless standards have been established. One can group these into two main categories, depending on the transmission range: \n\n\u2022 Short-range communication: including standards for: \u2013 wireless LAN, used for Wi-Fi, namely IEEE 802.11 \u2013 wireless PAN, used more widely for measurement and automation applications, such as IEEE 802.15.1 (Bluetooth) (IEEE, 2002) and IEEE 802.15.4 (ZigBee/6LoWPAN) (IEEE, 2003). All these standards use the instrumentation, scienti\ufb01c and medi- cal (ISM) radio bands, typically operating in the 2.400\u20132.4835 GHz band. \u2022 Long-range communication: including the increasingly important sub-gigahertz IoT communication techologies, such as LoRA, in the 868\u2013870 MHz band. These trade data transmission rates (on the order of hundreds of kbit/s) for longer transmission ranges. \n\nCommunication technologies can be also classi\ufb01ed according to the speci\ufb01c application: \n\n\u2022 environmental monitoring (weather monitoring and geo-referenced environmental monitoring) \u2022 precision agriculture \u2022 machine and process control (M2M communications) \u2022 facility automation \u2022 traceability systems. \n\n9 \n\n2 \n\nStandards \n\n2.1 \u201cTraditional\u201d Internet Review \n\nThe original idea of the Internet was that of connecting multiple independent networks of rather arbitrary design. It began with the ARPANET as the pioneering packet switching network, but soon included packet satellite networks, ground-based packet radio networks and other networks. The current Internet is based on the concept of open-architecture networking (an excellent overview of the history of the Internet is in an article by Leiner et al. [1]). According to this original approach, the choice of any individual network technol- ogy was not dictated by a particular network architecture but rather could be selected freely by a provider and made to interwork with the other networks through a meta-level \u201cinternetworking architecture\u201d. The use of the open systems interconnect (OSI) approach, with the use of a layer architecture, was instrumental in the design of interactions between di\ufb00erent networks. The TCP/IP protocol suite has proven to be a phenomenally \ufb02exible and scalable networking strategy. Internet Protocol (IP) (layer three) provides only for addressing and forwarding of individual packets, while the transport control protocol (TCP; layer four), is concerned with service features such as \ufb02ow control and recovery when there are lost packets. For those applications that do not need the services of TCP, the User Datagram Protocol (UDP) provides direct access to the basic service of IP. In practice, the seven-layer architecture foreseen by the ISO-OSI protocol stack has been replaced by a \ufb01ve-layer IP stack. This is typically referred to as the TCP/IP protocol stack, because the TCP is the most-used protocol in the transport layer and IP is the almost ubiquitous in the network layer. The three upper layers of the \n\nInternet of Things: Architectures, Protocols and Standards, First Edition. Simone Cirani, Gianluigi Ferrari, Marco Picone, and Luca Veltri. \u00a9 2019 John Wiley & Sons Ltd. Published 2019 by John Wiley & Sons Ltd. \n\n10 2 Standards \n\nOSI Model TCP/IP Model \n\nApplication Layer \n\nPresentation Layer \n\nSession Layer \n\nTransport Layer \n\nNetwork Layer \n\nData Link Layer \n\nPhysical Layer \n\nApplication Layer \n\nTransport Layer \n\nInternet Layer \n\nHost-To-Network (Network Access Layer) \n\nFigure 2.1 Communication protocol stacks: traditional seven-layer ISO-OSI stack (left) versus four-layer TCP/IP stack (right). \n\nISO-OSI protocol stack \u2013 the session (layer \ufb01ve), presentation (layer six), and application (layer seven) \u2013 converge in a single (\ufb01fth) layer in the TCP/IP protocol stack, namely The layered architecture of the Internet (according to the ISO-OSI and TCP/IP models) is shown in Figure 2.1. In the following, we summarize the main communication protocols used in the various layers of the ISO-OSI communication protocol stack. In particular, we will outline: \n\n\u2022 at the physical/link layer (L1/L2), the IEEE802.3 (Ethernet) and IEEE 802.11 (Wi-Fi) protocols; \u2022 at the network layer (L3), IPv4 and IPv6; \u2022 at the transport layer (L4), TCP and UDP; \u2022 at the application layer (L5), Hypertext Transfer Protocol (HTTP) and Session Initiation Protocol (SIP). \n\n2.1.1 Physical/Link Layer \n\nIn this subsection, we focus on two relevant communication protocols for physical/link (PHY/MAC) layers, namely the IEEE 802.3 standard \n\n2.1 \u201cTraditional\u201d Internet Review 11 \n\n(typically referred to as Ethernet) and the IEEE 802.11 (which refers to the vast family of Wi-Fi standards, with all their amendments). While the former applies to wired local area networks (LANs), the latter applies to wireless LANs (WLANs). Being related to the bottom two layers of the protocol stack, they mostly refer to point-to-point communications; in other words, there is no concept of routing. \n\n2.1.1.1 IEEE 802.3 (Ethernet) IEEE 802.3 is the set of standards issued by the Institute of Electrical and Electronics Engineers (IEEE) to de\ufb01ne Ethernet-based networks as well as the name of the working group assigned to develop them. IEEE 802.3 is otherwise known as the Ethernet standard and de\ufb01nes the physical layer and the media access control (MAC) for the data link layer for wired Ethernet networks. It is generally a local area network (LAN) technology. IEEE 802.3 speci\ufb01es the physical and networking characteristics of an Ethernet network, such as how physical connections between nodes (routers/switches/hubs) are made through various wired media, such as copper coaxial or \ufb01ber cables. The technology was developed to work with the IEEE 802.1 standard for network archi- tecture and the \ufb01rst released standard was Ethernet II in 1982, which featured 10 Mbit/s delivered over thick coaxial cable and frames with a type \ufb01eld. In 1983, the \ufb01rst standard with the name IEEE 802.3 was developed for 10BASE5 (also known as \u201cthick Ethernet\u201d or thicknet). It had the same speed as the earlier Ethernet II standard, but the type \ufb01eld was replaced by a length \ufb01eld. IEEE 802.3a followed in 1985, and was designated as 10BASE2, which was essentially the same as 10BASE5 but ran on thinner coaxial cables, therefore it was also known as \u201cthinnet\u201d or \u201ccheapnet\u201d. There are a multitude of additions and revisions to the 802.3 stan- dard and each is designated by letters appended after the number \u201c3\u201d. Other notable standards are 802.3i for 10Base-T for twister pair wire and 802.3j 10BASE-F for \ufb01ber-optic cables, with the latest revision (2016) being 802.3bz, which supports 2.5GBASE-T and 5GBASE-T: 2.5-Gbit and 5-Gbit Ethernet over Cat-5/Cat-6 twisted pair wires. At layer two, Ethernet relies on carrier-sense multiple access with collision detection technology (CSMA/CD). A CSMA protocol works as follows. A station desiring to transmit senses the medium. If the medium is busy (i.e., some other station is transmitting) then the station defers its transmission to a later time. If the medium is \n\n12 2 Standards \n\nsensed as being free then the station is allowed to transmit. CSMA is very e\ufb00ective when the medium is not heavily loaded since it allows stations to transmit with minimum delay. But there is always a chance of stations simultaneously sensing the medium as being free and transmitting at the same time, causing a collision. These collision situations must be identi\ufb01ed so that the MAC layer can retransmit the frame by itself and not rely on the upper layers, which would cause signi\ufb01cant delay. Ethernet relies on the CD mechanism to mitigate this condition. It uses a carrier-sensing scheme in which a transmitting station can detect collisions while transmitting a frame. It does this by sensing transmissions from other stations. When a collision condition is detected, the station stops transmitting that frame, transmits a jam signal, and then waits for a random time interval before trying to resend the frame. This collision detection approach is possible over cabled networks, but does not work in wireless networks. CSMA/CD improves the CSMA performance by terminating transmission as soon as a collision is detected, thus shortening the time required before a retry can be attempted. \n\n2.1.1.2 IEEE 802.11 IEEE 802.11 is a set of PHY/MAC speci\ufb01cations for implementing wireless local area networks (WLAN) in various frequency bands, including the 900 MHz and the 2.4, 3.6, 5, and 60 GHz bands. The base version of the standard was released in 1997, and has had numerous subsequent amendments. The standard and its amendments provide the basis for wireless network products using the Wi-Fi brand. While each amendment is o\ufb03cially revoked when it is incorporated in the latest version of the standard, the corporate world tends to market the revisions individually, because they concisely denote the capabili- ties of their products. As a result, in the marketplace, each revision tends to become its own standard. Among the latest amendments are: \n\n\u2022 IEEE 802.11ac (2013): which guarantees very high throughput in the frequency band below 6 GHz, and brings potential improvements over 802.11n, including a better modulation scheme, wider chan- nels, and multi-user MIMO; \u2022 IEEE 802.11ah (2016): for sub-GHz license-exempt operations, such as sensor networks and smart metering; \u2022 IEEE 802.11ai: which introduces fast initial link setup. \n\nAn 802.11 LAN is based on a \u201ccellular\u201d architecture: the system is subdivided into cells. Each cell, referred to as a basic service set in the \n\n2.1 \u201cTraditional\u201d Internet Review 13 \n\n802.11 nomenclature, is controlled by a base station, known as an access point (AP). Although a wireless LAN may be formed by a single cell, with a single AP, most installations are formed by several cells, with the APs connected through some backbone, denoted as the distribution system (DS). This backbone is typically an Ethernet, and in some cases is wireless itself. The whole interconnected WLAN, including the di\ufb00erent cells, their respective APs and the DS, is seen as a single 802 network to the upper layers of the OSI model and is known as an extended service set. The basic access mechanism, called the distributed coordination function, is basically a carrier sense multiple access with collision avoidance technology (CSMA/CA). As notes above, CD mechanisms are a good idea in a wired LAN, but they cannot be used in a WLAN environment for two main reasons: \n\n\u2022 it would require the implementation of a full-duplex radio, increas- ing the price signi\ufb01cantly; \u2022 in a wireless environment we cannot assume that all stations hear each other (which is the basic assumption of the CD scheme), and the fact that a station wants to transmit and senses the medium as free does not necessarily mean that the medium is free around the receiver area. \n\nIn order to overcome these problems, the 802.11 standard uses a CA mechanism together with a positive acknowledgement scheme, as follows: \n\n1) A station wanting to transmit senses the medium: if the medium is busy then it defers; if the medium is free for a speci\ufb01ed time (referred to as the distributed interframe space), then the station is allowed to transmit. 2) The receiving station checks the cyclic redundancy check (CRC) of the received packet and sends an acknowledgment packet (ACK). Receipt of the ACK indicates to the transmitter that no collision occurred. If the sender does not receive the ACK then it retransmits the fragment until it receives the ACK or, if after a given number of retransmissions, no ACK is received, the packet is discarded. \n\nVirtual carrier sensing is another mechanism used to reduce the probability of collisions between two stations that are not within transmission range of each other. A station wanting to transmit a packet \ufb01rst transmits a short control packet, referred to as a request to \n\n14 2 Standards \n\nsend (RTS). This includes the source, destination, and the duration of the following transaction; in other words, the packet and the respec- tive ACK packet. The destination station then responds (if the medium is free) with a response control packet, referred to as the clear to send (CTS), which includes the same duration information. All stations receiving either the RTS and/or the CTS, set their virtual carrier sense indicators (referred to as the network allocation vector, NAV), for the given duration, and use this information together with the physical carrier sense when sensing the medium. This mechanism reduces the probability of a collision in the receiver area by a station that is \u201chidden\u201d from the transmitter to the short duration of the RTS transmission. This is because the station hears the CTS and reserves the medium as busy until the end of the transaction. The duration information on the RTS also protects the transmitter area from collisions during the ACK (from stations that are out of range of the acknowledging station). It should also be noted that, because the RTS and CTS are short frames, the mechanism also reduces the overhead of collisions, since these are recognized faster than if the whole packet were to be transmitted \u2013 this is true if the packet is signi\ufb01cantly bigger than the RTS, so the standard allows for short packets to be transmitted without the RTS/CTS transaction. \n\n2.1.2 Network Layer \n\nIn this subsection, we focus on the key protocol at the network layer (layer 3), namely IP, the key protocol for relaying datagrams across the Internet, de\ufb01ned as a combination of heterogeneous networks. IP is thus the key protocol to enable inter-networking and to allow e\ufb03- cient and robust routing in a very scalable way. The current version of IP is version 4 (IPv4), which relies on 32-bit addresses. However, its designated successor and thr fundamental enabler of the IoT is IPv6, which used 128-bit addresses, thus allowing the number of address- able \u201cthings\u201d to explode. In the following, a comparative oveview of IPv4 and IPv6 is presented. \n\n2.1.2.1 IPv6 and IPv4 IPv6 is the next-generation Internet protocol, and the Internet is still in its transition from IPv4. IPv4 public addresses have been exhausted and various techniques \u2013 such as Dynamic Host Control Protocol (DHCP), network address translation (NAT), and sub-netting \u2013 have been proposed in order to slow down the rate at which IPv4 IP address exhaustion is approaching. \n\n2.1 \u201cTraditional\u201d Internet Review 15 \n\nIn practice, IPv6 is much more than an extension of IPv4 addressing. IPv6, \ufb01rst de\ufb01ned in the RFC 2460 standard, is a complete implemen- tation of the network layer of the TCP/IP protocol stack and it covers a lot more than a simple address-space extension from 32 to 128 bits (the mechanism that gives IPv6 its ability to allocate addresses to all the devices in the world for decades to come). The technical functioning of the Internet remains the same with both versions of IP, and it is likely that both versions will continue to operate simultaneously on networks well into the future. To date, most networks that use IPv6 support both IPv4 and IPv6 addresses. The main characteristics of IPv4 and IPv6 can be summarized as follows. For more details, the reader is invited to the many widely avail- able references on the subject. \n\nIPv4 IPv4 uses 32-bit (4-byte) addresses in dotted decimal notation, for example 192.149.252.76, with each entry being a decimal digit \u2013 leading zeros can be omitted. An address is composed of a network and a host portion, which depend on the address class. Various address classes are de\ufb01ned: A, B, C, D, or E depending on initial few bits. The total number of IPv4 addresses is 232 = 4,294,967,296. NAT can be used to extend these address limitations. The IPv4 header has a variable length of 20\u201360 bytes, depending on the selected IP options. The support of IPSec is optional and options are integrated in the header \ufb01elds (before any transport header). The left-hand side of Figure 2.2 shows the structure of an IPv4 header. IPv4 addresses are not associated with the concept of address lifetimes, unless the IP address has been assigned by a DHCP (for example, through a Wi-Fi access point). IPv4 addresses are categorized into three basic types: unicast address, multicast address, and broadcast address. All IPv4 addresses are public, except for three address ranges that have been des- ignated as private by IETF RFC 1918: 10.*.*.* (10/8), 172.16.0.0 through 172.31.255.255 (172.16/12) , and 192.168.*.* (192.168/16). Private address domains are commonly used within organizations. Private addresses cannot be routed across the Internet. IP addresses are assigned to hosts by DHCP or static con\ufb01guration. The typical minimum value of the maximum transmission unit (MTU) of a link \u2013 the maximum number of bytes that a particular link type supports \u2013 is 576 bytes. \n\n1 Byte \n\nVersion Version Header Length \n\nDATA \n\nH e a d e r \n\n32 bits \n\n1 Byte 1 Byte 1 Byte 1 Byte 1 Byte 1 Byte 1 Byte \n\nType of Service Total Packet Length \n\nldentification Flags Fragment Offset \n\nProtocol Time to Live Header Checksum \n\n32-bit IPv4 Source Address 128-bit IPv6 Source Address \n\n32-bit IPv4 Destination Address \n\n128-bit IPv6 Destination Address \n\n(Options, if present, padded if needed) \n\nPayload Length Next Header Hop Limit \n\nFlow Label Traffic Class \n\nFigure 2.2 Header structure for IPv4 (left) and IPv6 (right) packets. \n\n2.1 \u201cTraditional\u201d Internet Review 17 \n\nIPv6 IPv6 uses 128-bit (16-byte) addresses in hexadecimal notation (i.e., each entry corresponds to 4 bits), for example 3FFE:F200:0234: AB00. The basic architecture is 64 bits for the network number and 64 bits for the host number. Often, the host portion of an IPv6 address (or part of it) will be derived from a MAC address or other interface identi\ufb01er. The total number of IPv6 addresses is 2128 = 3.4 \u00d7 1038. There is no NAT support by design. The IPv6 header has a \ufb01xed length of 40 bytes and there are no IP header options. IPSec needs to be supported and options are supported with extension headers (there is a simpler header format). The extension headers are AH and ESP (unchanged from IPv4), hop-by-hop, routing, fragment, and destination. The right-hand part of Figure 2.2 shows the structure of an IPv6 header. IPv6 addresses have two lifetimes: preferred and valid. The preferred lifetime is always shorter than the valid one. After the preferred life- time expires, the address must not be used as a source IP address to establish new connections if another preferred address exists. When the valid lifetime expires, the address is not used as a valid source or destination IP address. The rationale for a potentially \ufb01nite lifetime of an IPv6 address is to match the disposable nature of things, such as a beacon with a two-year lifetime. IPv6 addresses are categorized into three basic types: unicast, multicast, and anycast. IPv6 addresses can also be classi\ufb01ed as either public or temporary (with limited lifetime). Temporary addresses can be routed globally, while IPv4 private addresses cannot. Temporary addresses are used for privacy purposes, concealing the actual identity of the initiator of a communication. Moreover, temporary addresses do not contain an interface identi\ufb01er that is a MAC address. IPv6 addresses are self-assigned to hosts with stateless address auto-con\ufb01guration or DHCPv6. IPv6 has a lower boundary limit on MTU of 1280 bytes and there- fore does not fragment packets below this threshold. Fragmentation and defragmentation at the link-layer must occur to transmit an IPv6 packet over a link of less than 1280 MTU, such as IEEE 802.15.4. \n\n2.1.3 Transport Layer \n\nThe main goal of protocols at the transport layer is to provide host-to- host communication services for applications, hiding the underlying \n\n8 15 16 \n\nTCP Segment Header Format \n\nUDP Datagram Header Format \n\n23 24 31 7 0 \n\n0 Source Port Destination Port \n\nSequence Number \n\nAcknowledgement Number \n\n32 \n\n64 \n\n96 Data Offset Res \n\nHeader and Data Checksum \n\nFlags Window Size \n\nOptions \n\nUrgent Pointer 128 \n\n160... \n\nBit # \n\n8 15 16 23 24 31 7 0 \n\n0 Source Port \n\nLength Header and Data Checksum \n\nDestination Port \n\n32 \n\nBit # \n\nFigure 2.3 Header structure for TCP (top) and UDP (bottom) datagrams. \n\n2.1 \u201cTraditional\u201d Internet Review 19 \n\nnetworking strategy (dealt with at network layer) and speci\ufb01c link- by-link communication strategies (dealt with at link and physical layers). \n\n2.1.3.1 TCP and UDP The two widely used protocols at the transport layer are TCP and UDP: while TCP is used for connection-oriented transmissions, UDP is used for simpler messaging transmissions. In general terms, TCP creates virtual circuits between hosts and guarantees features such as reliabil- ity, \ufb02ow control, congestion avoidance, and multiplexing, while UDP is a best-e\ufb00ort protocol that allows packet transmissions with minimum reliability (e.g., checking data integrity at the receiver. While TCP is the predominant transport layer protocol in the classical Internet, UDP, owing to its simplicity of implementation, is a very attractive option for IoT scenarios. TCP is suited for applications that require high reli- ability, and transmission time is relatively less critical. UDP is suitable for applications that need fast, yet \u201cbest-e\ufb00ort\u201d, transmission, such as games. UDP\u2019s stateless nature is also useful for servers that answer small queries from huge numbers of clients. This makes UDP a very attractive option for IoT scenarios. TCP rearranges data packets in the order speci\ufb01ed, whereas UDP has no inherent order: all packets are independent of each other. If ordering is required, it has to be managed by the application layer. TCP data is read as a byte stream, and no distinguishing indications are transmitted to signal message (segment) boundaries. In UDP, packets are sent individually and are checked for integrity only if they arrive. TCP is \u201cheavyweight\u201d, requiring three packets to set up a socket con- nection before any user data can be sent. It handles reliability and congestion control (in other words, TCP does \ufb02ow control). UDP is \u201clightweight\u201d \u2013 there is no ordering of messages, no tracking connec- tions, and so on. In other words, UDP does not have an option for \ufb02ow control. In Figure 2.3, the header structure of TCP (top) and UDP (bottom) are shown: as expected, the TCP header is much larger than that for UDP. More precisely, each TCP header has ten required \ufb01elds totaling 20 bytes (160 bits) and it can also optionally include an additional data section of up to 40 bytes in size; a UDP header contains 8 bytes. The layout of TCP headers is as follows. \n\n\u2022 Source TCP port (2 bytes) and destination TCP port (2 bytes) num- bers are the communication endpoints for sending and receiving devices. \n\n20 2 Standards \n\n\u2022 Message senders use sequence numbers (4 bytes) to mark the ordering of a group of messages. Both senders and receivers use the acknowledgment number (4 bytes) \ufb01eld to communicate the sequence numbers of messages that are either recently received or expected to be sent. \u2022 The data o\ufb00set \ufb01eld (4 bits) stores the total size of a TCP header in multiples of 4 bytes. A header not using the optional TCP \ufb01eld has a data o\ufb00set of \ufb01ve (representing 20 bytes), while a header using the maximum-sized optional \ufb01eld has a data o\ufb00set of 15 (representing 60 bytes). \u2022 Reserved data (3 bits) in TCP headers always has a value of zero. This \ufb01eld aligns the total header size as a multiple of four bytes (which is important for e\ufb03ciency of data processing). \u2022 TCP uses a set of six standard and three extended control \ufb02ags (each an individual bit representing on or o\ufb00, for a total of 9 bits) to manage data \ufb02ow in speci\ufb01c situations. One bit \ufb02ag, for example, initiates the TCP connection reset logic. \u2022 TCP senders use a number called window size (2 bytes) to regulate how much data they send to a receiver before requiring an acknowl- edgment in return. If the window size becomes too small, network data transfer will be unnecessarily slow, while if the window size becomes too large, the network link can become saturated (unusable for any other applications) or the receiver may not be able to process incoming data quickly enough (also resulting in slow performance). Windowing algorithms built into the protocol dynamically calcu- late size values and use this \ufb01eld of the TCP header to coordinate changes between senders and receivers. \u2022 The checksum value (2 bytes) inside a TCP header is generated by the protocol sender, and helps the receiver detect messages that are corrupted or tampered with. \u2022 The urgent pointer \ufb01eld (2 bytes) is often set to zero and ignored, but in conjunction with one of the control \ufb02ags, it can be used as a data o\ufb00set to mark a subset of a message as requiring priority processing. \u2022 Usage of optional TCP data (0\u201340 bytes) is beyond the scope of this chapter, but includes support for special acknowledgment and window-scaling algorithms. \n\nThe layout of UDP headers is as follows. \n\n\u2022 Source UDP port (2 bytes) and destination UDP port (2 bytes) num- bers are the communication endpoints for sending and receiving devices. \n\n2.1 \u201cTraditional\u201d Internet Review 21 \n\n\u2022 The length \ufb01eld (2 bytes) in a UDP header represents the total size of each datagram, including both header and data. This \ufb01eld ranges in value from a minimum of 8 bytes (the required header size) to sizes above 65,000 bytes. \u2022 Similar to TCP, a UDP checksum (2 bytes) allows receivers to cross-check incoming data for any corrupted bits. \n\n2.1.4 Application Layer \n\nPerhaps the most important reason for the widespread adoption of the Internet is the design and development of application layer protocols, which have been made available to developers as e\ufb00ective means to transmit information among endpoints of distributed applications without having to specify a custom communication protocol. This section will describe protocols that had an impact on the development of Internet-based applications and represent a valid introduction to IoT application scenarios. \n\n2.1.4.1 HTTP Hypertext Transfer Protocol (HTTP) [2, 3] is the most popular appli- cation layer protocol, and has been the true enabler of the Worldwide Web. Because of its extreme popularity, it is outside the scope of this book to present a detailed description of the protocol. We will out- line the most prominent features in order to highlight why HTTP is perhaps the most important and widespread application layer on the Internet. HTTP is a stateless text-based request/response protocol that de\ufb01nes the communication between a client and a server over a TCP connection. The HTTP protocol is characterized by the following features: \n\n\u2022 URLs are used to give addresses to resources targeted by requests. \u2022 Methods (or verbs) are de\ufb01ned in order to provide semantics at the application layer about the type of operation being executed by the server. The main methods used are typically GET, POST, PUT, and DELETE, although many other verbs have been de\ufb01ned, either in the HTTP speci\ufb01cation itself or in subsequent updates to address speci\ufb01c issues. \u2022 Header \ufb01elds can be added to messages in order to convey further information, so that they are processed in the correct way and to provide additional semantics to communication. \n\n22 2 Standards \n\n\u2022 Status codes in responses provide a standard, uniform, and descrip- tive way to inform the client about the result of the request that has been served. Status codes are divided into classes: \u2013 1xx Informational \u2013 2xx Success \u2013 3xx Redirection \u2013 4xx Client error \u2013 5xx Server error \n\nThe solidity of the HTTP speci\ufb01cation and its implementation in all programming languages and platforms make it common as an application-layer transport protocol for information transmitted between endpoints. Its use makes the design of distributed appli- cations extremely e\ufb03cient, because all e\ufb00orts can be dedicated to de\ufb01ning the semantics of the data being exchanged. In 2015, HTTP/2 [4] was released, with a particular focus on e\ufb03- cient communication and reduced consumption of network resources in terms of latency, header compression, and parallel \ufb02ows over the same connection. \n\n2.1.4.2 AMQP The Advanced Message Queue Protocol (AMQP1) is a message- oriented protocol and a standard of the Organization for the Advancement of Structured Information Standards. The current version of AMQP is 1.0. AMQP can be seen as the asynchronous complement of HTTP. AMQP is not an actual publish/subscribe (pubsub) protocol, but rather a speci\ufb01cation for interoperable messaging for message- oriented middleware (MOM). AMQP de\ufb01nes a wire format; that is, the set of rules and principles that must be observed to create the stream of bytes to be transmitted. Therefore, any AMQP client can work with any MOM that implements AMQP. AMQP is based on a queue server. Queues are message storage facil- ities. AMQP publishers can send messages directly to a queue or to an exchange, which is a topic-based router for message dispatching. Mes- sages can be tagged with a routing key (a topic). Queues can be bound to an exchange for selective message dispatching to consumers. The routing key supports a dot-separated syntax that allows for di\ufb00erent \n\n1 https://www.amqp.org. \n\n2.1 \u201cTraditional\u201d Internet Review 23 \n\nlevels of expressiveness. Through the use of wildcards, a \ufb01ne-grained routing of messages can be implemented. Persistent queues store messages until a consumer pulls them o\ufb00 the queue; they are not tied to the existence of a consumer. Queues can, however, be dynamically created by a consumer and will then be destroyed when the consumer disconnects. AMQP provides great \ufb02exibility in creating di\ufb00erent messaging sce- narios, such as message queue, fanout, routing, and even remote pro- cedure calls (RPC). It supports reliable delivery of messages. The most popular implementations of AMQP are RabbitMQ2 and Apache ActiveMQ3 . \n\n2.1.4.3 SIP The Session Initiation Protocol (SIP) [5] is an IETF standard application-layer control protocol that can be used to establish, mod- ify, or terminate end-to-end sessions. SIP is a text-based client-server protocol, where the client sends SIP requests and the server responds to requests. The SIP architecture includes both end systems (termi- nals), also called SIP user agents, and intermediate systems, called SIP proxy, redirect or registrar servers, depending on their function. A \u201cregistrar server\u201d is SIP server that receives registration requests issued by SIP user agents, and is used for maintaining the binding between the SIP user name (also called address-of-record; SIP AOR) and its current contact address, which can be used for reaching such user/resources. The mapping between SIP AORs and SIP contact URIs is called a location service and is an important component for resource discovery in SIP. All SIP addresses are represented by URIs with the scheme sip:, and identify a name or contact address of a SIP user; a SIP user can be a real user, a system, an application, or some other kind of resource. The proxy servers are intermediary entities that act as both server and client for making requests on behalf of other clients. A proxy server may act as an \u201coutbound\u201d proxy when used for routing SIP requests addressed to users that are not maintained in a local location service, or as a \u201cfar-end\u201d (or \u201cdestination\u201d) proxy if the request is addressed to a user with an AOR maintained by the proxy and mapped to one or more SIP contact URIs. \n\n2 https://www.rabbitmq.com/. 3 http://activemq.apache.org. \n\n24 2 Standards \n\nIn contrast to proxy servers, redirect servers accept requests and replies to the client with a response message that typically provides a di\ufb00erent contact address (URI) for the target of previous request. SIP signaling between users consists of requests and responses. When a user agent (UA) wants to send a request to a remote user (identi\ufb01ed by a SIP AOR), it may send the message directly to the IP address of the remote user\u2019s UA, or to the proxy server that is responsible for the target AOR (normally the fully quali\ufb01ed domain name of the proxy server is included in the AOR), or to a locally con\ufb01gured outbound proxy server. When the request reaches the target UA, the latter may optionally reply with some provisional 1xx responses and with one \ufb01nal response (codes 2xx for success, or 3xx, 4xx, 5xx and 6xx for failure). SIP de\ufb01nes di\ufb00erent request methods, such as INVITE, ACK, BYE, CANCEL, OPTIONS, REGISTER, SUBSCRIBE, and NOTIFY. When a UA wants to initiate a session it sends an INVITE message that may be responded to with provisional 1xx responses and a \ufb01nal response. The UA that issued the INVITE then has to con\ufb01rm the \ufb01nal response with an ACK message. In contrast to all other SIP transactions, the INVITE transaction is a three-way handshake (INVITE/2xx/ACK). Once the session is established, both endpoints (user agents) may modify the session with a new INVITE transaction, or tear-down the session with a BYE transaction (BYE/2xx). When the caller or the callee wish to terminate a call, they send a BYE request. SIP messages may contain a \u201cbody\u201d, which is treated as opaque payload by SIP. Figure 2.4 shows an example of SIP message \ufb02ow, including the registration of two UAs with their own registrar/proxy servers, and a session setup and tear-down from UA1 (identi\ufb01ed by the SIP AOR sip:u1@P1) to UA2 (identi\ufb01ed by the SIP AOR sip:u2@P2). During an INVITE transaction, the SIP body is used to negotiate the session in terms of transport and application protocol, IP addresses and port number, payload formats, encryption algorithms and param- eters, and so on. The negotiation follows an o\ufb00er/answer paradigm: the o\ufb00er is usually sent within the INVITE while the answer is in the 2xx \ufb01nal response. The most commonly used protocol for such nego- tiations is the Session Description Protocol (SDP), but other protocols may be used. \n\n2.2 The Internet of Things 25 \n\nUA1 REGISTER sip:P1 To: sip:u1@P1 Contact: sip:address1:port1 \n\nREGISTER sip:P2 To: sip:u2@P2 Contact: sip:address2:port2 \n\nProxy1 \n\n200 OK \n\n180 Ringing 180 Ringing \n\nACK sip:address2:port2 \n\nData sessions \n\n200 OK \n\nBYE sip:address2:port2 \n\n180 Ringing \n\n200 OK \n\n200 OK Contact: sip:address2:port2 [SDP offer] \n\n200 OK Contact: sip:address2:port2 [SDP offer] \n\n200 OK Contact: sip:address2:port2 [SDP offer] \n\nINVITE sip:u2@P2 Contact: sip:address1:port1 [SDP offer] \n\nINVITE sip:u2@P2 Contact: sip:address1:port1 [SDP offer] \n\nINVITE sip: address2:port2 Contact: sip:address1:port1 [SDP offer] \n\nProxy2 UA2 \n\nFigure 2.4 UA registration and session setup with two intermediate proxy servers. \n\n2.2 The Internet of Things \n\nThe IoT and its applications are becoming a reality, with several com- mercial players developing innovative products in a variety of \ufb01elds, such as home automation and smart cities. These products are starting to reach end users, who are now becoming aware of the integration of physical and cyber worlds. The forecast of billions (or trillions) of con- nected devices in future years is constantly being con\ufb01rmed and can be objectively considered as a fact. The \u201cgold rush\u201d of the IoT era, driven on one hand by the will to demonstrate the feasibility of interconnect- ing everyday devices to people and, on the other hand, by the intention to make custom solutions into standards for public use, has created a plethora of closed vertical solutions. This is leading to a highly frag- mented market, a babel of incompatible solutions, rather than a highly interoperable environment, which is what the Internet and the IoT should be like. \n\n26 2 Standards \n\nCurrent IoT applications consider personal devices to be gateways, which have to bridge the world of smart objects and the user. Typi- cally, users must run custom software on their smartphones in order to interact with particular IoT objects. These apps have prior knowledge of the things they will work with: there are established communication protocols, data formats, and application-speci\ufb01c interaction patterns. In the long run, this approach represents a huge barrier to progress for a number of reasons. \n\n\u2022 Smart objects manufactured by the same vendor typically need to be accessed through legacy software, resulting in a plethora of applica- tions that end-users must install and use. This also has an impact on the creation of new applications for smart objects, whose interfaces (APIs) must be disclosed by the vendor to application developers. \u2022 Mobility is a critical factor: people access services and use applications while on the go. This means they might enter envi- ronments that contain smart objects that they have not come across before (for example, because they enter a room in a hotel or museum they had never visited before, because some smart objects might have been deployed since their last visit, or because smart objects have changed their capabilities). While there are standard self-con\ufb01guring mechanisms for discovering services and resources,(such as mDNS, DNS-SD, and web linking), these approaches are not adequate if users want to to fully and seamlessly interact with things. \u2022 Smart objects should be able to adapt dynamically to particular con- ditions, such as a change in their battery level or hosted resources, or the presence of speci\ufb01c users. Smart objects should be able to drive di\ufb00erent forms of interaction, which may not have been con- sidered at the time of custom software implementation and would therefore require upgrades or new software to be installed. \n\n2.2.1 Designing the Architecture of an IP-based Internet of Things \n\nThe IoT calls for adaptive interactions between humans and smart objects, with the goal of \ufb01lling the gap between users, the physical world, and the cyber world. In order to avoid dependence on speci\ufb01c legacy software, this interaction should be driven by the smart objects that are pervasively deployed and accessed. All actors need to speak the same language: IP. \n\n2.2 The Internet of Things 27 \n\nIn order to prevent the fragmentation that results from vertical solutions, signi\ufb01cant e\ufb00ort has been expended in private and public research groups and in standards organizations such as IEEE, IETF, and IPSO. This activity had two main goals: \n\n\u2022 to de\ufb01ne open standards for communication (e.g., 6LoWPAN/- CoAP); \u2022 to map the traditional IP-based Internet stack to the IoT. \n\nWe can now assume that the IoT will be a network of heteroge- neous interconnected devices. This will be the infrastructure for the so-called \u201cWeb of Things\u201d (WoT). After being actively involved in this research and standardization phase, we feel that there is still a signi\ufb01cant amount of work to be done to reach a state where the IoT can be accessed and exploited by end-users with the same simplicity that they experience on the web. At this point, it is time to really start interacting with smart objects, not just to communicate with them. The WoT is being designed around well-known concepts and practices derived from the Web, such as the REST paradigm. The REST paradigm was introduced to loosely couple client applications with the systems they interact with, to support long-term evolution of systems, and to provide robustness. While this proves to perfectly \ufb01t in machine-to-machine (M2M) scenarios, the loose coupling introduced at the application layer is not su\ufb03cient to enable the widespread adoption of applications that require humans to be in the loop, for example by providing input/output through some user interface. CoAP has been designated as the standard protocol for the WoT, similar to the position of HTTP for the web. In fact, CoAP has been designed to work with HTTP, to which it directly maps so as to give easy integration. While CoAP mainly targets M2M application scenarios, the widespread adoption of the WoT requires tools that allow humans to be in the loop. The Firefox web browser add-on Copper6 has been developed with the aim of narrowing the gap between the world of browsers and the world of things. Although this add-on provides a handy technical, debug console-like tool for working with CoAP-enabled smart objects, it does not really allow for easy interaction for any user. In our opinion, intuitive and easy-to-use interfaces for end-users are currently missing. The evolution of mobile and wearable computing has changed the way people use online services; they are now always connected, whether at home or on the go. In this context, there is a concrete need \n\n28 2 Standards \n\nto \ufb01ll the gap between mobile devices and the IoT. A paradigm shift in areas such as human\u2013computer interactions is needed to let people access and use the IoT with the same ease with which they can access the Internet and possibly also to enable new and more natural forms of interaction, which will widen the range of IoT users. The evolution towards the IoT begins by rethinking and optimizing all of the relevant layers of the protocol stack. In the following, we out- line the main characteristics of the communication protocols being considered for the IoT. \n\n2.2.2 Physical/Link Layer \n\nIn this subsection, we focus on four communication protocol groups relevant for IoT scenarios, (mostly) at the physical/link layer: \n\n\u2022 the IEEE 802.15.4 standard and Zigbee, which relies on IEEE 802.15.4 and introduces application management on top of this (i.e., Zigbee is not strictly at the physical/link layer) \u2022 low-power Wi-Fi, an amendment of the Wi-Fi protocol family that is attractive for IoT applications \u2022 Bluetooth and its newest energy-e\ufb03cient version Bluetooth Low Energy (BLE), which are extremely attractive for IoT because of their widespread availability, notably in almost every smartphone \u2022 protocols in the area of power line communications (PLC). \n\nWhile the \ufb01rst three groups are relevant for wireless communi- cations, the last one is used in wired communications (in electrical cables). \n\n2.2.2.1 IEEE 802.15.4 and ZigBee The IEEE 802.15 working group de\ufb01ned the physical layer (PHY) and the medium access sub-layer (MAC) for low-complexity, low-power-consumption, low-bit-rate WPAN connectivity. The IEEE 802.15.4 standard, approved in 2003 and amended several times in the following years, contributes to all of these aims, and several compliant products are already available on the market, even if more as development kits than as real end-products. The physical layer of IEEE 802.15.4 foresees the use of one of three possible unlicensed frequency bands: \n\n\u2022 868.0\u2013868.6 MHz: used in Europe, and allows one communication channel (versions published in 2003, 2006, 2011); \n\n2.2 The Internet of Things 29 \n\n\u2022 902\u2013928 MHz: used in North America, up to ten channels (2003), extended to thirty (2006); \u2022 2400\u20132483.5 MHz: used worldwide, with up to sixteen channels (2003, 2006). \n\nThe original 2003 version of the standard speci\ufb01es two physical layers based on direct sequence spread spectrum (DSSS) techniques: one working in the 868/915 MHz bands with transfer rates of 20 and 40 kbit/s, and one in the 2450 MHz band with a rate of 250 kbit/s. The 2006 revision (IEEE 802.15.4b) improves the maximum data rates of the 868/915 MHz bands, so they support 100 and 250 kbit/s. It goes on to de\ufb01ne four physical layers depending on the modulation method used. Three of these preserve the DSSS approach: \n\n\u2022 In the 868/915 MHz bands, binary or o\ufb00set quadrature phase shift keying can be used (the latter being optional). \u2022 In the 2450 MHz band, using the latter. \u2022 An alternative, optional 868/915 MHz layer is de\ufb01ned using a com- bination of binary keying and amplitude shift keying; it is thus based on parallel sequence spread spectrum (PSSS). \n\nDynamic switching between supported 868/915 MHz PHYs is possible. Beyond these three bands, the IEEE 802.15.4c study group con- sidered the newly opened 314\u2013316 MHz, 430\u2013434 MHz, and 779\u2013787 MHz bands in China, while the IEEE 802.15 Task Group 4d de\ufb01ned an amendment to 802.15.4-2006 to support the new 950\u2013956 MHz band in Japan. The \ufb01rst standard amendments by these groups were released in April 2009. In August 2007, IEEE 802.15.4a was released. This expanded the four PHYs available in the earlier 2006 version to six, including one PHY using direct sequence ultra-wideband and another using chirp spread spectrum. The ultra-wideband PHY is allocated frequencies in three ranges: below 1 GHz, between 3 and 5 GHz, and between 6 and 10 GHz. The chirp spread spectrum PHY is allocated spectrum in the 2450 MHz ISM band. In April 2009, IEEE 802.15.4c and IEEE 802.15.4d were released. These expanded the available PHYs through addition of several new PHYs: one for the 780 MHz band using O-QPSK or MPSK and another for the 950 MHz band using GFSK or BPSK. IEEE 802.15.4e, \ufb01nally approved in 2012, was de\ufb01nes a MAC amendment to the existing 802.15.4-2006 standard. It adopts a \n\n30 2 Standards \n\nchannel-hopping strategy to improve support for the industrial markets, and increases robustness against external interference and persistent multi-path fading. The IEEE 802.15.4 family provides for low bit-rate connectivity in the personal operating space; typically between 10 and 100 m. Full support of mesh networks for battery-powered nodes is provided, through the classi\ufb01cation of devices into two di\ufb00erent types: full function devices (FFD) and reduced function devices (RFD). An IEEE 802.15.4 network should include at least one FFD operating as the PAN coordinator for special (but not centralized) functions, whereas all the other FFDs should make up the wireless sensor network (WSN) backbone; RFDs, which are usually intended as the \u201cleaf\u201d nodes of the WSN spanning tree, perform simple tasks more related to sensing than networking. An RFD can communicate only with one FFD, while an FFD can com- municate with both RFDs and FFDs. In the late 2000s, on the basis of the current IEEE 802.15.4 speci\ufb01- cations, a consortium of hundreds of companies agreed the adoption of an industrial standard called ZigBee; the name was inspired by the social behavior of bees, which work together to tackle complex tasks. ZigBee exploits cooperation to allow for the multi-hop exchange of messages and it adds logical network, security, and application man- agement functions on top of the referenced IEEE 802.15.4 standard by de\ufb01ning the upper layers of the protocol stack, from network to application. In addition, ZigBee de\ufb01nes application pro\ufb01les, a set of template-based descriptions of device con\ufb01gurations, each one spe- cialized for work in a common cooperative and distributed application. Aside from its technical aspects, one of the main tasks of the ZigBee Alliance is to ensure interoperability among devices made by di\ufb00erent manufacturers, thus expanding their potential adoption. \n\n2.2.2.2 Low-power Wi-Fi Low-power Wi-Fi refers to IEEE 802.11ah, an amendment of the IEEE 802.11-2007 wireless networking standard, called Wi-Fi HaLow by the Wi-Fi Alliance. Wi-Fi HaLow is expected to enable a variety of new power-e\ufb03cient use cases in smart homes, connected cars, and digi- tal healthcare, as well as industrial, retail, agriculture, and smart city environments. Wi-Fi HaLow extends Wi-Fi into the 900 MHz band, enabling the low-power connectivity necessary for the creation of large groups of stations or sensors that cooperate to share signals, support- ing the concept of the IoT. Wi-Fi HaLow\u2019s range is nearly twice that \n\n2.2 The Internet of Things 31 \n\nof today\u2019s Wi-Fi, and will not only be capable of transmitting signals further, but will also provide more robust connections in challenging environments and where the ability to penetrate walls or other barriers is an important consideration. 802.11ah could solve many of the problems with deploying large- footprint Wi-Fi networks by allowing for a signi\ufb01cant number of devices, providing power-saving services and allowing for long distances to the AP. A typical 802.11ah AP could associate more than 8,000 devices in a hierarchical ID structure within a range of 1 km, making it ideal for areas with a high concentrations of sensors and other small devices, such as street lamp controllers and smart parking meters. The 802.11ah standard also includes new PHY and MAC layers, grouping devices into tra\ufb03c indication maps to accommodate small units (such as sensors) and M2M communications. \n\n2.2.2.3 Bluetooth and BLE Bluetooth is a standard wire-replacement communications protocol primarily designed for low-power consumption and short com- munication ranges. The transmission range is power dependent. The speci\ufb01cations were formalized by the Bluetooth Special Interest Group (SIG). The SIG was formally established by Ericsson, IBM, Intel, Toshiba and Nokia in 1998: today it has a membership of over 30,000 companies worldwide. While Bluetooth 3.0, introduced in 2009, sup- ported a data rate of 25 Mbit/s with a transmission range of 10 m, with the latest Bluetooth 5.0, introduced in 2016, the data rate and trans- mission range have increased to 50 Mbit/s and 240 m. On top of the physical layer, link-layer services including medium access, connec- tion establishment, error control, and \ufb02ow control are provided. The upper logical link control and adaptation protocol provides multiplex- ing for data channels, fragmentation and reassembly of larger packets. The other upper layers are the Generic Attribute Protocol, which pro- vides for e\ufb03cient data collection from sensors, and the generic access pro\ufb01le, which allows for con\ufb01guration and operation in di\ufb00erent modes, such as advertising or scanning, and connection initiation and management. The Bluetooth Core Speci\ufb01cation version 4.0 (known also as \u201cBlue- tooth Smart\u201d) was adopted in 2010. Bluetooth 4.0 includes classic Bluetooth, Bluetooth High Speed and Bluetooth Low Energy (BLE) protocols. Bluetooth High Speed is based on Wi-Fi, while classic Bluetooth consists of legacy Bluetooth protocols. BLE, previously \n\n32 2 Standards \n\nknown as Wibree, is a subset of Bluetooth 4.0 with an entirely new protocol stack for rapid build-up of simple links. It is aimed at very low power applications running o\ufb00a coin cell battery. Chip designs allow for two types of implementation: dual-mode and single- mode. Starting from version 4.2, IoT-oriented features have been intro- duced into Bluetooth: \n\n\u2022 low energy secure connection with data packet length extension (v4.2); \u2022 link layer privacy (v4.2); \u2022 IP support pro\ufb01le (v6.0) \u2022 readiness for Bluetooth Smart Things to support connected homes (v4.2); \u2022 connectionless services, such as location-relevant navigation of low-energy Bluetooth connections (v5.0). \n\nBLE uses a short-range radio with minimal power use, which can operate for a much longer time (even for years) compared to previ- ous versions. Its range coverage (about 100 m) is ten times that of the classic Bluetooth while its latency is 15 times shorter. BLE can be oper- ated using a transmission power of between 0.01 and 10 mW. With these characteristics, BLE is a good candidate for IoT applications. The BLE standard has been developed rapidly by smartphone makers and is now available in most smartphone models. The feasibility of using this standard has been demonstrated in vehicle-to-vehicle communi- cations as well as in WSNs. Compared to ZigBee, BLE is more e\ufb03cient in terms of energy con- sumption and the ratio of transmission energy per transmitted bit. BLE allows devices to operate as masters or slaves in a star topology. For the discovery mechanism, slaves send advertisements over one or more dedicated advertisement channels. To be discovered as a slave, these channels are scanned by the master. When they are not exchanging data, the devices are in sleep mode. \n\n2.2.2.4 Powerline Communications Power line communications (PLC) involve the use of existing elec- trical cables to transport data and have been investigated for a long time. Power utilities have been using this technology for many years to send or receive (limited amounts of) data on the existing power \n\n2.2 The Internet of Things 33 \n\ngrid. Today, PLCs represent a very appealing area of application for IoT technologies. Relevant IoT-oriented smart grid communication protocols can be summarized as follows. \n\n\u2022 PRIME: intended for PLC-based modems operating in the fre- quency range between 42 kHz and 88 kHz using orthogonal frequency-division multiplexing; \u2022 HomePlug: operating at frequencies of up to 400 kHz; \u2022 G3-PLC: intended for PLC-based modems operating in a sub- frequency range of the CENELEC A band, from 35 to 91 kHz; \u2022 G.hnem: the speci\ufb01cation was drafted by ITU and selected G3-PLC and PRIME as annexes to its main body. \u2022 IEEE P1901.2: de\ufb01ned by IEEE and adopting G3- PLC and PRIME. \n\n2.2.3 Network Layer \n\nThe envisioned IP-based IoT will consist of trillions of connected devices. This unprecedented magnitude demands strategic choices to be taken in the design of a global network of smart objects. On the one hand, there is the need to address each and every smart object individually (and globally). On the other hand, the use of IPv4 cannot be a long-term approach. The depletion of IPv4 addresses makes it impossible to assign public IPv4 addresses to objects. The use of IPv4 would require the introduction of NAT techniques in order to provide an extended address space to smart objects. This would involve complex con\ufb01guration management to ensure reachability of smart objects. As a result, the scalability, manageability, and ease of deployment of smart objects would be in jeopardy. Stemming from these considerations, the only feasible solution to create a global, sustainable, and scalable IoT is to adopt IPv6 at the net- work layer. In particular, IPv6 provides some bene\ufb01cial features that make its adoption convenient: \n\n\u2022 its addresses are 128 bits long, thus making it possible to assign about 3.4 \u00d7 1038 unique IP addresses; \u2022 it integrates IPSec for security; \u2022 it provides link-local and global addresses, derived from the device\u2019s MAC address, with a pre\ufb01x of fe80::/10, or provided by the net- work\u2019s router. \n\n34 2 Standards \n\n2.2.3.1 The 6LoWPAN Adaptation Layer Low-power wireless personal area networks (WPANs) have special characteristics, that set them apart from earlier link-layer technolo- gies. These include limited packet size (a maximum 127 bytes for IEEE 802.15.4), various address lengths, and low bandwidth. These characteristics necessitate an adaptation layer that \ufb01ts IPv6 packets to the IEEE 802.15.4 speci\ufb01cations. The IETF 6LoWPAN working group developed such a standard in 2007. 6LoWPAN is the speci\ufb01cation of mapping services required to maintain an IPv6 network over low-power WPANs. The standard provides header compression to reduce the transmission overhead, fragmentation to meet the IPv6 MTU requirement, and forwarding to link-layer to support multi-hop delivery. In general, the goal of 6LoWPAN is to transmit a small IPv6 datagram over a single IEEE 802.15.4 hop. \n\n2.2.4 Transport Layer \n\nIoT scenarios typically call for energy-e\ufb03cient, lightweight, and non CPU-intensive approaches to communication. This is a result of the limited capabilities of smart objects. For these reasons, UDP is the typ- ical choice for transport-layer communication in the IoT. Of course, this choice results in the impossibility of enjoying the nice features that TCP provides, such as retransmission, ordering, and congestion control. These must be implemented in a higher layer if needed by an application. There are other transport-layer protocols that may be considered, such as SCTP [6], which focuses on stream control. However, there has not been a concrete e\ufb00ort by the research community, academia, or industry to de\ufb01ne an IoT-oriented transport-layer protocol as has been done for all other layers. \n\n2.2.5 Application Layer \n\nThe experience gained with the Internet and the importance attributed to application-layer protocols have been critical to the awareness that the IoT needs a dedicated application-layer, which must take into account all the requirements of, and the conditions deriving from, lower layers. A dedicated web transfer protocol for low-power and lossy networks (LLNs), called the Constrained Application Protocol (CoAP), has been de\ufb01ned, with the aim of replicating the outstanding experience of HTTP and the resulting widespread adoption of the web. Other application-layer protocols have also been proposed in \n\n2.2 The Internet of Things 35 \n\norder to provide alternatives to the stateless request/response com- munication paradigm o\ufb00ered by CoAP. Examples include pub/sub communications (an example of which is the MQTT protocol), and introducing sessions such as CoSIP. In this section, we will provide a detailed presentation of CoAP and CoSIP in order to highlight their features, the design choices behind them, and how they can represent the enablers for the development and deployment of e\ufb03cient, complex, large-scale IoT applications. \n\n2.2.5.1 CoAP LoWPANs are typically characterized by: \n\n\u2022 Small packet size: Since the maximum physical layer packet for IEEE 802.15.4 is 127 bytes, the resulting maximum frame size at the MAC layer is 102 octets. Link-layer security imposes a further overhead, which, in the maximum case (21 octets of overhead in the AES-CCM-128 case, versus 9 and 13 for AES-CCM-32 and AES-CCM-64, respectively), leaves only 81 octets for data packets. \u2022 Low bandwidth: The limited bandwidth does not allow for data to be transferred at high rates (data rates are of the order of tens or a few hundreds of kilobits per second). It is important to exchange as little data as possible to minimize latency of transmission. \u2022 Low power: Some devices are battery operated, so energy consump- tion is a critical issue. Since radio-related operations are the most energy-consuming, it is desirable to minimize the amount of data to be transferred to keep radio utilization as low as possible. \u2022 Low cost: Devices are typically associated with sensors, switches, and so on. This drives some of their other characteristics such as low processing power, low memory, and so on. Numerical values for \u201clow\u201d are not given on purpose: costs tend to change over time \u2022 Unreliability: Devices are subject to uncertain radio connectivity, battery drain, device lockups, and physical tampering. \u2022 Duty cycling. Devices connected to a LoWPAN may sleep for long periods of time in order to save energy, and are thus unable to com- municate during these sleep periods. \n\nAdopting IPv6 in constrained environments through 6LoWPAN introduces: \n\n\u2022 packet fragmentation (into small link-layer frames) and compres- sion at the transmitter; \u2022 fragment reassembly (from small link-layer frames) and decompres- sion at the receiver. \n\n36 2 Standards \n\nIn 6LoWPANs, fragmentation can increase the probability of packet delivery failure. Given the small packet size of LoWPANs, applications must send small amounts of data: \n\n\u2022 less data \u21d2fewer fragments to be sent \u21d2lower energy consumption (CPU/TX/RX); \u2022 less data \u21d2fewer fragments to be sent \u21d2lower packet loss proba- bility. \n\nDue to the limited capabilities of objects in the IoT, the distinction among the di\ufb00erent layers of the protocol stack is not as strong as in the traditional Internet. This means that design choices taken at a par- ticular layer may (and typically do) have an impact on all the other layers. A cross-layer design is therefore required to ensure that things work as expected and to prevent a bad design from a\ufb00ecting the func- tioning of the object. For instance, HTTP and TCP are not well suited in this area due to overhead they introduce. On the one hand, HTTP is a text-based and very verbose protocol. On the other hand, TCP is a connection-oriented transport and requires setting up and maintain- ing of connections, which is burdensome both from a processing and a communication perspective. Moreover, duty-cycling is not compatible with keeping connections alive. For all the above reasons, application-layer protocols for the IoT must be designed carefully in order to take into account the constraints deriving from lower layers and the very nature of smart objects. The IETF candidate as application-layer protocol for the IoT is the Constrained Application Protocol (CoAP), de\ufb01ned in RFC 7252 [7]. CoAP was designed by the IETF Constrained RESTful Environments (CoRE) working group and became an Internet standard in mid-2014. CoAP is a lightweight application-layer protocol purposedly designed to bring web functionalities to constrained devices that operate in LLNs. In order to meet the requirements of constrained environments, CoAP di\ufb00ers from HTTP in a number of ways. First, it uses UDP as the underlying transport protocol instead of TCP, thus removing the burden of establishing and maintaining connections, which may be infeasible for smart objects that have limited capabilities and may be duty-cycled. As a consequence, CoAP implements its own reliability mechanisms for message retransmission, which cannot be guaranteed by the transport-layer protocol. In addition, in order to minimize \n\n2.2 The Internet of Things 37 \n\noverhead, and unlike HTTP, CoAP uses a binary format instead of a text-based format. CoAP has been designed to bring the REST paradigm (see Section 3.3) to the IoT. CoAP implements a request/response (client/ server) communication model on top of UDP \u2013 or its secure version, Datagram Transport Layer Security (DTLS) \u2014 supporting four basic methods: POST, GET, PUT, and DELETE. \n\nProtocol overview CoAP is an application-layer protocol designed to be used by con- strained devices in terms of computational capabilities, which may feature limited battery and operate in constrained (low-power and lossy) networks. \n\nCoAP is a RESTful protocol According to the REST paradigm, CoAP URIs identify the resources of the application. A resource represen- tation is the current or intended state of a resource referred to the server through a proper namespace. Representations of resources are exchanged between a client and a server. A client that is interested in the state of a resource sends a request to the server; the server then responds with the current representation of the resource. \n\nCoAP maps to HTTP CoAP maps to HTTP easily in order to guaran- tee full integration with the web. The CoAP protocol stack mirrors HTTP\u2019s, as shown in Figure 2.5. The mapping allows protocol transla- tion to be performed easily on dedicated proxies in order to guarantee full interoperability between HTTP clients and CoAP servers and vice versa. This mechanism enables CoAP-unaware clients, such as legacy \n\nFigure 2.5 CoAP protocol stack vs. HTTP protocol stack. \n\nCoAP \n\nUDP \n\nIPv6/6LoWPAN \n\nMAC \n\nPHY \n\nMAC \n\nPHY \n\nIP \n\nTCP \n\nHTTP Application \n\nTransport \n\nNetwork \n\nLink \n\nPhysical \n\nLayers Internet of Things Internet \n\n38 2 Standards \n\nHTTP-based applications, to work with smart objects without requir- ing any changes. \n\nCoAP is a binary protocol CoAP minimizes overhead by adopting a binary message format. CoAP messages are formed from some mandatory \ufb01elds (Version, Type, Token, Code, Message-ID) and other optional \ufb01elds (CoAP Options and Payload). The syntax of CoAP messages has been designed not only to keep messages small, but also to make them extremely easy and light to parse, so that smart objects can receive a bene\ufb01t in terms of energy consumption. \n\nCoAP runs on top of UDP CoAP runs on top of UDP, which is the most lightweight transport in terms of overhead (only 8 bytes are added by the header). Moreover, the connectionless nature of UDP does not introduce communication, processing, or memory overheads due to the establishment and maintenance of TCP connections. \n\nCoAP embeds IoT-oriented features Due to the nature of the opera- tional scenarios in which it is going to be used, CoAP introduces some IoT-oriented features, such as: \n\n\u2022 resource observation \u2022 asynchronous message exchange \u2022 multicast communication. \n\nCoAP URI CoAP URIs use either the coap: or coaps: scheme (Figure 2.6), the lat- ter referring to secure CoAP (CoAPs). CoAPs uses DTLS as a secure transport, similar to HTTP\u2019s use of TLS. The default UDP ports are 5683 for coap: and 5684 for coaps:. \n\ncoap:// example.com :5683 /sensor ?id=1 \n\nscheme \n\nCoAP URI \n\nhost port path query \n\ncoaps:// example.com :5684 /sensor ?id=1 \n\nFigure 2.6 CoAP URI. \n\n2.2 The Internet of Things 39 \n\nCoAP messaging CoAP is based on a request/response communication model. Since CoAP is based on UDP, reliability is not provided by the transport layer. Retransmission may be therefore needed, especially in LoW- PAN, where the physical conditions and radio protocols used may have detrimental e\ufb00ects on communications. CoAP implements reliability internally, and handles these situations by implementing a retransmission and deduplication mechanism. The connectionless nature of UDP results in an asynchronous com- munications model. This means that, unlike connection-based com- munications, request and responses must be matched. CoAP includes \ufb01elds used for request/response matching. CoAP is characterized by two layers, as shown in Figure 2.7: \n\n\u2022 The messaging layer provides support for duplicate detection and (optionally) reliability. \u2022 The requests/responses layer provides support for RESTful interac- tions, through GET, POST, PUT, DELETE methods. \n\nCoAP messages are exchanged between UDP endpoints (the default port is 5683). CoAP messages, as in HTTP, are either requests or responses. All messages include a 16-bit message ID used to detect duplicates and for optional reliability (acknowledgements of received \n\nFigure 2.7 CoAP messaging model. Requests/Responses \n\nRESTful interactions: \n### -\nURIs \n### -\nGET/POST/PUT/DELETE semantics \n\nUDP DTLS \n\nCoAP \n\nMessaging \n\nCommunication over UDP: \n### -\nreliablity/retranmission \n### -\nmessage deduplication \n\n40 2 Standards \n\nmessages). In order to match requests and responses, an 8-bit token \ufb01eld is used. Message IDs and tokens are separate concepts and they actually work \u201corthogonally\u201d. The former is used to detect duplicates of a message due to retransmission that are received by an endpoint; in other words, no two messages can have the same message ID. The latter is used to link and match requests and responses; a response must report the same token as its corresponding request. \n\nReliability The use of UDP, especially in LLNs, might lead to lost messages. Reliability cannot be provided by transport layer (as it would be if TCP were used) and must be ensured at application layer. The de\ufb01nition of CoAP over other reliable transports, such as TCP, TLS, and WebSockets, is a work in progress [8]. In CoAP, reliability is implemented by performing retransmission with exponential back-o\ufb00(timeout is doubled at each retransmission). If the sender of a message does not receive an expected acknowledgement, it resends the message (using the same message ID). A maximum of four retransmissions can be performed. CoAP de\ufb01nes four types of message: \n\n\u2022 CON (con\ufb01rmable): used for messages that must be transmitted reliably; \u2022 NON (non-con\ufb01rmable): used for messages for which reliability is not needed; \u2022 ACK (acknowledgment): used to acknowledge the reception of a CON message; \u2022 RST (reset): used to cancel a reliable transmission. \n\nReliability is achieved thanks to the following rules (also shown in Figure 2.8): \n\nCON [0xabcd] \n\nACK [0xabcd] \n\nclient server \n\nNON [0xabcd] \n\nReliable transmission Unreliable transmission \n\nFigure 2.8 CoAP reliability. \n\n2.2 The Internet of Things 41 \n\n\u2022 When a CON request is sent, an ACK response is required to be sent back to acknowledge the correct reception of the request. \u2022 When a NON request is sent, the response should be returned in a NON message. \u2022 CON messages provide reliability: if no ACK response is returned prior to a retransmission timeout (with exponential back-o\ufb00), the message is retransmitted. \n\nPiggy-backed and separate responses If a CON CoAP request is sent, CoAP responses can be either: piggy-backed, if the server can respond immediately, or separate, if the server cannot respond immediately. With piggy-backed responses, the responses are included in the ACK message that acknowledges the request (implicit acknowl- edgement). With separate responses, the server \ufb01rst sends an ACK message to acknowledge the request; when the data is available, the server sends a CON message containing the response. This is acknowledged by the client with a new ACK message. The two behaviors are shown in Figure 2.9. \n\nCON [0xabcd] GET/light (Token 0x12) \n\nCON [0xabcd] GET/light (Token 0x12) \n\nACK [0xabcd] 2.05 Content (Token 0x12) \u201c1000 lm\u201d CON [0xffff] 2.05 Content (Token 0x12) \u201c1000 lm\u201d \n\nclient server \n\nPiggy-backed response \n\nACK [0xabcd] \n\nclient server \n\nSeparate response \n\nACK [0xffff] \n\nFigure 2.9 Piggyback response and separate responses. \n\n42 2 Standards \n\n0 1 \n\nToken \n\nOptions \n\n1 1 1 1 1 1 1 1 Payload \n\nFigure 2.10 CoAP general message format. \n\nCoAP message format The general structure of a CoAP message is shown in Figure 2.10. A CoAP message is formed by a header and, optionally, a payload. The header\u2019s structure is detailed in Figure 2.11. \n\nVersion Ver (2 bits) speci\ufb01es the protocol version number. The cur- rent version of CoAP sets these bits to 01 mandatorily. \n\nType T (2 bits) speci\ufb01es the type of message. The following values are de\ufb01ned: \n\n0 = CON is used for con\ufb01rmable messages 1 = NON is used for non-con\ufb01rmable messages 2 = ACK is used for acknowledgment messages 3 = RST is used for reset messages. \n\nToken length TKL (4 bits) is the length in bytes of the Token \ufb01eld. Valid values are 0 to 8, while values 9\u201315 are reserved. A value of 0 indicates that the message will not include a token. \n\nCode Code (8 bits) describes the message. The code is divided into a 3-bit class and a 5-bit meaning. The following values are de\ufb01ned for the code: \n\n\u2022 Class 0 (000) identi\ufb01es a request message. \u2022 Class 2 (010) identi\ufb01es a \u201cSuccess\u201d response. \n\n0 1 \n\nclass detail TKL Version T \n\nMessage-ID \n\nFigure 2.11 CoAP message header detail. \n\n44 2 Standards \n\n\u2022 Class 4 (100) identi\ufb01es a \u201cClient error\u201d response (the client should not repeat the request as it will fail again). \u2022 Class 5 (101) identi\ufb01es a \u201cServer error\u201d response (the request failed due to a server error; the client might repeat the request, depending on the failure reason reported by the server). \n\nA simple check on the presence of any bit set to 1 can be performed to determine immediately whether the message is a request or a response. Similarly, a check on the \ufb01rst bit can be performed to determine immediately whether the response was successful or not. Finally, a check on last bit can be performed to determine whether a response refers to a client or a server error. The structure of the code is an example of how CoAP has been designed in order to simplify parsing operations and to take processing load away from smart objects. For requests, the detail is used to indicate the method of the request: \n\n1 = GET 2 = POST 3 = PUT 4 = DELETE. \n\nFor responses, the detail is used to give additional information related to the response. Some examples of response codes are: \n\n\u2022 Success responses: 2.01 Created, 2.02 Deleted, 2.04 Changed, 2.05 Content \u2022 Client error responses: 4.00 Bad Request, 4.02 Bad Option, 4.04 Not Found, 4.05 Method Not Allowed, \u2026 \u2022 Server error responses: 5.00 Internal Server Error, 5.01 Not Imple- mented, \u2026 \n\nMessage-ID Message-ID (16 bits) is the message identi\ufb01er used to detect duplicates and for optional reliability. \n\nToken (optional) Token (TKL bits) is the message token. It is used to match responses to requests independently from the underlying mes- sages. The length in bytes is speci\ufb01ed in the TKL \ufb01eld. This \ufb01eld is optional. If not used, TKL is 0. \n\nCoAP options CoAP request and response semantics are carried in CoAP messages. Required and optional information for all messages, \n\n2.2 The Internet of Things 45 \n\nsuch as the URI and payload media type, are carried as CoAP options. Options have the same role as in HTTP headers. Table 2.1 shows all the options de\ufb01ned in the CoAP speci\ufb01cation. CoAP de\ufb01nes a number of options that can be included in a message. These options are encoded as TLV (type-length-value). Each option speci\ufb01es the option number of the CoAP option (registered on the IANA registry), the option length, and the option value. In order to maximize compactness, options are encoded in a very size-e\ufb03cient way, called delta encoding. According to delta encoding, options are sorted in ascending order of their number. Instead of the actual option number, an option delta (4 bits) is reported; that is, the option number is calculated as a delta from the preceding option. The option number can be calculated by simply summing all the option delta values of the current option and all previous ones. Since the option delta is 4 bits long, the maximum delta between two consecutive options is 15 at most. In order to support bigger deltas \n\nTable 2.1 CoAP options. \n\nOption number Option name Format Length (bits) \n\n1 If-Match opaque 0\u20138 \n\n3 Uri-Host string 1\u2013255 \n\n4 ETag opaque 1\u20138 \n\n5 If-None-Match empty 0 \n\n7 Uri-Port uint 0\u20132 \n\n8 Location-Path string 0\u2013255 \n\n11 Uri-Path string 0\u2013255 \n\n12 Content-Format uint 0\u20132 \n\n14 Max-Age uint 0\u20134 \n\n15 Uri-Query string 0\u2013255 \n\n17 Accept uint 0\u20132 \n\n20 Location-Query string 0\u2013255 \n\n35 Proxy-Uri string 1\u20131034 \n\n39 Proxy-Scheme string 1\u2013255 \n\n60 Size1 uint 0\u20134 \n\n46 2 Standards \n\nbetween options, an extended option delta is used. An extended delta adds 1 or 2 bytes after the option length, depending on the value of the option delta. The option delta can have the following values: \n\n\u2022 0 to 12 (no extended option); \u2022 13 (extended option): the value of the option ranges from 13 to 268 \u2013 1 byte for extended delta is added after option length; \u2022 14 (extended option): the value of the option ranges from 269 to 65804 \u2013 2 bytes for extended are added delta after option length. \n\nIf option delta is 13, 1 byte is used for the extended delta. The actual option number is calculated as (13 + value of extended delta). Since there is 1 byte added for the delta, the maximum option number is 13 + 255 = 268. If the option delta is 14, 2 bytes are used for the extended delta. The actual option number is calculated as (269 + value of extended delta). Since there are 2 bytes added for the delta, the maximum option number is 268 + 65,536 = 65,804. The use of the extended delta is shown in Figure 2.12. After the option number, the option length (4 bits) is reported. Sim- ilar to the option number, the option length can be 15 at maximum. In order to allow for larger values, an extended option length is used. An extended length adds 1 or 2 bytes after the option length or after the extended delta (if present), depending on the value of the option length. The option length can have the following values: \n\n\u2022 0 to 12 (no extended option); \u2022 13 (extended option): 1 byte for extended length after option length or after extended delta; \u2022 14 (extended option): 2 bytes for extended length after option length or after extended delta. \n\nIf the option length is 13, with 1 byte for extended length, the option length is calculated as (13 + value of extended delta). If option length \n\n1 1 0 1 1 1 1 0 \n\n(b) \n\n(a) \n\nFigure 2.12 CoAP extended option delta with (a) 1 byte and (b) 2 bytes added after the option length. \n\n2.2 The Internet of Things 47 \n\n1 1 0 1 1 1 1 0 \n\n(b) \n\n(a) \n\nFigure 2.13 CoAP extended option length with (a) 1 byte and (b) 2 bytes added after the option length or extended delta. \n\nis 14, with 2 bytes for extended length, the option length is calculated as (269 + value of extended delta). The use of extended length is shown in Figure 2.13. Options can be either repeatable or not. Repeatable options report a delta of 0. The Uri-Host, Uri-Port, Uri-Path, and Uri-Query options are used to specify the target resource of a request to a CoAP origin server. Uri-Path and Uri-Query options are repeatable. The Uri-Host option speci\ufb01es the Internet host of the resource being requested. The Uri-Port option speci\ufb01es the transport layer port number of the resource. Each Uri-Path option speci\ufb01es one segment (segments are separated by a slash) of the absolute path to the resource. Each Uri-Query option speci\ufb01es one argument parameterizing the resource. Figure 2.14 shows how to proceed to create the CoAP options for the CoAP URI coap://example.com/people/123. The Location-Path and Location-Query options together indicate a relative URI that consists either of an absolute path, a query string or both. A combination of these options is included in a 2.01 (Created) response to indicate the location of the resource created as the result of a POST request. The Content-Format option indicates the format of the representa- tion included in the payload. The Accept option can be used to indicate which Content-Format is acceptable to the client. The representation format is a content format identi\ufb01er; that is, a number de\ufb01ned in the CoAP Content Format Registry. Table 2.2 reports the de\ufb01ned content format identi\ufb01ers. \n\nResource observation The state of a resource on a CoAP server can change over time. Clients can get the most recent state in one of two ways: polling or observing. Polling means performing GET requests periodically. This \n\n48 2 Standards \n\nOption Name \n\nUri-Host 3 3 example.com \n\npeople \n\n123 \n\n11 \n\n11 8 \n\n11 \n\nType \n\n00000000 (0) 00000011 (3) 00110001 00110010 00110011 (123) \n\n00001000 (8) 00000110 (6) \n\n00000011 (3) 00001011 (11) 01100101 01111000 01100001 01101101 01110000 01101100 01100101 00101110 01100011 01101111 01101101 (example.com) \n\n01110000 01100101 01101111 01110000 01101100 01100101 (people) \n\nLength Value \n\n0 \n\n6 \n\n3 \n\nUri-Path \n\nUri-Path \n\nOption Number Option Delta Option Value Option Length (bytes) \n\nFigure 2.14 Procedure to construct CoAP message options to target URI coap://example.com/people/123. \n\nTable 2.2 CoAP content formats. \n\nMedia type Encoding Content format identi\ufb01er \n\ntext/plain charset=utf-8 0 \n\napplication/link-format - 40 \n\napplication/xml - 41 \n\napplication/octet-stream - 42 \n\napplication/exi - 47 \n\napplication/json - 50 \n\n2.2 The Internet of Things 49 \n\nObserver Subject \n\nRegistration \n\nNotification \n\nNotification \n\nNotification \n\nFigure 2.15 Observer pattern. \n\nis a typical HTTP pattern. However, polling is ine\ufb03cient for a number of reasons. Resources may not change state between two successive GET requests, thus making some of these requests unnecessary. Since all requests consume energy in the constrained CoAP server, this approach can have negative e\ufb00ects on battery-operated objects. Moreover, if the resource changes its state multiple times between successive GET requests, for some time the client was not aware of the most up-to-date state. The Observe option [9] was introduced to avoid polling (RFC 7641) and to create a more suitable pattern for constrained envi- ronments. The Observe option implements an observer design pattern (Figure 2.15): when included in a GET request, the server is instructed to send noti\ufb01cations to the client whenever the state of the resource changes. This is similar to a pub/sub model, but is intrinsically very di\ufb00erent. The communication is still based on requests and responses (rather than subscriptions and publishers), but multiple responses are sent after a single request. Responses are linked to the request because they report the same token. The Observe option has been assigned the option number 6. Its length can be between 0 and 3 bytes. The option value is an unsigned integer: \n\n\u2022 0 is used for registration (start observing); \u2022 1 is used for deregistration (stop observing); \n\n50 2 Standards \n\n\u2022 other values are used to sort noti\ufb01cations (since UDP is used, noti- \ufb01cations may arrive in the wrong order) or to ignore older noti\ufb01ca- tions if a more up-to-date state has been noti\ufb01ed. \n\nFigure 2.16 shows a typical resource observation. The client per- forms a GET a request for a speci\ufb01c resource and contextually regis- ters itself to the server to receive updates related to resource changes by adding an Observe option with value 0 and a speci\ufb01c token. The server replies with a 2.05 response with the same token and an Observe option value including the representation of the resource in the pay- load. Whenever the state of the resource changes, the server sends another response to the client with the same token and a di\ufb00erent (sub- sequent) Observe option value. When the client stops being interested in updates on the resource, it sends another GET request to the server with the same token but with an Observe option value of 1. The server will reply with a \ufb01nal response and will no longer send updates. The Observe option requires the server to maintain a list of registered clients (endpoint and token) for each resource. This can introduce an overhead on the smart object. Resources are therefore not necessarily observable. The server can mark a resource as observ- able in the CoRE Link Format representation of the link, using an obs attribute. \n\nBlockwise transfers CoAP was designed to achieve minimal overhead. In fact, CoAP mes- sages work well for small payloads. CoAP messages are encapsulated in UDP packets, which have a maximum size of 65536 bytes. How- ever, it might happen that applications need to transfer larger pay- loads. In other cases, constrained servers or clients may not be able to process payloads of arbitrary sizes. Let us think about a smart object with a bu\ufb00er that limits it to accept payloads of 128 bytes, but where 1 kilobyte of data needs to be transferred. Blockwise transfers have been purposedly de\ufb01ned to divide \u201clarge\u201d amounts of data into several chunks of a given size [10]. The meaning of the term \u201clarge\u201d depends on the speci\ufb01c scenario: it may mean larger than a UDP packet or larger than the maximum size of an object\u2019s bu\ufb00er. RFC 7959 de\ufb01nes two new options called Block1 and Block2 for this goal. Block1 and Block2 options provide a minimal way to trans- fer larger representations in a blockwise fashion. The two options are used to convey the necessary information to split a large payload into smaller chunks and to control the transfer of each chunk in such a way that it can be successfully reconstructed at the other endpoint. \n\nClient \n\nServer \n\nResource State \n\nREGISTRATION \n\nDEREGISTRATION \n\n2.05 Content Token: 0xabcd Observe = 8 17 \u00b0C \n\n2.05 Content Token: 0xabcd Observe = 9 18 \u00b0C \n\n2.05 Content Token: 0xabcd Observe = 10 19 \u00b0C \n\n2.05 Content Token: 0xabcd Observe = 11 18 \u00b0C \n\n2.05 Content Token: 0xabcd Observe = 12 19 \u00b0C \n\n2.05 Content Token: 0xabcd Observe = 13 18 \u00b0C \n\nGET Token: 0xabcd Observe = 1 \n\nGET Token: 0xabcd Observe = 0 \n\nFigure 2.16 CoAP resource observation. \n\n52 2 Standards \n\nNUM M SZX \n\nNUM \n\nNUM \n\nM \n\nM \n\nSZX \n\nSZX \n\n1B \n\n2B \n\n3B \n\nFigure 2.17 Anatomy of a Block option value. \n\nBlock1 (option number 27) is related to the request payload and is typically used in conjunction with POST/PUT requests. Block2 (option number 23) is related to the response payload and is typically used in conjunction with GET requests. Clients and servers can also negotiate a block size that can be used for all transfers, using the Size1 and Size2 options. The value of the Block option is variable in size (0 to 3 bytes) and is formed by the following three \ufb01elds, as shown in Figure 2.17: \n\n\u2022 NUM: the relative number of the block within a sequence of blocks with a given size. \u2022 M (1 bit): a \u201cmore\u201d bit, indicating whether more blocks will follow or this is the last block. \u2022 SZX (3 bits): the size exponent of the block; SZX can be a number from 0 to 6, while the value is reserved and cannot be used. The actual size of the block is computed as 24+SZX, which means that blocks can have a size from 24 to 210 bytes. \n\nIn the following examples, the notation 2:0/1/128 means that the message contains a Block2 option, NUM = 0, M = 1, and SZX = log2128 \u22124 = 3. Figure 2.18 shows the use of the Block2 option to perform the block- wise transfer of a resource requested by a client. The client starts by requesting the /status resource on the server by issuing a GET request. The server, in a piggy-backed response, replies with a 2.05 response, which includes a Block2 option, with the values 0/1/128. This means that this is the \ufb01rst block (NUM = 0), another block will follow (M = 1), and that the size of the block is 128 bytes. After receiving the \ufb01rst block, the client performs another request for the next block. To do \n\nClient Server \n\nCON [MID = 1234], GET, /status \n\nACK [MID = 1234], 2.05 Content, 2:0/1/128 \n\nCON [MID = 1235], GET, /status, 2:1/0/128 \n\nACK [MID = 1235], 2.05 Content, 2:1/1/128 \n\nCON [MID = 1236], GET, /status, 2:2/0/128 \n\nACK [MID = 1236], 2.05 Content, 2:2/0/128 \n\nGet the third block \n\nBlock 2/more to come/128 bytes \n\nBlock 3/more to come/up to 128 bytes \n\nBlock 1/more to come/128 bytes \n\nGet the resource \n\nGet the second block \n\nFigure 2.18 Block2 option (response payload) transfer example. \n\n54 2 Standards \n\nso, it includes a Block2 option in the request, specifying the parame- ters of the block: 1/0/128. NUM = 1 means that the requested block is the second. M does not a\ufb00ect the request. The client also asks for a block 128 bytes in size. The server responds in the same way as before, with a Block2 option with value 1/1/128. The client then requests the next block. In this case, the response\u2019s Block2 option has a value of 2/0/128. M = 0 indicates that this is the last block. In this case, the reported size of 128 bytes indicates that the block will be of up to 128 bytes in size. This response terminates the blockwise transfer. Figure 2.19 shows the use of the Block1 option to perform a blockwise transfer of a resource that a client intends to post. The client starts by sending the representation of a /status resource on the server by issuing a PUT request. The request contains a Block1 option, with the values 0/1/128. This means that this is the \ufb01rst block (NUM = 0), another block will follow (M = 1), and that the size of the block is 128 bytes. The server, in a piggy-backed response, replies with a 2.31 response (meaning that it is ready to accept more blocks), which includes a Block1 option, with the values 0/1/128. After sending the \ufb01rst block, the client performs another request to transfer the next block. To do so, it includes a Block1 option in the request, with value 1/1/128. NUM = 1 means that the requested block is the second. M does not a\ufb00ect the request. The client also asks for a block 128 bytes in size. The server responds in the same way as before, with a Block1 option with value 1/1/128. The client then requests the last block, including a Block1 option with value 2/0/128. M = 0 indicates that this is the last block. In this case, the reported size of 128 bytes indicates that the block will be of up to 128 bytes in size. The server sends a 2.04 response, which terminates the blockwise transfer. \n\nMulticast communication CoAP supports multicast, which targets multiple endpoints with a single request. For example, a single POST request targeting a multicast group address, such as POST all.\ufb02oor1.building.example.com/status/lights, can be used to switch on all lights in a building with a single request, rather than requiring a client to issue multiple unicast requests targeting each server (as shown in Figure 2.20). RFC 7390 [11] de\ufb01nes mechanisms to manage CoAP groups. \n\nResource discovery and resource directory Resource discovery is based on discovering links (URIs) to resources hosted by a CoAP service endpoint. CoAP supports resource discov- ery through a standard mechanism based on web linking [12] and \n\nClient Server \n\nCON [MID = 1234], PUT, /options, 1:0/1/128 \n\nACK [MID = 1234], 2.31 Continue, 1:0/1/128 \n\nCON [MID = 1235], PUT, /options, 1:1/1/128 \n\nACK [MID = 1235], 2.31 Continue, 1:1/1/128 \n\nCON [MID = 1236], PUT, /options, 1:2/0/128 \n\nACK [MID = 1236], 2.04 Changed, 1:2/0/128 \n\nSend the third block Block 3/more to come/up to 128 bytes \n\nSend the resource Block 1/more to come/128 bytes \n\nSend the second block Block 2/more to come/128 bytes \n\nFigure 2.19 Block1 option (request payload) transfer example. \n\n\n![Image](/src/assets/generated_images/iot_p70_i0.png)\n\n![Image](/src/assets/generated_images/iot_p70_i1.png)\n\n![Image](/src/assets/generated_images/iot_p70_i2.png)\n\n![Image](/src/assets/generated_images/iot_p70_i3.png)\n\n![Image](/src/assets/generated_images/iot_p70_i4.png)\n56 2 Standards \n\n\n\n\n\n\n\n\n\n\n\nCoAP client \n\nFigure 2.20 CoAP group communication. \n\nClient Server \n\nGET coap://[ff02::1]/.well-known/core \n\n2.05 Content Content-Format: application/link-format \n\n</sensors/temp>;ct=50;rt=\"temperature-C\";if=\"sensor\", </actuators/light>;ct=50;rt=\"light\";if=\"toggle\" \n\nFigure 2.21 Resource discovery in CoAP. \n\nthe CoRE Link Format [13]. A client can issue a request for the /.well-known/core path on a server (or targeting a CoAP multicast group) and receive a list of available resources on the endpoint, formatted in CoRE Link Format (Figure 2.21). Each link contains a list of attributes that describe the resource being linked (e.g., obs means observable; rt indicates the resource type; ct indicates the content type). The if attribute de\ufb01nes the set of methods that the resource accepts (CoRE interface). More details on CoRE Link Format and CoRE interfaces can be found in Sections 3.9.1 and 3.9.2, respectively. Sometimes direct discovery of resources through /.well-known/core is not feasible. For instance, nodes may be sleeping or multicast tra\ufb03c may be ine\ufb03cient. In order to simplify the task of resource discovery, a resource directory (RD) can be used. An RD is a CoAP endpoint \n\n\n![Image](/src/assets/generated_images/iot_p71_i0.png)\n2.2 The Internet of Things 57 \n\n\nThe Internet \n\nServer \n\nServer \n\nProxy \n\nC \n\nC \n\nC \n\nC \n\nCoAP \n\nCoAP CoAP \n\nCoAP \n\nClient HTTP \n\nHTTP \n\nConstrained Environments \n\nC \n\nFigure 2.22 HTTP-to-CoAP proxying. \n\nthat can be used as a registry to register, maintain, lookup and remove resource descriptions [14]. It is a centralized registry that contains CoRE links to resources hosted on several endpoints. The RD supports a function set for adding, updating, and removing links and a function set for lookup operations. The RD can be queried to \ufb01lter results on the basis of speci\ufb01c attributes (say, a speci\ufb01c resource type). \n\nHTTP/CoAP proxying There are several reasons that motivate the use of HTTP/CoAP prox- ying functionalities. Figure 2.22 shows a complex hybrid Internet/IoT scenario with smart objects in constrained environments interacting with traditional hosts on the Internet. This scenario involves the use of di\ufb00erent application protocols, such as HTTP and CoAP. Direct CoAP communication might occur, but not all traditional Internet clients may support CoAP or be aware of the fact that a particular resource resides in a constrained network. In order to allow the necessary cross-protocol communication, an intermediate proxy node must be introduced. Other motivations for the introduction of this network element are: \n\n\u2022 to shield the constrained network from the outside, say for security reasons such as protection against DoS attacks; \u2022 to support integration with the existing web through legacy HTTP clients; \u2022 to ensure high availability on resources through caching; \u2022 to reduce network load; \n\n58 2 Standards \n\n\u2022 to support data formats that might not be suitable for constrained applications, such as XML. \n\nRFC 7252 de\ufb01nes the following terms: \n\n\u2022 origin server: a CoAP server on which a given resource resides or is to be created (see Figure 2.23a); \u2022 intermediary: a CoAP endpoint that acts both as a server and as a client towards an origin server (see Figure 2.23b); \u2022 proxy: an intermediary that forwards requests and relays back responses; it can perform caching and protocol translation (e.g. HTTP-to-CoAP) (see Figure 2.23c); \u2022 CoAP-to-CoAP proxy: a proxy that maps a CoAP request to another one; \u2022 cross-proxy: a proxy that performs protocol translation from/to CoAP to/from another protocol, such as HTTP; \u2022 HTTP-to-CoAP proxy: a proxy that translates HTTP requests to CoAP requests (Figure 2.23d). \n\nC OS \n\nPOST \n\nPOST \n\nC OS \n\nPOST \n\nI \n\nPOST \n\nC OS \n\nGET 1 \n\nP \n\nGET 1 \n\nC \n\nGET 2 2.05 2.05 \n\n2.05 \n\nCACHE \n\nC OS \n\nPOST \n\nP \n\nPOST \n\nHTTP CoAP \n\n(a) \n\n(b) \n\n(c) \n\n(d) \n\nFigure 2.23 (a) Direct endpoint communication to origin server; (b) communica- tion through intermediary node; (c) proxy- based communication. (d) HTTP-to- CoAP proxy. \n\n2.2 The Internet of Things 59 \n\nA HTTP-to-CoAP proxy can thus be used to allow incoming HTTP request generated by HTTP clients to be translated into CoAP requests that can be forwarded and served by CoAP servers. A reverse translation is then required, allowing CoAP responses to be trans- formed into HTTP responses that can be sent back to the client. CoAP has been de\ufb01ned with the goal of mapping to HTTP easily, allowing easy integration with the web. CoAP-to-HTTP translation is fairly straightforward, as CoAP is a logical subset of HTTP. CoAP methods, response codes, and options have many similarities to HTTP. RFC 8075 [15] de\ufb01nes rules for mapping HTTP messages to CoAP messages. These rules apply to URI mappings, request method map- pings, response code mappings, and HTTP header to CoAP option mappings. \n\nURI mapping HTTP-to-CoAP URI mapping is based on URI encap- sulation (a CoAP URI is included in an HTTP URI), as shown in Figure 2.24. \n\nRequest method mapping Some HTTP methods and CoAP methods are easily mapped: \n\n\u2022 HTTP GET \u21d4CoAP GET. \u2022 HTTP POST \u21d4CoAP POST. \u2022 HTTP PUT \u21d4CoAP PUT. \u2022 HTTP DELETE \u21d4CoAP DELETE. \n\nOther HTTP methods cannot be mapped. \n\nh t t p : / / p . e x a m p l e . c o m / h c / c o a p : / / s . e x a m p l e . c o m / l i g h t \n\nHTTP proxy URI CoAP resource URI \n\nHTTP client \n\nCoAP server HTTP server \n\nCoAP client \n\nHTTP-to-CoAP proxy \n\ncoap://s.example.com/light \n\nhttp://p.example.com/hc \n\nFigure 2.24 HTTP-to-CoAP URI mapping. \n\n60 2 Standards \n\nTable 2.3 HTTP/CoAP response code mappings. \n\nCoAP response code HTTP status code \n\n2.01 Created 201 Created \n\n2.02 Deleted 200 OK \n\n204 No Content \n\n2.03 Valid 304 Not Modi\ufb01ed \n\n200 OK \n\n2.04 Changed 200 OK \n\n204 No Content \n\n2.05 Content 200 OK \n\n4.00 Bad Request 400 Bad Request \n\n4.02 Bad Option 400 Bad Request \n\n4.04 Not Found 404 Not Found \n\n4.05 Method Not Allowed 405 Method Not Allowed \n\n5.00 Internal Server Error 500 Internal Server Error \n\n5.01 Not Implemented 501 Not Implemented \n\n5.02 Bad Gateway 502 Bad Gateway \n\nResponse code mapping Table 2.3 shows the mapping between CoAP response codes and HTTP response codes. \n\nOpen issues The following are some questions related to protocol mapping that derive from the di\ufb00erent natures of HTTP and CoAP: \n\n\u2022 What HTTP features are not present in CoAP and vice versa \u2022 How can HTTP methods that do not exist in CoAP be mapped (e.g., HEAD, OPTIONS)? \u2022 What are resource observations in HTTP? \u2022 What are group communications in HTTP? \n\n2.2.5.2 CoSIP Protocol Speci\ufb01cation There are many applications in both constrained and non-constrained environments that feature non-request/response communication models. Some of these applications require the creation and man- agement of a \u201csession\u201d, a term that we use to refer to any exchange of data between an association of participants. For two participants, \n\n2.2 The Internet of Things 61 \n\nthe session may involve the sending of one or (probably) more data packets from one participant to the other, in one or both directions. Unidirectional sessions may be initiated by either the sender or the receiver. Examples of sessions in IoT scenarios may be the data \ufb02ow generated by a sensor (measurement samples) and sent to recipient for further processing, or data streams exchanged by two interacting toys. Although in principle CoAP encapsulation could also be used for carrying data in a non-request/response fashion, for example by using the CoAP POST request in non-con\ufb01rmable mode, or by using the CoAP \u201cobservation\u201d model, it is evident that it would be much more e\ufb03cient to set up a session between constrained nodes \ufb01rst, and then perform a more lightweight communication without carrying unnec- essary CoAP header \ufb01elds for each data packet. The data communica- tion would be in accord with the network, transport, and application parameters negotiated during the session setup. Session Initiation Protocol (SIP) is the standard application protocol for establishing application-level sessions [5]. It allows the endpoints to create, modify, and terminate any kind of (multi)media session: VoIP calls, multimedia conferences, or data communication. Once a session has been established, the media are typically transmitted using other application-layer protocols, such as RTP and RTCP [16], or as raw UDP data, directly between the endpoints, in a peer-to-peer fashion. SIP is a text protocol, similar to HTTP, which can run on top of several transport protocols, such as UDP (default), TCP, or SCTP, or on top of secure transport protocols such as TLS and DTLS. Session parameters are exchanged as SIP message payloads; a standard protocol used for this purpose is the session description protocol [17]. The SIP protocol also supports intermediate network elements, which are used to allow endpoint registration and session establishment. Examples include SIP proxy servers and registrar servers. SIP also de\ufb01nes the concepts of transaction, dialog, and call as groups of related messages, at di\ufb00erent abstraction layers. Although SIP has been de\ufb01ned for Internet applications, we may imagine also using it in constrained IoT scenarios. Note that SIP already includes mechanisms for subscribe/notify communication paradigms [18] and for resource directories, which are particularly useful in IoT scenarios, and for which proper CoAP extensions are currently being speci\ufb01ed [9, 14]. The main drawback of using the standard SIP protocol in con- strained environments is the large size of text-based SIP messages \n\n62 2 Standards \n\n(compared to other binary protocols such CoAP), and the processing load required for parsing such messages. A constrained version of SIP, named \u201cCoSIP\u201d, designed to allow constrained devices to instantiate communication sessions in a lightweight and standardized fashion and can be adopted in M2M application scenarios, has been proposed. Session instantiation can include a negotiation phase, in which the parameters that will be used for all subsequent communication are agreed. As proposed, CoSIP is a binary protocol, which maps to SIP, just as CoAP does to HTTP. CoSIP can be adopted in various application scenarios, such as service discovery and pub/sub applications. \n\nRelated work on session initiation Smart objects are typically required to operate using low-power and low-rate communication methods, featuring unstable (lossy) links, such as IEEE 802.15.4. These are usually termed low-power wireless personal area networks (LoWPANs) or low-power and lossy networks (LLNs). The Internet Engineering Task Force (IETF) has set up several working groups in order to address issues related to bringing IP connectivity to LoWPAN smart objects. In particular, the 6LoWPAN (IPv6 over Low-power WPAN) working group [19] was chartered to de\ufb01ne mechanisms to optimize the adoption of IPv6 in LoWPANs and the ROLL (Routing over Low-power and Lossy Networks) working group [20] was formed to develop optimal IPv6 routing in LLNs. Finally, the CoRE (Constrained RESTful Environ- ments) working group [21] was chartered to provide a framework for RESTful applications in constrained IP networks. It is working on the de\ufb01nition of a standard application-level protocol, namely CoAP, which can be used to let constrained devices communicate with any node, either on the same network or on the Internet, and provides a mapping to HTTP REST APIs. CoAP is intended to provide, among others, create-read-update-delete (CRUD) primitives for resources of constrained devices and pub/sub communication capabilities. While the work on CoAP is already at an advanced stage, the CoRE working group is also investigating mechanisms for discovery and con\ufb01guration, but work on these issues is still at an early stage and therefore open to proposals. The \u201cobserver\u201d CoAP extension [9] allows CoAP clients to observe resources (via a subscribe/notify mechanism) and to be noti\ufb01ed when the state of the observed resource changes. This approach requires \n\n2.2 The Internet of Things 63 \n\nthe introduction of a new CoAP Observe option to be used in GET requests in order to let the client register its interest in the resource. The server will then send \u201cunsolicited\u201d responses back to the client, echoing the token it speci\ufb01ed in the GET request and reporting an Observe option with a sequence number used for reordering purposes. As we will describe later, we envision that the instantiation of a ses- sion could signi\ufb01cantly reduce the number of transmitted bytes, since, after the session has been established, only the payloads need be sent to the observer, thus eliminating the overhead due to the inclusion of the CoAP headers in each noti\ufb01cation message. As for service discovery, the CoRE working group has de\ufb01ned a mechanism, called a resource directory (RD) [14], to be adopted in M2M applications. An RD is necessary because of the impracticality of direct resource discovery, due to the presence of duty-cycled nodes and unstable links in LLNs. Each CoAP server must expose an interface /.well-known/ core to which a client can send requests for discovering available resources. The CoAP server will reply with the list of resources and, for each resource, an attribute that speci\ufb01es the format of the data associated with it. The CoAP protocol, however, does not specify how a node joining the network for the \ufb01rst time must behave in order to announce itself to the RD node. In RFC 7390 [11], this functionality is extended to multicast communications. In particular, multicast resource discovery is useful when a client needs to locate a resource within a limited, local scope, and that scope supports IP multicast. A GET request to the multicast address speci\ufb01ed by the standard is made for /.well-known/core. Of course multicast resource discovery works only within an IP multicast domain and does not scale to larger networks that do not support end-to-end multicast. The registration of a resource in the RD is performed by sending a POST request to it. Discovery can be accomplished by issuing a GET request to the RD, targeting the .well-known/core URI. This dis- covery mechanism is totally self-contained in CoAP as it uses only CoAP messages. The CoSIP protocol provides an alternative mechanism to register resources on an RD, which may also be called a CoSIP registrar server. The advantage of using a CoSIP-based registration mechanism is that it might be possible to register resources other than those reachable through CoAP, thus providing a scalable and generic mechanism for \n\n64 2 Standards \n\nservice discovery in constrained applications with a higher degree of expressiveness, such as setting an expiration time for the registration. \n\nCoSIP In both constrained and non-constrained environments, there are many applications in which it may either be necessary or simply advantageous to negotiate an end-to-end data session. In this case the communication model consists of a \ufb01rst phase in which one endpoint requests the establishment of a data communication and, optionally, both endpoints negotiate communication parameters (transfer protocols, data formats, endpoint IP addresses and ports, encryption algorithms and keying materials, and other application speci\ufb01c parameters) of the subsequent data sessions. This may be useful for both client-server and peer-to-peer applications, regardless of whether the data sessions evolve according to a request/response model. The main advantage is that all such parameters, including possible resource addressing, may be exchanged in advance, while no such control information is required during data transfer. The longer the data sessions, the more advantageous this approach is compared to per-message control information. In addition, for data sessions that may vary in format or other parameters over time, such changes may be supported by performing session renegotiation. A standard way to achieve all this in an IP-based network is by using SIP [5]. SIP has been de\ufb01ned as a standard protocol for initiating, modifying and tearing down any type of end-to-end multimedia session. It is independent of the protocol used for data transfer and from the protocol used for negotiating the data transfer (such a negotiation protocol can be encapsulated transparently within the SIP exchange). In order to simplify the implementation, SIP reuses the message format and protocol \ufb01elds of HTTP. However, in contrast to HTTP, SIP works by default on UDP, by directly implementing all mechanisms for a reliable transaction-based message transfer. This is an advantage in duty-cycled constrained environments, where prob- lems may arise when trying to use connection-oriented transports, such as TCP. However, SIP may also run on other transport protocols, such as TCP, SCTP, TLS, or DTLS. Unfortunately, SIP derives from HTTP the text-based protocol syntax that, even if it simpli\ufb01es the implementation and debugging, results in larger message sizes and bigger processing costs and probably with larger source code sizes (RAM footprint) required for \n\n2.2 The Internet of Things 65 \n\nmessage parsing. Note that the SIP standard also de\ufb01nes a mechanism for reducing the overall size of SIP messages; this is achieved by using a compact form of some common header \ufb01eld names. However, although this allows for a partial reduction of the message size, it may still result in big messages, especially when compared to other binary formats, for example those de\ufb01ned for CoAP. For this reason we have tried to de\ufb01ne and implement a new binary format for SIP in order to take advantages of the functionalities already de\ufb01ned and supported by SIP methods and functions, together with a very compact message encoding. We naturally called such new pro- tocol CoSIP, standing for Constrained Session Initiation Protocol, or simply Constrained SIP. Due to the protocol similarities between SIP and HTTP, in order to maximize the reuse of protocol de\ufb01nitions and source code implementations, we decided to base CoSIP on the same message format as de\ufb01ned for CoAP, thanks to the role that CoAP plays with respect to HTTP. However, it is important to note that, while CoAP must de\ufb01ne new message exchanges, mainly due to the fact that it has to operate in constrained and unreliable network scenarios over the UDP transport protocol, and while HTTP works over TCP, CoSIP completely reuses all of the SIP message exchanges and transactions already de\ufb01ned by the SIP standard, since SIP already works over unre- liable transport protocols such as UDP. SIP is structured as a layered protocol. At the top there is the concept of dialog: a peer-to-peer relationship between two SIP nodes that persists for some time and facilitates sequencing of di\ufb00erent request\u2013response exchanges (transactions). In CoAP there is no concept equivalent to SIP dialogs, and, if needed, it has to be explicitly implemented at application level. Under the dialog there is the transaction layer: the message exchange that comprises a client request, the ensuing optional server provisional responses and the server\u2019s \ufb01nal response. The concept of a transaction is also present in CoAP: requests and responses are bound and matched through a token present in the message header \ufb01eld. Under the transaction there is the messaging layer where messages are e\ufb00ectively formatted and sent through an underlying non-SIP transport protocol (such as UDP or TCP). Instead of completely re-designing a session initiation protocol for constrained environments, we propose to reuse SIP\u2019s lay- ered architecture, by simply re-de\ufb01ning the messaging layer in a constrained-oriented binary encoding. To this end, we propose to \n\n66 2 Standards \n\n0 Ver =1 Type =1 TKL =0 \n\n2 4 8 \n\nCode \n\nOptions \n\nPayload \n\n1 1 1 1 1 1 1 1 \n\nMessage ID \n\n16 31 \n\nFigure 2.25 CoSIP message format. \n\nreuse the same CoAP message syntax [7]. Figure 2.25 shows the CoSIP message format derived from CoAP. A CoSIP message contains, in sequence: \n\n\u2022 the 2-bit version \ufb01eld (set to 1, i.e. CoSIP version 1); \u2022 the 2-bit type \ufb01eld (set to 1 = Non-con\ufb01rmable); \u2022 the 4-bit CoAP TKL \ufb01eld (set to 0); \u2022 the 8-bit Code \ufb01eld that encodes request methods (for request messages) and response codes (for response messages); \u2022 the 16-bit CoAP message ID \ufb01eld; \n\npossibly followed by by more option \ufb01elds. If a CoSIP message body is present, as in CoAP it is appended after the options \ufb01eld, pre\ufb01xed by an 1-byte marker (0xFF) that separates CoSIP header and payload. Options are encoded, as in CoAP, in Type-Length-Value (TLV) format and encode all CoSIP header \ufb01elds (From, Via, Call-ID, etc.) included in the CoSIP message. Since CoSIP re-uses the transaction layer of SIP, no CoAP optional Token \ufb01eld is needed [7] and the TKL (Token length) \ufb01eld can be permanently set to 0. Moreover, since CoSIP already has reliable mes- sage transmission (within the transaction layer), no Con\ufb01rmable (0), Acknowledgement (2), or Reset (3) message types are needed, and the only type of message that must be supported is Non-con\ufb01rmable (1). A comparison of the layered architectures of CoSIP and SIP is shown in Figure 2.26. Besides the above binary message, a CoSIP message can be virtu- ally seen as a standard SIP message, formed by one request-line or one \n\n\n![Image](/src/assets/generated_images/iot_p81_i0.png)\n2.2 The Internet of Things 67 \n\n\n(a) (b) \n\nFigure 2.26 Comparison of the layered architectures of: (a) SIP and (b) CoSIP. \n\nstatus-line (depending if the message is a request or a response), fol- lowed by a sequence of SIP header \ufb01elds, followed by a message body, if preset. In particular, SIP header \ufb01elds are logically the same as in the standard SIP protocol, but encoded in the corresponding CoSIP Options. For each SIP header \ufb01eld, a di\ufb00erent option number has been set, and a suitable encoding mechanism has been de\ufb01ned. In particular, general rules that we followed are: \n\n\u2022 IP addresses are encoded as a sequence of 5 bytes for IPv4 and 17 bytes for IPv6, where the \ufb01rst byte discriminates the type of address, i.e. 1 = IPv4 address, 2 = IPv6 address, 3 = FQDN (fully quali\ufb01ed domain name). \u2022 For header \ufb01eld parameters, when possible, the parameter name is implicitly identi\ufb01ed by the position of its value in the correspond- ing binary-encoded CoSIP option; otherwise, parameter names are substituted by parameter codes. In the latter case the parameter is encoded as type-value pair (for \ufb01xed size values) or type-length-vale tuples (for variable size values). \u2022 Random tokens, such as SIP \u201cbranch\u201d values, SIP \u201cfrom\u201d and \u201cto\u201d tags, \u201ccall-id\u201d, etc. are generated as arrays of a maximum 6 bytes. \n\nOne problem in reusing the current CoAP message format [7] is that in CoAP the 8-bit code \ufb01eld is used to encode all possible request methods and response codes. In particular, in CoAP, for response mes- sages, the 8-bit code \ufb01eld is divided into two sub\ufb01elds: \n\n\u2022 the \ufb01rst three bits (class) encodes the CoAP response classes 2xx (Success), 4xx (Client error), and 5 (Server error); \n\n68 2 Standards \n\n\u2022 the remaining 5 bits (details) encode the sub-type of the response within a given class type. For example a 403 \u201cForbidden\u201d response is encoded as 4 (class) and 03 (details). \n\nUnfortunately, this method limits the number of possible response codes that can be used (for example, using only 5 bits for the details sub\ufb01eld does not allow the direct encoding of response codes such as 480 \u201cTemporarily unavailable\u201d or 488 \u201cNot acceptable here\u201d). In CoSIP, we overcome this problem by encoding within the code \ufb01eld only the response class (2xx, 4xx, etc.) and by adding an explicit option \ufb01eld, called response-code, which encodes the complete response code (e.g. 488), including the response sub-type (88, in the case of response code 488). The size of the response-code option is 2 bytes. Moreover, in order to support all SIP/CoSIP response codes we also added the classes 1xx (Provisional) and 3xx (Redirect) used in SIP. \n\nIoT application scenarios In this section, we will describe the most signi\ufb01cant IoT applications, in order to provide an overview of the capabilities and typical usage of the CoSIP protocol. In all the scenarios, we consider a network ele- ment called an IoT gateway, which includes also a HTTP/CoAP proxy that can be used by nodes residing outside the constrained network to access CoAP services. \n\nCoAP service discovery CoSIP allows smart objects to register the ser- vices they provide to populate a CoSIP registrar server, which serves as an RD. The term registrar server is interchangeable with RD here. Figure 2.27 shows a complete service registration and discovery scenario enabled by CoSIP. We consider a smart object that includes a CoAP server, which provides one or more RESTful services, and a CoSIP agent, which is used to interact with the CoSIP registrar server. The smart object issues a REGISTER request (a), which includes reg- istration parameters, such as the address of record (AoR) of the CoAP service and the actual URL that can be used to access the resource (contact address). Note that, while the original SIP speci\ufb01cation states that the To header must report a SIP or SIPS URI, CoSIP allows any scheme URI to be speci\ufb01ed in the To header, for example a CoAP URI. Upon receiving the registration request, the registrar server stores the AoR-to-contact address mapping in a location database and then sends a 200 OK response. \n\n\n![Image](/src/assets/generated_images/iot_p83_i0.png)\n2.2 The Internet of Things 69 \n\n\nFigure 2.27 CoAP service discovery. The numbers indicate the order of exchanged messages. \n\nWhen a REST client, either CoAP or HTTP, is willing to discover the services, it can issue a GET request targeting the .well-known/ core URI, which is used as a default entry point to retrieve the resources hosted by the RD, as de\ufb01ned in RFC 6690 [13]. The GET request is sent to the HTTP/CoAP proxy, which returns a 200 OK response (in the case of HTTP) or a 2.05 Content response containing the list of services in the payload (in the case of CoAP). \n\nSession establishment A session is established when two endpoints need to exchange data. CoSIP allows the establishment of session in a standard way without binding the session establishment method to a speci\ufb01c session protocol. For instance, CoSIP can be used to negoti- ate and instantiate a RTP session between constrained nodes. Once a session has been established, the data exchange between the endpoints occurs (logically) in a peer-to-peer fashion. Figure 2.28 shows how CoSIP can be used to establish a session between two endpoints. Let us assume an IoT agent (IoT-A1) iden- ti\ufb01ed by the CoSIP URI cosip:user1@domain, and which includes at least a CoSIP agent, has registered its contact address to an IoT gateway in the same way as described in the previous subsec- tion, on CoAP service discovery (steps 1 and 2). If another IoT-A2 cosip:user2@domain wants to establish a session with IoT-A1, it will send a suitable INVITE request to the IoT gateway, which will act as \n\n\n![Image](/src/assets/generated_images/iot_p84_i0.png)\n70 2 Standards \n\n\nFigure 2.28 CoSIP session establishment. \n\na CoSIP proxy, relaying the request to IoT-A1 (steps 3 and 4). IoT-A1 will then send a 200 OK response to IoT-A2 (steps 5 and 6), which will \ufb01nalize the session creation by sending an ACK message to IoT-A2 (steps 7 and 8). At this point the session has been set up and data \ufb02ow between IoT-A1 and IoT-A2 can occur directly. The session establishment pro- cess can be used to negotiate communication parameters, for instance by encapsulating Session Description Protocol (SDP) [17] or an equiv- alent in the message payload. As we will show in the protocol evalua- tion section below, setting up a session, rather than using CoAP, both in a request/response or subscribe/notify paradigm, is a very e\ufb03cient way to avoid the overhead due to carrying headers in each exchanged message, since eventually only the payloads will be relevant for the application. \n\nSubscribe/notify applications IoT scenarios typically involve smart objects, which may well be battery-powered. It is crucial to adopt energy-e\ufb03cient paradigms for OS tasks, application processing, and communication. In order to minimize the power consumed, duty-cycled smart objects are used. Sleepy nodes, especially those operating in LLNs, are not guaranteed to be reachable, so it is more appropriate for smart objects to use a subscribe/notify (pub/sub) approach to send noti\ufb01cations regarding the state of their resources, rather than receiving and serving incoming requests. Such behavior \n\n\n![Image](/src/assets/generated_images/iot_p85_i0.png)\n2.2 The Internet of Things 71 \n\n\nFigure 2.29 Subscribe/notify applications with CoSIP. \n\ncan be achieved by leveraging on the inherent capabilities of SIP, and therefore of CoSIP, as sketched in Figure 2.29. The depicted scenarios consider several pub/sub interactions: noti\ufb01- cations can be sent either by a noti\ufb01er IoT agent (IoT-AN) or by an IoT gateway, and subscribers can be either subscriber IoT agents (IoT-AS), IoT gateways, or generic remote subscribers. Let us assume that all the noti\ufb01ers have previously registered with their CoSIP registrar server (this step is also called the publishing phase in a typical pub/sub scenario). The standard subscription/noti\ufb01cation procedure is the following: \n\n1) The subscriber sends a SUBSCRIBE request to the noti\ufb01er, also specifying the service events it is interested in. 2) The noti\ufb01er stores the subscriber\u2019s URI and event information and sends a 200 OK response to the subscriber. 3) Whenever the noti\ufb01er\u2019s state changes, it sends a NOTIFY request to the subscriber. 4) The subscriber sends a 200 OK response back to the noti\ufb01er. \n\nFigure 2.29 reports all the use cases when pub/sub might be used. An IoT-AS can subscribe to the service of an IoT-AN in the same network, if it is willing to perform some task, such as data/service aggregation. The IoT gateway can subscribe to an IoT-AN in order to collect sensed data, say to store them in the cloud, without the need \n\n72 2 Standards \n\nto periodically poll for data. Finally, the IoT gateway itself might be a noti\ufb01er for remote subscribers that are interested in noti\ufb01cations for speci\ufb01c services provided by the gateway, which may or may not be the same of existing IoT-AN nodes managed by the gateway. Note that, it might be possible to have interactions with legacy SIP agents if the IoT gateway is also able to perform SIP/CoSIP proxying. The adoption of CoSIP in IoT scenarios makes it easy to set up e\ufb03cient pub/sub-based applications in a standard way, thus allowing for seamless integration and interaction with the Internet. Moreover, the valuable experience gained in recent years with SIP, both in terms of technologies and implementation, can be reused to speed up the implementation and deployment of session-based applications. \n\nProtocol evaluation In order to evaluate the performance of CoSIP, an implementation of the protocol has been developed together with some test applications. We decided to focus on network performance as a metric by measur- ing the amount of network tra\ufb03c generated by the test applications. The CoSIP protocol was implemented in Java, because of its simplicity, cross-platform support, and the existence and availability of SIP and CoAP libraries [22\u201324]. The source code of the CoSIP implementation is freely available [25\u201327]. The results show that there are many advantages to using CoSIP, both in constrained and non-constrained applications. The \ufb01rst eval- uation compares CoSIP and SIP in terms of bytes transmitted for the signaling related to the instantiation and termination of a session. Each CoSIP request and response message is separately compared with its SIP counterpart. The results are illustrated in Figure 2.30. Table 2.4 shows the compression ratio for each CoSIP/SIP message pair. Regard- ing the session as a whole, CoSIP yields an overall compression ratio of slightly more than 0.55. Another evaluation showed the advantage of using sessions in constrained applications. Figure 2.31 shows the amount of network tra\ufb03c (in bytes) generated by two constrained applications: the \ufb01rst application uses CoSIP to establish a session and then performs the data exchange by sending the payloads over UDP; the second is a standard CoAP-based application where the communication occurs between a CoAP client and a CoAP server, using con\ufb01rmed CoAP POST requests. In both cases data is sent at the same rate of one data message every 2s. The \ufb01gure shows that the lightweight CoSIP session \n\n\n![Image](/src/assets/generated_images/iot_p87_i0.png)\n2.2 The Internet of Things 73 \n\n\n600 \n\n500 \n\n400 \n\n300 \n\nMessage Size [Bytes] \n\n200 \n\n100 \n\n0 INVITE 100 Trying 180 Ringing 200 OK Session Message \n\nACK BYE 200 OK \n\nCoSIP session SIP session \n\nFigure 2.30 Transmitted bytes for CoSIP and SIP session (signaling only). \n\nTable 2.4 Comparison between CoSIP and SIP signaling (bytes per message) for session instantiation and establishment. \n\nMessage type CoSIP (bytes) SIP (bytes) Compression Ratio \n\nINVITE 311 579 0.537 \n\n100 Trying 141 279 0.505 \n\n180 Ringing 173 372 0.465 \n\n200 OK 293 508 0.577 \n\nACK 216 363 0.595 \n\nBYE 183 309 0.592 \n\n200 OK 162 274 0.591 \n\nis instantiated in a very short period of time and, after the session has been established, few bytes are exchanged between the endpoints. On the other hand, the CoAP-based application has no overhead at the beginning due to the instantiation of the session but, soon afterwards, the amount of tra\ufb03c generated by the application exceeds that of the \n\n\n![Image](/src/assets/generated_images/iot_p88_i0.png)\n74 2 Standards \n\n\n1600 \n\nCoAP \n\nCoSIP \n\n1400 \n\n1200 \n\n1000 \n\n800 \n\nTransmitted Bytes \n\n600 \n\n400 \n\n200 \n\n0 0 50 100 Time [s] 150 \n\nFigure 2.31 Transmitted bytes in a CoSIP session vs. CoAP con\ufb01rmed POST requests and responses. \n\nCoSIP-based application, since in the CoAP-based scenario, data is exchanged within CoAP messages, resulting in an unnecessary CoAP overhead. Note that in the depicted scenario the CoSIP signaling used for ses- sion initiation includes all SIP header \ufb01elds normally used in stan- dard non-constrained SIP applications; that is, no reduction in term of header \ufb01elds has been performed. Instead, for the CoAP application, we considered only mandatory CoAP header \ufb01elds, resulting in the best-case scenario for CoAP in terms of CoAP overhead (minimum overhead). This means that in other CoAP applications, the slope of the line could become even steeper, thus reducing the time when the break-even point with CoSIP is reached. \n\nConclusions Here we have introduced a low-power protocol called CoSIP, for establishing sessions between two or more endpoints targeting constrained environments. Many applications, both in constrained and non-constrained scenarios, do bene\ufb01t from establishing a session \n\n2.2 The Internet of Things 75 \n\nbetween the participants in order to minimize the communication overhead and to negotiate parameters related to the data exchange that will occur. The CoSIP protocol is a constrained version of the SIP protocol, designed to minimize the amount of network tra\ufb03c and therefore energy consumption, and targeted at IoT scenarios. A similar e\ufb00ort in trying to minimize the amount of data in IoT and M2M applications is being carried on in standardization orga- nizations, such as the IETF CoRE working group, which is currently de\ufb01ning a protocol (CoAP) to be used as a generic web protocol for RESTful constrained environments, and which maps to HTTP. Similarly, in this work we have applied the same approach to de\ufb01ne a protocol for session instantiation, negotiation, and termination. We have described some interesting IoT scenarios that might ben- e\ufb01t from using such a protocol, namely service discovery, session establishment, and services based on a subscribe/notify paradigm. A Java-language implementation of CoSIP has been developed and tested to evaluate the performance of the new protocol, by measuring the number of transmitted bytes compared to solutions based on SIP and CoAP. The results show that applications that use CoSIP can outperform other SIP- and CoAP-based applications in terms of generated network tra\ufb03c: SIP signaling can be compressed by nearly 50% using CoSIP, and long-running applications that may use CoAP for sending the same type of data to a given receiver may be better implemented with CoSIP, since no CoAP overhead has to be transmitted along with each transmitted data message, leading to a packet size and per-packet processing reduction; packet size reduction in turn may reduce the need for packet fragmentation (in 6LoWPAN networks) and the energy consumption of the nodes involved in the data exchange. Future work will include exhaustive experimentation, both in simulation environments and a real-world testbeds comprising a variety of heterogeneous devices. These are currently being set up at the Department of Information Engineering of the University of Parma. The aim is to evaluate the performance of the CoSIP protocol both in terms of energy consumption and delay. The tests will focus on the time required to set up a session in di\ufb00erent scenarios, such as in IEEE 802.15.4 multi-hop environments, and the measurement of energy consumption compared to standard CoAP communication. Two di\ufb00erent perspectives will be analyzed: end-to-end delay between the actual session participants and energy consumption on \n\n76 2 Standards \n\nthe intermediate nodes which will be indirectly involved in the session, responsible for multi-hop routing at lower layers. The target platforms will be both constrained and non-constrained devices for session participants and relay nodes, in order to provide a thor- ough evaluation in heterogeneous devices operating under di\ufb00erent conditions. \n\n2.3 The Industrial IoT \n\nIIoT still lacks a reference networking/communication platform. Sev- eral initiatives are being developed: in the following, we comment on a few relevant ones. The German Plattform Industrie 4.0 is a candidate to become a Euro- pean standard platform. This process is taking place within EU insti- tutions, and individual European countries have their own industrial transformation projects in which the IIoT takes center stage, including: \n\n\u2022 Smart Factory (The Netherlands) \u2022 Factory 4.0 (Italy) \u2022 Industry of the Future (France). \n\nOther major e\ufb00orts include the Japanese Robot Revolution initiative and the Industrial Internet Consortium (IIC). The latter is a consor- tium co-founded by US industrial giant GE, which also coined the term Industrial Internet and is one of the major players in the IIoT. The IIC today is busy mainly with the promotion of the IIoT, in which data is used in order to improve operations, enhance service and detect new opportunities. The IIC collaborates with the Industry 4.0 Platform. Just like the Industry 4.0 Platform, the Internet of Things Consor- tium has developed a framework called the Industrial Internet Ref- erence Architecture (IIRA). The \ufb01rst version was released in 2015 and version 1.8 of the IIRA was published in January 2017. It aims to help all sorts of experts who are involved in IIoT projects to consistently design IIoT solution architectures and deploy interoperable IIoT systems. On top of the IIRA model, in February 2017 the IIC also published the Industrial Internet Connectivity Framework (IICF). Other initiatives are also being considered. For instance, the Orga- nization for Machine Automation and Control, the OPC Foundation, and PLCopen, which have worked independently on di\ufb00erent aspects of automation standardization, are now combining e\ufb00orts to create \n\n2.3 The Industrial IoT 77 \n\ncompanion speci\ufb01cations for the standards and protocols they have already developed in order to allow seamless IIoT interoperability. For example, the OPC Foundation\u2019s \u201cUni\ufb01ed Architecture\u201d (OPC UA) is an industrial interoperability framework. It delivers information modeling with integrated security, access rights, and all communi- cation layers to provide plug and play machine-to-machine (M2M) communication inside factories. It is scalable across the plant \ufb02oor and from sensor to IT enterprise and cloud scenarios. OPC and PLCopen \u2013 which is focused around IEC 61131-3, the only global standard for industrial control programming \u2013 worked together to de\ufb01ne a set of function blocks to map the IEC 61131-3 standard for industrial controls programming to the OPC UA information communication model. \n\n79 \n\n3 \n\nInteroperability \n\n3.1 Applications in the IoT \n\nCosts, limited size and minimal energy consumption are a few of the reasons that IoT devices have limited computational capabilities. Because of these functional and economic requirements, smart objects, especially those that are battery-powered, cannot a\ufb00ord to have heavy processing loads and use expensive communication protocols. On the one hand, limited processing capabilities means that it is hard to process large messages. On the other hand, less processing means lower energy consumption. As a result, IoT devices typically need to minimize the amount of transmitted data. Devices that operate in low-power and lossy networks (LLNs), can greatly bene\ufb01t from lightweight protocols. Large messages result in more fragments (6LoWPAN), which introduce overhead: due to the unstable nature of LLNs, transmitting more fragments can require multiple retransmissions before a whole message can be successfully reconstructed by the receiver. These retransmissions may result in more delay and energy consumption. Communication protocols are speci\ufb01c communication paradigms, which can be classi\ufb01ed into two categories: request/response and publish/subscribe (pub/sub). Speci\ufb01c application scenarios have requirements that drive the choice of the most suitable communica- tion paradigm (and protocol). The question of which architecture \ufb01ts best does not have a clear \u201cone-for-all\u201d answer. \n\nInternet of Things: Architectures, Protocols and Standards, First Edition. Simone Cirani, Gianluigi Ferrari, Marco Picone, and Luca Veltri. \u00a9 2019 John Wiley & Sons Ltd. Published 2019 by John Wiley & Sons Ltd. \n\n\n![Image](/src/assets/generated_images/iot_p93_i0.png)\n80 3 Interoperability \n\n3.2 The Verticals: Cloud-based Solutions \n\nThe early days of the IoT were characterized by the adoption of a very simplistic approach to interconnecting devices: by relying on the availability of cloud services, all makers needed to do was to connect things to the Internet (either through cellular networks or in many cases through an Internet-connected gateway) and send all data uplink to the cloud. The cloud service would then provide a storage facility for all data sent by devices on one side, and a HTTP-based interface for access by clients (through browser or vendor-speci\ufb01c mobile apps) on the other. All major cloud service providers (as illustrated in Figure 3.1), such as Amazon and Microsoft, have now entered this market and released their own cloud IoT platforms. Amazon\u2019s AWS IoT and Microsoft\u2019s Azure IoT suite are probably the most popular cloud IoT platforms. These cloud IoT platforms are an easy way for makers to deploy their applications without requiring them to invest development resources to realize a backend. Although clearly easy to implement and very cost-e\ufb00ective, this approach has created the misunderstanding that the IoT can simply be built by connecting things to the Internet. This is a prerequisite for the IoT but it is not enough to actually create a worldwide network of interconnected devices. This \ufb01rst generation of hardware and software involved has introduced several issues because no attention \n\n\nCloud loT Platform \n\nCloud Services \n\nSmart objects \n\nApplications \n\nMQTT/HTTP over secure channel (TLS,VPN) \n\nFigure 3.1 Cloud IoT platform architecture. \n\n3.3 REST Architectures: The Web of Things 81 \n\nwas paid to developing a long-term design that would actually control the network nor take into account: \n\n\u2022 Scalability: The number of IoT devices is expected to reach 50 bil- lion by 2020. At present, with the order of hundreds of millions of things, everything works, but are networks and services ready to handle the tra\ufb03c generated by billions of things? \u2022 Availability: What happens if an Internet connection becomes tem- porarily or permanently unavailable? Relying on the cloud would just make the service unavailable. \u2022 Interoperability: All device-to-cloud applications do not allow direct interactions among things made by di\ufb00erent manufacturers. Inter- operability can occur only at the cloud level, through system inte- gration of the data itself, if such data are made available to external applications. \u2022 Security: Even though secure and authorized access to cloud services can be implemented in traditional ways, attackers could exploit a breach in the cloud to access a huge amount of private data or implement a DoS attack to prevent users from accessing their data. \u2022 Evolution of systems: Device-to-cloud applications typically need to hard code information into things (which act as clients), thus mak- ing them less robust to changes on the server side. Any update or upgrade in the server functionality might have a destructive e\ufb00ect on the operations of things, which may then require a software/ \ufb01rmware upgrade to change how they operate (say, the endpoint they target or the data format they use). \n\nCloud-based solutions are never going to disappear, at least anytime soon. Nonetheless, this approach just cannot be the reference archi- tecture for a scalable and evolutionary IoT. \n\n3.3 REST Architectures: The Web of Things \n\nOne promising approach that is being brought to the IoT is the idea that it should be built in a similar way to the Internet. There are several reasons to use a web-based approach in the IoT. The web has been around for decades and lots of experience has been gained. \n\n82 3 Interoperability \n\nSince its public release in 1991, the World Wide Web has dramatically evolved and has become an infrastructure upon which to store documents, resources, and to build distributed applications. The most important aspects of the introduction of the web were the referencing of resources through uniform resource identi\ufb01ers (URIs) [28] and the introduction of the Hypertext Transfer Protocol (HTTP) [2] as the application-layer protocol for hypermedia systems. Along with these two major pillars, other essential standards and technologies have been developed, such as the Hypertext Markup Language (HTML) for web documents, web browsers, and web servers. As the web became more and more popular, browsers integrated dynamic behavior through Javascript and Cascading Stylesheets (CSS). After all these years, HTTP is by far the most common application-layer protocol and software libraries implementing web protocols are available (web servers, HTTP clients and so on) for any programming language. Ways of building web applications are widely known and used: adopting similar approaches for the IoT could therefore take advantage of the expertise of existing developers. Moreover, the web has proved to scale extremely well: this is extremely important for the IoT, where billions of connected devices are expected to operate. The IoT can greatly bene\ufb01t from all the experience gained in the development of the web and thus the use of a similar architecture would seem to be a wise design choice. \n\n3.3.1 REST: The Web as a Platform \n\nThe web was born to be an easy to use, distributed, and loosely cou- pled (see below) system for sharing documents. The architecture of the web is simple enough to make it easy to build applications and man- age content. The web is based on a small set of principles, yet it has proved to scale and evolve wonderfully. Thanks to these principles, the web has evolved to become a platform for building distributed systems using HTTP. REpresentational State Transfer (REST) is the architectural style behind the web. De\ufb01ned in 2000 in Roy Fielding\u2019s PhD thesis [29], REST de\ufb01nes a set of rules and principles that all the elements of the architecture must conform to in order to build web applications that scale well, in terms of: \n\n\u2022 scalability (number of interacting clients) \u2022 robustness (long-term evolution of systems). \n\n3.3 REST Architectures: The Web of Things 83 \n\nLoose coupling means that the endpoints should contain as little information about each other as needed to work. All necessary missing information should be collected while interacting. The client must know very few things a-priori. The server will drive the client and pass in the information required to progress and to perform the intended operations. The more a client knows about the server, the more closely it depends on the server implementation. This is a weakness for an application because any change on the server must be matched by a change in the client, which would otherwise just break. In a highly dynamic, evolving, and gigantic environment such as the IoT, design principles that lead to create robust applications must be adopted. \n\n3.3.1.1 Resource-oriented Architectures REST is based on the concept of a resource. A resource can be de\ufb01ned as any relevant entity in an application\u2019s domain that is exposed on the network. A webpage, a video, and an order on an e-commerce website can all be considered web resources. A resource is anything with which a user interacts while progressing toward some goal. Anything can be mapped as a resource, as long as it is meaningful for the application. Resources are characterized by some data, such as the title of the page or the items in an order. An alternative to a resource-oriented architecture (ROA) is a service-oriented architecture (SOA). SOAs have been around for many years and have become a reference for many legacy business- oriented systems. A SOA refers to an architecture where two endpoints communicate through a pre-de\ufb01ned set of messaging contracts. A client starts interacting with a server by retrieving the list of available services and how these can be mapped to HTTP messages, in a Web Service De\ufb01nition Language (WSDL) document. In essence, the WSDL maps a message to a method call on the server. Remote method calls are contained in a SOAP (an XML speci\ufb01cation) included in the body of messages. The presence of a WSDL document is needed to add semantics to messages. However, this is a weakness: if a server changes its services, a client needs to get access to the new WSDL or its functionalities are invalidated. In a ROA, on the other hand, there is no endpoint exposing services; there are only resources that can be manipulated. This is critical for the robustness of the client application. \n\n84 3 Interoperability \n\n3.3.1.2 REST Architectures The principle of separation of concerns is a fundamental of the REST architecture. According to this principle, each element of a system is responsible for a speci\ufb01c concern. Well-separated concerns allow for modularity, reusability, and independent evolution of the system\u2019s ele- ments. A REST architecture builds on: \n\n\u2022 clients (or user agents, such as browsers), which are the application interface and initiate the interactions \u2022 servers (origin servers) host resources and serve client requests. \n\nIntermediaries act as clients and servers at the same time. Forward proxies (known to clients) are \u201cexit points\u201d for a request. Reverse prox- ies appear as origin servers to a client, but actually relay requests. A REST architecture is characterized by uniform interfaces: all con- nectors within the system must conform to this interface\u2019s constraints. Collectively, REST de\ufb01nes the following principles: \n\n\u2022 identi\ufb01cation of resources \u2022 manipulation of resources through representations \u2022 self-descriptive messages \u2022 hypermedia as the engine of application states. \n\nAn application that follows the above principles is termed RESTful. \n\n3.3.1.3 Representation of Resources Resources are never exchanged directly by endpoints. Instead, representations of resources are exchanged between endpoints. A representation is a view of the state of the resource at a given time. This view can be encoded in one or more transferable formats, such as XHTML, Atom, XML, JSON, plain text, comma-separated values, MP3, or JPEG. Typically, the type of representation is speci\ufb01ed in one header of the message containing the resource; for example, HTTP de\ufb01nes the Content-Type header. For the sake of compactness, from now on we will refer to the representation of a resource simply as a resource. Resources are exchanged back and forth between clients and servers. In order to be exchanged, resources must be serialized/deserialized properly at each endpoint, as shown in Figure 3.2. The same resource can have many di\ufb00erent representations (1:N relationship): the state of the same sensor can be described using JSON, XML, or any other suitable format. \n\n\n![Image](/src/assets/generated_images/iot_p98_i0.png)\n3.3 REST Architectures: The Web of Things 85 \n\n\nFigure 3.2 Representations of resources are exchanged between endpoints. \n\n3.3.1.4 Resource Identi\ufb01ers In order to ensure that an application is handling the correct resource, a mechanism to identify a resource univocally in the network is nec- essary. uniform resource identi\ufb01ers (URIs), de\ufb01ned in RFC 3986 [28], serve this speci\ufb01c need. A URI identi\ufb01es a resource univocally. A URI can be used to address a resource, so that it can be located, retrieved, and manipulated. There is a 1:N relationship between a resource and URIs: a resource can be mapped to multiple URIs, but a URI points exactly to one resource. URIs can be of two kinds: \n\n\u2022 a uniform resource name (URN) speci\ufb01es the name of a resource (e.g., urn:ietf:rfc:2616); \u2022 a uniform resource locator (URL) speci\ufb01es how to locate the resource, (e.g., http://example.com/books/123). \n\nAll URIs take the following form: scheme:scheme-specific- part. The scheme part de\ufb01nes how the rest of the URI is to be interpreted \u2013 it typically serves as an indication of the communication protocol that should be used to target the resource. For instance, URNs use the urn scheme, while web resources use the http scheme. URLs include all the information needed to successfully address the resource. A URL has the form shown in Figure 3.3. The optional [username:password] part speci\ufb01es credentials to use for authenticated access to the resource. The host and optional port include networking information needed to reach to the resource. The \n\nhttp:// example.com :8080 /people ?id=1 \n\nscheme host port path query \n\n#address \n\nfragment \n\nFigure 3.3 Generic URL structure. \n\n86 3 Interoperability \n\nhost can be be either an IP address or a fully quali\ufb01ed domain name, which must be resolved using the DNS system. The path provides information to locate the resource inside the host. The query contains matching information to \ufb01lter out the result. Finally, the fragment can be used to identify a speci\ufb01c portion of the resource. URIs should be opaque and not expose any speci\ufb01c notion of the format used to represent the targeted resource. For example, http://example .com/people/123 is a good URI, while http://example.com/ people/123.xml and http://example.com/people/123 .json are not. \n\n3.3.1.5 Statelessness An important principle of REST is statelessness. Statelessness implies that no state information must be kept on the client and server sides, thus avoiding the need to use cookies or to introduce the concept of sessions, which demand a stricter coupling between the endpoints. All requests must therefore be stateless. In order to preserve state- lessness, each message must be self-descriptive. This means that all requests must contain all the information to understand the request so that servers can process them without context (about the state of the client). There is no state information maintained between clients and servers: the state of the client is contained in the request, so the server is relieved from the burden of keeping track of the client state. \n\n3.3.1.6 Applications as Finite-state Machines RESTful applications make forward progress by transitioning from one state to another, just like a \ufb01nite-state machine (FSM), as shown in Figure 3.4. Due to the loose coupling between clients and servers, the states of the FSM and the transitions between them are not known in advance. A state is reached when the server transfers a representation of the resource as a consequence of a client request. The next possible transi- tions are discovered when the application reaches a new state (gradual reveal). Resource representations that embed links are called hyper- media. These links represent the possible transitions to the next states. In essence, the state of the a resource identi\ufb01ed by a URI is contained in the data section of the resource representation and the transition to the next states are contained in the links. \n\n3.3.1.7 Hypermedia as the Engine of Application State The \ufb01nal principle of REST is \u201chypermedia as the engine of applica- tion state\u201d, or HATEOAS for short. HATEOAS states that resource \n\n3.3 REST Architectures: The Web of Things 87 \n\nFigure 3.4 Applications as \ufb01nite-state machines. Entry point \n\nS0 \n\nS1 \n\nS2 \n\nS4 \n\nS5 \n\nS3 \n\nrepresentation should include all the information to drive the client to perform the next requests to progress in the application. By doing so, a client just needs to follow the instructions that the server trans- mits in order to reach its goal. This guarantees that, should the server change its implementation and introduce new functionality (states and links in the FSM), the client would be una\ufb00ected by these changes and could continue to operate. In summary, RESTful applications progress according to the follow- ing steps: \n\n1) The client starts from an entry URI or a bookmark. 2) The response to a GET request includes a hypermedia representa- tion. 3) The representation contains links that de\ufb01ne the possible transi- tions to the next states of the FSM. 4) The client selects a link to follow and issues the next request; that is, it triggers a transition to the next state. 5) The client can also go back. \n\nAn important contribution of REST is the fact that it allows the web to be modeled as an FSM. The web is a globally distributed application, with web browsers as the clients and millions of servers that can serve requests. In the web, resources are documents (such as HTML pages). HTML includes links that can point to other documents (inside <a> tags) and is therefore a hypermedia format. The application is entered through a \ufb01rst URI (entered in the address bar). By clicking on a link, a new state is reached (the new document). \n\n88 3 Interoperability \n\n3.3.2 Richardson Maturity Model \n\nThe Richardson maturity model (Figure 3.5) is a classi\ufb01cation system for web-based applications. The classi\ufb01cation is based on levels, which determine the degree of compliance with the principles of REST. It can be used to answer the question \u201cHow RESTful is a web application?\u201d According to the Richardson maturity model, the higher the level, the more RESTful an application is: the higher the level, the less coupling exists between clients and servers. We always have to remind ourselves that coupling between endpoints should be avoided as much as possi- ble in order to support independent evolution of systems. \n\n3.3.2.1 Level 0: the Swamp of POX The \ufb01rst attempt to create remote procedure calls (RPCs) on the web implied the use of HTTP as a transport system for remote interactions, but without using any of the mechanisms of the web. HTTP was merely used as a tunneling mechanism for custom remote interaction. Using HTTP has great bene\ufb01ts, such as the use of TCP ports 80 and 443, which are typically considered safe by \ufb01rewalls and therefore are not blocked. The idea behind using HTTP as a transport is to expose a service at some URI and then use a single HTTP method \u2013 namely POST \u2013 to send requests, embedding in the request payload an XML-formatted document describing the operation. In essence, clients post RPCs that trigger actions. The XML documents \n\nHypermedia controls \n\nHTTP verbs \n\nResources \n\nThe Swamp of POX \n\nREST oriented features \n\nFigure 3.5 The Richardson maturity model. \n\n3.3 REST Architectures: The Web of Things 89 \n\nClient Web Service POST /calendar HTTP/1.1 \n\n<eventRequest date=\"2015-03-24\" user=\"123\"/> \n\nhttp://example.com/calendar \n\nClient Web Service \n\nHTTP/1.1 200 OK \n\n<eventList> <event start=\"1230\" end=\"1430\" type=\"teaching\"> <course name=\"Internet of Things\"/> </event> <event start=\"1630\" end=\"1730\" type=\"call\"> <person name=\"Gianluigi Ferrari\"/> </event> </eventList> \n\nClient Web Service \n\nPOST /calendar HTTP/1.1 \n\n<newEventRequest date=\"2015-03-24\" user=\"123\"/> <event start=\"1730\" end=\"1800\" type=\"meeting\"/> </newEventRequest> \n\nClient Web Service HTTP/1.1 200 OK \n\n<event start=\"1730\" end=\"1800\" type=\"meeting\"/> \n\nFigure 3.6 XML-based RPC. \n\nembedded in the request and response messages describe the action and the result of that action, respectively. All the semantics of an interaction are strictly tied to the syntax that clients and servers use. This is why Level 0 applications are in \u201cthe Swamp of POX\u201d (plain old XML). This is depicted in Figure 3.6. The agreement on both sides makes applications extremely vulnera- ble to changes; the client must have a very deep a-priori knowledge of: \n\n\u2022 the web service \u2022 the actions that can be triggered \u2022 the meaning of XML document tags and attributes. \n\nIf the web service changes something, the client just breaks. Few web features are used to enforce interactions between endpoints; this is just an HTTP-based RPC model. The format used by XML documents is typically SOAP [30]. However, using SOAP and XML-RPC instead of plain XML does not make any di\ufb00erence; it is just a detail of serializa- tion and deserialization at endpoints. \n\n90 3 Interoperability \n\n3.3.2.2 Level 1: Resources In order to increase the robustness of client applications against changes in the server implementation, a more convenient approach is to model interactions by targeting resources instead of services. Rather than making all our requests to a single service endpoint, individual resources are addressed (one service exposes many logical resources). Applications that use the concept of resources rather than services are classi\ufb01ed as Level 1. This is an improvement over Level 0 because more web-oriented concepts are introduced and exploited, but HTTP is still used as a tunneling mechanism. When working with Level 1 applications, action names and parameters are typically mapped directly to a URI, rather than embedded in the semantics of XML/SOAP payloads (Figure 3.7). The action is triggered by sending an HTTP GET or POST request to the targeted URI, for example GET http://example.com/people/123?action=delete. One important bene\ufb01t of using URIs is that resources are globally addressable. However, this is still a form RPC: the di\ufb00erence is that semantics are inserted in the URI, which still introduces a coupling between client and server. Moreover, the use of the GET method for operations that might create side-e\ufb00ects on the server (such as creating or deleting resources) does not comply with the principles de\ufb01ned in the HTTP speci\ufb01cation [2], which states that GET requests should be idempotent (meaning that multiple requests have the same e\ufb00ect as a single request), and is therefore bad practice. \n\n3.3.2.3 Level 2: HTTP Verbs As we have just seen, Level 1 applications, which embed the semantics of the action to execute directly in the URI and use a single HTTP method for requests, violate the HTTP speci\ufb01cation. A much better \n\npublic Event createEvent(long user, Date from, Date to, String type){ \n\n//... \n\nService Method Arguments \n\n} \n\nhttp://example.com/calendar/newEvent? user=123&date=2015-03-24&type=meeting&start=1730&end=1800 \n\nFigure 3.7 URI-to-action mapping. \n\n3.3 REST Architectures: The Web of Things 91 \n\nTable 3.1 Semantics and e\ufb00ects of HTTP methods for manipulating resources. \n\nHTTP method Safe Idempotent Action \n\nGET yes yes Retrieve a resource with the given URI \n\nPOST no no Create a resource (a new URI is returned by the server) \n\nPUT no yes Update the targeted resource \n\nDELETE no yes Remove the targeted resource \n\napproach is to move the semantics from the URI to HTTP verbs when manipulating resources. In this case we refer to Level 2 applications. Resources are still addressable using URIs, and each resource can be manipulated using HTTP methods. Each method has a particular meaning and maps to a speci\ufb01c CRUD (create-read-update-delete) operation, as shown in Table 3.1. According to RFC 2616, HTTP methods can be safe and/or idempotent. Safe means that they have no e\ufb00ect on the resource (the resource remains the same). Idempotent means that the same request can be executed multiple times with the same e\ufb00ect as executing it once. \n\nHTTP method semantics Level 2 applications de\ufb01ne the following pro- cedures for CRUD operations. \n\n\u2022 Creating a resource: When creating a resource (Figure 3.8), the client must issue a POST request to the target URI of the creator of the resource or the URI of the resource to be created itself (in case this is allowed by the server). The request body might contain the initial representation (state) of the resource. The response body contains \n\nClient Web Service POST /calendar/events HTTP/1.1 \n\n<event start=\"1730\" end=\"1800\" type=\"meeting\"/> \n\nhttp://example.com/calendar \n\nClient Web Service \n\nHTTP/1.1 201 Created Location: /calendar/events/12345 \n\n<event start=\"1730\" end=\"1800\" type=\"meeting\"/> \n\nFigure 3.8 Resource creation. \n\n92 3 Interoperability \n\nthe state of the newly created resource. If the URI of the newly cre- ated resource is de\ufb01ned by the server, it is returned in the Location header. \u2022 Retrieving a resource: When retrieving a resource (Figure 3.9), the client must issue a GET request to the target URI of the selected resource. The request body is left empty. The response body con- tains the current state of the resource. \u2022 Updating a resource: When changing a resource (Figure 3.10), the client must issue a PUT request to the target URI of the resource to manipulate. The URI is the one returned in the Location header after an initial POST. The request body might contain the new state. The response body contains the updated state. \u2022 Deleting a resource: When deleting a resource (Figure 3.11), the client must issue a DELETE request to the target URI of the resource to delete. The request body is left empty. The response body might be empty or contain the state of the deleted resource. \n\nClient Web Service GET /calendar/events/13245 HTTP/1.1 \n\nhttp://example.com/calendar \n\nClient Web Service HTTP/1.1 200 OK \n\n<event start=\"1730\" end=\"1800\" type=\"meeting\"/> \n\nFigure 3.9 Resource retrieval. \n\nClient Web Service PUT /calendar/events/12345 HTTP/1.1 \n\n<event start=\"1830\" end=\"1900\" type=\"meeting\"/> \n\nhttp://example.com/calendar \n\nSchedule a new event Client Web Service \n\nHTTP/1.1 200 OK Location: /calendar/events/12345 \n\n<event start=\"1830\" end=\"1900\" type=\"meeting\"/> \n\nFigure 3.10 Resource update. \n\n3.3 REST Architectures: The Web of Things 93 \n\nClient Web Service DELETE /calendar/events/13245 HTTP/1.1 \n\nhttp://example.com/calendar \n\nClient Web Service HTTP/1.1 200 OK \n\nFigure 3.11 Resource deletion. \n\nHTTP Response Code Semantics Status (response) codes also have semantics: they have particular meaning. Each method has a speci\ufb01c set of status codes. For instance, 2xx indicates success, 4xx indicates a client error (e.g., 405 Method not allowed), and 5xx indicates a server error (e.g., 500 Internal server error). A client error instructs the client not to repeat the request. It can be due to a bad syntax, missing credentials or authorization, or a failure to \ufb01nd the resource for the given URI. A server error means that the client might choose to repeat the request since the failure was on the server side. The semantics of the most common success and failure response codes are reported in Tables 3.2 and 3.3, respectively. \n\nTable 3.2 Semantics of 2xx HTTP status codes when manipulating resources. \n\nMethod Status code Reason \n\nGET 200 OK \n\nPOST 201 Created \n\nPUT 200 OK \n\n204 No content \n\nDELETE 200 OK \n\n202 Accepted \n\n204 No content \n\n94 3 Interoperability \n\nTable 3.3 Semantics HTTP error status codes when manipulating resources. \n\nStatus code Reason Code \n\n400 Bad request The client isseud a malformed request \n\n401 Unauthorized The client must authenticate before performing the request \n\n403 Forbidden The client does not have the privileges to access the resource \n\n404 Not found No resource with the given URI was found \n\n405 Method not allowed The resource cannot be manipulated using the HTTP method \n\n500 Internal server error The server failed to process the request \n\nDescribing Level 2 Applications With Level 2 applications, HTTP is no longer used just as a transport for requests, but instead is also used to describe what manipu- lation on the resource is being requested. By doing so, requests and response are fully descriptive and do not rely on any speci\ufb01c a-priori knowledge between endpoints regarding the contents of the message or how to construct a URI. Requests can therefore be read as \u201c(READ, CREATE, UPDATE, DELETE) the resource identi\ufb01ed by the URI.\u201d Level 2 applications use: \n\n\u2022 HTTP verbs and status codes to coordinate interactions and manip- ulate resources; \u2022 HTTP headers to convey information (e.g., the Location header to indicate the URI of a created resource). \n\nHowever, there is still some coupling between client and server appli- cations: the client must know the URI of a resource and which methods can be invoked. Some sort of documentation is needed to let clients learn about the allowable manipulations for a resource; that is, what can be done with a resource. The solution to this problem is to use a Web Application Description Language1 (WADL) document [31]. A WADL document is a static description used to advertise the endpoints, the methods, and the \n\n1 http://www.w3.org/Submission/wadl/. \n\n3.3 REST Architectures: The Web of Things 95 \n\nrepresentation formats of the resources hosted by a web application. WADL documents describe: \n\n\u2022 sets of resources; \u2022 relationships between resources; \u2022 methods that can be applied to each resource, together with expected input/output and formats; \u2022 resource representation formats (MIME types and data schemas). \n\nWADL documents are needed to answer the following questions: \n\n\u2022 \u201cWhat actions can I take with a URI that is being linked in my rep- resentation?\u201d \u2022 \u201cWhat is the result of such actions and how should the returned state be interpreted?\u201d \n\n3.3.2.4 Level 3: Hypermedia In order to be fully compliant with the REST principles, Level 3 appli- cations must support the HATEOAS principle (see Section 3.3.1.7). As we have seen, this stands for \u201chypermedia as the engine of application state,\u201d and is the ultimate guarantee that client and server applications are fully decoupled. According to HATEOAS, representations of resource should be hypermedia; that is, representations contain URI links to other resources. Hypermedia embed links to drive application states. Web linking [12] speci\ufb01es relation types for web links, and de\ufb01nes a registry for these relations. Because of this, client applications do not need any a-priori knowledge of the server application since the transitions to next possible states are embedded in the state itself. When clients reach a state of the application, the representation of the resource has a double goal: \n\n\u2022 it describes the current state; \u2022 it includes link information to drive the client perform the next intended transitions, according to what the server expects. \n\nThe state of a resource is the aggregation of: \n\n\u2022 data: values of information items belonging to that resource; \u2022 links: representing transitions to possible future states of the current resource. \n\nThis idea of letting the server drive the client through all the states of the application allows client applications to be extremely robust \n\n96 3 Interoperability \n\nagainst changes of the server since all a client needs to do is to fol- low the links included in the representation of the current resource. All the client needs to know in advance is an initial URI (entry point of the application) in order to let the application reach the \ufb01rst state. Put in another way, the more a client ignores details about the server, the more robust and open to system evolution it is. A direct consequence of the HATEOAS principle is the fact that hypermedia plays a fundamental role in the discovery and descrip- tion of next states for the client. It is important to use or de\ufb01ne (hyper)media types that are meaningful for the application. A typical rule for HATEOAS is \u201ca REST API should spend almost all of its descriptive e\ufb00ort in de\ufb01ning the media type(s) used for representing resources and driving application state, or in de\ufb01ning extended rela- tion names and/or hypertext-enabled mark-up for existing standard media types.\u201d Since hypermedia controls describe the resources and drive the application, they are the core of the application. A client capable of understanding the meaning of the hypermedia is fully autonomous in the execution of all the operations, regardless of any change on the server. A server can change the URI scheme indepen- dently without breaking clients and can introduce new functionalities (states) just by adding more links in the hypermedia. HATEOAS fully enables true independent evolution of systems. \n\nHypermedia formats Even in Level 3 applications, clients still need to discover and interact with resources. When the client is presented links to other states, it must be able to interpret these links in order to decide which one to follow. A human-controlled application can rely on user interfaces and events input by users to advance, but this does not apply to machine-to-machine (M2M) communications. As argued before, hypermedia formats provide the means for interacting with a service and are therefore an integral part of the application\u2019s service contract. An extremely important detail of an application is the choice of hypermedia format at design time. This choice must ensure that the chosen format is able to convey all necessary information for client applications to progress. This is where semantics start to become important. Hypermedia formats can either be standard or domain-speci\ufb01c. Several of the hypermedia formats already in use on the Web \u2013 Atom (application/atom), RSS (application/rss), and XHTML (application/xhtml) \u2013 are widely used. XHTML supports \n\n3.4 The Web of Things 97 \n\nhypermedia using hypermedia controls such as the <a> tag. Using standard formats has some bene\ufb01ts, such as widespread knowledge among system/software architects, developers, and IT engineers of the semantics of tags or \ufb01elds and the availablity of software libraries and applications supporting such media types. However, not all standard hypermedia can meet the requirements of an application. Custom formats can be designed to map speci\ufb01c problem domains. Even though a discussion on semantics is beyond the scope of this book, hypermedia format is a very important design criterion, which should be carefully considered. An IoT standard for hypermedia to be used in constrained environ- ments is the CoRE Link Format [13]. The CoRE Link Format is an IoT-oriented web linking speci\ufb01cation used to de\ufb01ne attributes and relations that are meaningful for IoT applications. The CoRE Link For- mat will be considered in detail in Section 3.9.1. \n\n3.3.2.5 The Meaning of the Levels Level 1 handles complexity: a single large service endpoint is divided into multiple resources. Level 2 provides a standard set of verbs so as to handle operations uniformly (CRUD operations). Level 3 introduces discoverability, in order to make a protocol self-documenting. \n\n3.4 The Web of Things \n\nModeling the IoT using web-oriented, RESTful principles can be a way to start to develop a global infrastructure of interconnected objects and to foster the development of scalable and robust IoT applications. The basic idea is to consider smart objects as tiny servers that imple- ment Level 3 IoT applications using hypermedia and the CoRE Link Format. Building the IoT around the REST paradigm and modeling it according to web concepts allows reuse of all the experience gained in the decades of building the web. The Web of Things (WoT) provides an application layer that simpli\ufb01es the creation of the IoT. By bringing the patterns of the web to the IoT, it will be possible to create robust applications in the long term and to build an infrastruture designed to scale inde\ufb01nitely over time. WoT applications will bring to the IoT the same usability as the World Wide Web did with the Internet. The WoT will use a mix of HTTP and CoAP protocols, according to the speci\ufb01c application requirements and deployment scenarios. However, given \n\n98 3 Interoperability \n\nthe RESTful nature of these web-oriented protocols, the same patterns will be adopted, resulting in full interoperability between the web and the WoT. As discussed in Section 2.2.5.1, CoAP has been designed to map to HTTP; dedicated network elements (HTTP\u2013CoAP prox- ies) able to perform protocol translation can be introduced in order to update client and server applications that natively communicate with di\ufb00erent protocols. \n\n3.5 Messaging Queues and Publish/Subscribe Communications \n\nOf course, REST is not the only communication paradigm that can be used. REST has a number of advantages, as thoroughly discussed in Section 3.3, but it also requires objects to be tiny servers that must be accessible by clients. In many cases, due to limited processing capabil- ities and connectivity issues (such as \ufb01rewall policies), this is not fea- sible. An alternative to the traditional synchronous request/response communication model (also known as the RPC pattern) is provided by messaging systems. Messaging systems, or message-oriented middleware, implement an asynchronous communication model and loosely couple the senders with the consumers of messages, thus allowing for more \ufb02exibility and scalability. Compared to REST, senders do not send messages directly to speci\ufb01c receivers, about whom they do not have any knowledge at all. Messaging systems typically provide higher throughput than RPC systems; the former are bounded by network bandwidth while the latter are bounded by network latency. Moreover, the asynchronous nature of messaging systems prevents blocking of I/O operations, which may downgrade performance. Messaging systems implement one of two asynchronous messaging approaches: message queues or pub/sub. \n\nMessage queues In the message queue pattern, the sender sends a message to a queue on a server, where it is stored/persistent: the message is not erased immediately but is kept in memory until a consumer receives it. Only once delivered is the message deleted from the queue. This pattern implements asynchronous point-to-point communication, with total independence between the sender and the consumer. \n\n3.5 Messaging Queues and Publish/Subscribe Communications 99 \n\nP1 \n\nS1 \n\nP2 \n\nS2 \n\nS3 \n\nBroker \n\ntopicA \n\ntopicB \n\ntopicA \n\ntopicA, topicB \n\ntopicB \n\nFigure 3.12 Publish/subscribe communication model. \n\nPublish/Subscribe In the pub/sub pattern, two kinds of entities exist: publishers and subscribers. Publishers send messages to a \u201ctopic\u201d on the server. Subscribers can subscribe to a topic to receive a copy of all mes- sages that have been published on that topic. This means that a message can be consumed by multiple consumers. This is similar to an application-layer multicast. Pub/sub implements the observer pattern, in an event-based paradigm. The separation between publishers and subscribers is possible thanks to intermediary nodes, called brokers. Brokers can be imple- mented as message queues. Typically, the broker is involved for the following functions: \n\n\u2022 publishing: publishers send messages to the broker; \u2022 subscriptions: subscribers register to receive messages, possibly \ufb01l- tered according to some policy (content or topic). \n\nUpon receiving a message from a publisher, the broker is responsible for dispatching messages to the subscribers, according to their sub- scriptions, as shown in Figure 3.12. \n\n3.5.1 Advantages of the Pub/Sub Model \n\nThe pub/sub communication model has the following advantages: \n\n\u2022 Loose coupling: Publishers need not know which subscribers receive messages or even if they exist. Contrast this with the client/server paradigm, where a client must know the URI of the server and the server must exist. \u2022 Scalablility: Since brokers only need to route messages, they can be replicated easily to support higher volumes of data being trans- ferred. \n\n100 3 Interoperability \n\n\u2022 Lightweight implementation: Publishers and subscribers have min- imal footprints for sending and receiving messages, as most of the load is carried by the broker. \n\n3.5.2 Disadvantages of the Pub/Sub Model \n\nThe loose coupling between publishers and subscribers has some drawbacks. As there is no direct interaction between the endpoints, the messaging contract between publishers and subscribers is in\ufb02ex- ible. No content-type negotiation can be performed. Of course, this introduces a weakness in the architecture, as any change on the mes- sage format being published has direct consequences on the receivers. Long-term evolution of systems is therefore hard to achieve. Complex and open systems, characterized by extremely heterogeneous event semantics, can be very di\ufb03cult to manage. Other drawbacks of the pub/sub model are: \n\n\u2022 There is no support for end-to-end security between publishers and subscribers, due to the presence of the broker; messages can be encrypted but this requires encryption/decryption keys to be distributed among publishers and subscribers. \u2022 There are throughput issues: the broker infrastructure must scale in order to avoid issues related to load peaks on both the incoming and outgoing interfaces, which can occur when the number of publish- ers and their publish rate and the number of subscribers increase. This can introduce slowdowns in message delivery. \n\n3.5.3 Message Queue Telemetry Transport \n\nMessage Queue Telemetry Transport (MQTT2) is a lightweight, open-source, TCP-based pub/sub protocol. MQTT is a standard of the Organization for the Advancement of Structured Information Standards. The current version of MQTT is 3.1.1. MQTT targets environments in which devices and networks are constrained. It can be used in scenarios where two-way communi- cations between endpoints operating in unreliable networks must occur. The lightweight nature of MQTT makes it particularly suited to constrained environments where message protocol overhead and message size should be minimal. \n\n2 https://mqtt.org \n\n3.5 Messaging Queues and Publish/Subscribe Communications 101 \n\nAccording to the pub/sub model, in MQTT, messages are published to a shared topic space inside the broker. Topics are used as \ufb01lters on the message stream from all publishers to the broker. MQTT supports hierarchical topics in the form of a topic/sub-topic/sub-sub-topic path. Messages are delivered to all clients that have subscribed with a matching topic \ufb01lter. This means that a single client can receive messages coming from multiple publishers. The matching condition is applied to the topic\u2019s hierarchy, so it possible to subscribe to just a portion of the topic. Wildcards can be used on segments of the path in order to provide \ufb01ner granularity over the messages to receive. In MQTT, the broker applies the subscription \ufb01lters to the message stream it receives in order to e\ufb03ciently determine to which clients a message should be dispatched. Therefore, a subscription can be considered as a conditional realtime receive operation and has a non-durable nature. A sensor-network oriented version of MQTT, called MQTT-SN, has been de\ufb01ned for use in low-power and lossy networks, such as IEEE 802.15.4 networks. MQTT-SN has been designed to allow implementation on low-cost, battery-operated devices. \n\n3.5.3.1 MQTT versus AMQP MQTT and AMQP have a lot in common and also have many di\ufb00er- ences. We will brie\ufb02y summarize their similarities and di\ufb00erences at a high-level. \n\nSimilarities between MQTT and AMQP Both MQTT and AMQP share the following features: \n\n\u2022 asynchronous, message queuing protocols \u2022 based on TCP \u2022 implementing an application-layer multicast \u2022 use TLS for security at the transport layer \u2022 widely available implementation for major platforms and program- ming languages. \n\nDi\ufb00erences between MQTT and AMQP MQTT and AMQP di\ufb00er in the following ways: \n\n\u2022 MQTT is more wire-e\ufb03cient and requires less e\ufb00ort to implement than AMQP; it is well suited to embedded devices. AMQP is a more verbose protocol but provides greater \ufb02exibility. \n\n102 3 Interoperability \n\n\u2022 MQTT provides hierarchical topics with no persistence (stream-oriented approach); AMQP does not provide a hier- archical topic structure but o\ufb00ers persistent queues as a message storage facility (bu\ufb00er-oriented approach). \u2022 In MQTT, messages are published to a single global namespace. In AMQP, messages can be sent to several queues. \u2022 In MQTT, the broker has AMQP supports transactions, while MQTT does not. \n\n3.6 Session Initiation for the IoT \n\nWhile the Constrained Application Protocol (CoAP; see Section 2.2.5.1) is intended to bring the REST paradigm to smart objects, there are many application scenarios that might bene\ufb01t from the use of sessions. An example would be the exchange of data between an association of participants. Here, we introduce a lightweight session initiation protocol targeted at constrained environments. It re-uses the syntax and semantics of CoAP in order to create, modify, and terminate sessions among smart objects with minimal overhead. \n\n3.6.1 Motivations \n\nBeside the REST and pub/sub communication models, there are also many other applications in both constrained and non-constrained environments that might bene\ufb01t from a non-request/response communication model. Some of these applications require the creation and management of a \u201csession\u201d. The term \u201csession\u201d refers to any exchange of data between an association of participants. The communication will occur according to the network, transport, and application parameters negotiated during the session setup. Where there are two participants, the session may involve the sending of one or (probably) more data packets from one participant to the other, in one or both directions. Unidirectional sessions may be initiated by either the sender or the receiver. Examples of sessions in IoT scenarios may be the data \ufb02ow generated by a sensor and sent to a particular recipient for further processing, or data streams exchanged by two interacting smart toys. \n\n3.6 Session Initiation for the IoT 103 \n\nThe Session Initiation Protocol (SIP) [5] is the standard application protocol for establishing application-layer sessions. It allows the endpoints to create, modify, and terminate any kind of (multi)media session: VoIP calls, multimedia conferences, or data communica- tions for example. Session media are transmitted end-to-end, in a peer-to-peer fashion, either using speci\ufb01c application/transport layer protocols, such as RTP [16], or as raw data on top of the TCP or UDP transport protocols. SIP is a text-based protocol, similar to HTTP, and can run on top of several transport protocols, such as UDP (default), TCP, or SCTP, or on top of secure transport protocol such as TLS and DTLS. Session parameters are exchanged as SIP message payloads; a standard protocol used for this purpose is the Session Description Protocol [17]. The SIP protocol also supports intermediate network elements, which are used to allow endpoint registration and session establishment. Examples include SIP proxy servers and registrar servers. SIP also de\ufb01nes the concepts of trans- action, dialog, and call as groups of related messages, at di\ufb00erent abstraction layers. Although SIP was de\ufb01ned for Internet applications, it has the potential to be reused in the IoT. However, this would require suitable adaptation in order to meet the requirements of constrained environ- ments: the large message size and the processing load for the parsing of standard text-based SIP messages is not suitable for constrained environments. For these reasons, in this section, we propose an alternative mechanism for session initiation, based on CoAP, aiming at allow- ing constrained devices to instantiate communication sessions in a lightweight and standardized fashion. Session instantiation can include a negotiation phase, in which the parameters used for all subsequent communication are determined. We propose to reuse not only the CoAP message format, but also the REST paradigm (and methods) provided by CoAP for initiating sessions, rather than compressing SIP into a binary protocol and rede\ufb01ning new methods. This approach brings several bene\ufb01ts, such as the possibility of taking advantage of the well-known REST paradigm and existing implementations of CoAP and avoiding the need to include other software libraries in smart objects, which are typically very limited in available memory. \n\n104 3 Interoperability \n\n3.6.2 Lightweight Sessions in the IoT \n\nThe reuse of CoAP\u2019s message syntax, rather than de\ufb01ning a brand new ad-hoc session initiation protocol for constrained environments, has several motivations: \n\n\u2022 Since CoAP maps HTTP methods well, and since SIP is very simi- lar to HTTP, the message format of CoAP is well-suited to carrying information required by a protocol like SIP. \u2022 Since CoAP already has many implementations in constrained oper- ating systems, such as Erbium [32] for Contiki OS, its use would not require new implementation and testing e\ufb00orts. \u2022 The possibility of using the same software libraries as CoAP allows the memory footprint to be kept very small \u2013 a critical issue for smart objects with very limited available memory. \n\nThere are two possible approaches for establishing, managing, and tearing down a session when using the message format de\ufb01ned by CoAP: \n\n\u2022 de\ufb01ning new ad-hoc methods for session initiation together with their own semantics, encoded according to CoAP syntax; \u2022 reusing the semantics of CoAP methods and trying to manage ses- sions in a RESTful fashion. \n\nOur opinion is that the latter approach is preferable since it would maximize the reuse of CoAP: both the message format and the seman- tics. This approach would also being the bene\ufb01t of avoiding changes to the standard or introducing a new one, as would be needed if new methods were to be de\ufb01ned. Treating the problem of session initiation in a RESTful fashion poses some issues, mainly related to the concept of a session: \n\n\u2022 Is a session compatible with the RESTful paradigm? \u2022 In RESTful terms, how should a session be de\ufb01ned? \u2022 What are the roles involved in the management of a session? \u2022 Can a resource be negotiated among two or more parties? \n\nThe answers to these questions drive the design of a suitable lightweight session initiation protocol. A \ufb01rst consideration is that a unidirectional session can be considered as a \ufb02ow of data from a data source and to a destination. A bidirectional session (i.e., a session where each of the endpoints of communication generate indepen- dent \u2013 but related \u2013 \ufb02ows of data) can therefore be considered as the \n\n3.6 Session Initiation for the IoT 105 \n\nunion of two unidirectional sessions. This idea can be extended to a session among multiple parties, which can be seen as the union of several unidirectional sessions. A second consideration is related to the role of the endpoints involved in the sessions. In SIP, an endpoint, termed a user agent (UA), can act in one of two roles when participating in a session: \n\n\u2022 a user agent client (UAC), which sends SIP requests (typically to initiate a session, through INVITE requests); \u2022 a user agent server (UAS), which receives requests and returns responses. \n\nSIP UAs typically act as both UAC and UAS because, in general, it can- not be determined in advance whether a UA will initiate a multimedia session (caller) or respond to a request for initiating a session (callee). However, in constrained IoT scenarios, it can be assumed that, because of their nature, smart objects will either as a UAC or, more often, as a UAS. Note that the role in establishing the session (UAC or UAS) is not strictly related to the role during the session (sending or receiving data). It is important to note that a session does not necessarily imply a multimedia \ufb02ow, but it is related to a long-lasting \ufb02ow of data that adheres to some parameters that can be negotiated among the end- points during the initiation phase. This feature is obviously compatible with duty-cycled devices. In RESTful terms, a session can be considered a \u201cresource\u201d con- taining all the parameters related to the \ufb02ow of data. The session identi\ufb01er is the URI of the resource. Figure 3.13 shows an example of an XML-based representation of a session resource, based on SDP. Other hypermedia formats can be also used as the resource represen- tation, for instance based on JSON. The proposed protocol makes no assumption about the actual hypermedia format used to represent resources. \n\nFigure 3.13 Example of an XML-based representation of a session resource carrying SDP session information. \n\n<?xmL version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?> <cosip:session xmlns: cosip=\u201chttp://schema.org/ietf/cosip\u201d xmlns: sdp=\u201chttp://schema.org/ietf/sdp\u201d> <cosip:params> <sdp:c>In IP6 aaaa::2</sdp:c> <sdp:m>audio 4000 RTP/AVP 0</sdp:m> <sdp:a>rtpmap:0 PCMU/8000</sdp:a> </cosip:params> </cosip:session> \n\n106 3 Interoperability \n\n3.6.2.1 A Protocol for Constrained Session Initiation In this section, we present the proposed procedures for establish- ing, maintaining, and terminating sessions, according to the REST paradigm and to the discussion about sessions and resources in Section 3.6.2. \n\n3.6.2.2 Session Initiation According to the well-known session setup model used by several session initiation and call-setup signaling protocols (e.g., SIP, H.323, ISUP), the UAC (the caller) starts by sending the \ufb01rst request mes- sage to establish a session. Then, the UAS (the callee) can respond, either accepting or refusing the request. A positive response is then con\ufb01rmed by the UAC in order to inform the UAS that the response has been received and the session can start. During this three-way handshake the UAC and UAS may negotiate the session by specifying session-related attributes, such as data type, \ufb02ow direction (from UAC to UAS, from UAS to UAC, or bidirectional), \ufb02ow endpoints, appli- cation and transport protocols, formats, and encoding parameters. Session negotiation is typically implemented through an o\ufb00er/answer model, where one party sends an \u201co\ufb00er\u201d and the other party sends an \u201canswer\u201d. Although some protocols (e.g., SIP) support both UAC- or UAS-initiated negotiation (i.e., both UAC and UAS may send the o\ufb00er, and the other party sends the answer in the next message), session negotiation is usually initiated by the UAC. According to the REST paradigm, a session is a resource maintained by the server. In this case, the client (UAC) requests from the server (UAS) the creation of such a resource; the server may either accept the request and create the resource (thus acting as an origin server) or refuse it. The session setup procedure is shown in Figure 3.14. The UAC sends a CoAP CON POST request targeted to the UAS, includ- ing a payload containing the o\ufb00er. This is encoded in a suitable format, such as SDP, XML, or JSON. The POST request also contains a CoAP Observe option set to 0 (i.e., register) in order to specify at the same time that the UAC is also interested in observing the created resource. This behavior is needed in order to support server-side session modi- \ufb01cations and termination, as described in Sections 3.6.2.3 and 3.6.2.4. Then, the UAS may: \n\n\u2022 accept the session, by replying with a CoAP CON 2.01 \u201cCreated\u201d response, including the new session identi\ufb01er (resource URI) \n\n3.6 Session Initiation for the IoT 107 \n\nFigure 3.14 Session initiation procedure. \n\nCON POST uas_uri Observe: 0 \n\nUAC UAS \n\nACK \n\nACK \n\nCON 2.01 Created Location: session_id Observe: seq_n \n\nSession \n\nwithin a Location-Path CoAP option \ufb01eld and the answer within the payload, reporting the result of the session negotiation (i.e., the representation of the created resource); \u2022 refuse the session. \n\nIn both the request and the response, the format of the ses- sion description (the o\ufb00er and the answer) is speci\ufb01ed by the Content-Format CoAP option \ufb01eld. In order to accomplish reliable transmission in the session setup phase, the CoAP CON POST request and the CoAP CON 2.01 responses should be acknowledged. CoAP de\ufb01nes also mechanisms to encapsulate the response in an ACK message (piggy-backing), in order to reduce the number of transmitted messages. In Figure 3.14, the UAS con\ufb01rms the CON POST with an ACK, then sends the CON 2.01 response, con\ufb01rmed by the UAC with an ACK message. In this case, the setup procedure involves four messages. although retransmissions might occur in the event of message losses or timeouts. When the setup procedure has completed, both parties may start sending the data according to the negotiated session. \n\n108 3 Interoperability \n\n3.6.2.3 Session Tear-down At the end of a session, the UAC or the UAS might wish to explicitly communicate to the other party the intention of ending the data communication. Even though this is not strictly required, it is prefer- able to perform this \u201cgraceful termination\u201d procedure in order to inform the other party to stop listening for incoming data and to free the allocated processing and/or memory resources. Although this could be done directly within the data plane, using speci\ufb01c features of the data communication protocol (when available), it is usually implemented at the control plane using the same signaling protocol adopted for session setup. For the proposed CoAP-based session initiation protocol, the tear-down procedure can be initiated either by the UAC or the UAS. If the UAC wants to tear down the current session, it starts the session-termination procedure by sending a CoAP CON DELETE request targeted to the session resource URI (previously obtained by the server during the setup within the 2.01 response). The UAS will process the received DELETE request: if a corresponding active session is found, the session is terminated and a CoAP CON 2.02 \u201cDeleted\u201d response is sent. According to the CoAP Observe option extension, if the UAS is willing to tear down the session, it can simply send a CoAP CON 4.04 \u201cNot found\u201d response matching the same Token option included in the original POST request that created the resource (session). Then the UAC con\ufb01rms the reception of the 4.04 response through an ACK message. Figure 3.15 shows the session tear-down procedure, with both UAC- and UAS-terminated sessions depicted. \n\n3.6.2.4 Session Modi\ufb01cation We consider also the case in which the UAC or the UAS may want to change the current active session. The session change may involve the modi\ufb01cation of session directions, data types, protocols, or other session parameters. If the UAC wants to change the session, it sends a CoAP CON PUT request targeted to the session resource URI. The UAC will include the o\ufb00er for the new changed session in the message payload. If the UAS agrees on the new session description, it sends back a CoAP CON 2.04 \u201cChanged\u201d response containing the new representation (i.e., the answer describing the changed session). The CON 2.04 is \n\n3.7 Performance Evaluation 109 \n\nCON DELETE session_id \n\nACK 2.02 Deleted ACK \n\nUAC UAC \n\n(a) (b) \n\nUAS UAS \n\nCON 4.04 Not Found \n\nFigure 3.15 Session terminated by (a) UAC and (b) UAS. \n\nthen con\ufb01rmed by the UAC and the session modi\ufb01cation can be applied by both endpoints. If the UAS wants to change the session, a new answer (compatible with the o\ufb00er provided by the UAC during the setup) should be sent. According to the CoAP Observe option extension, this is performed by sending a new CoAP CON 2.04 \u201cChanged\u201d response reporting the same Token option included in the original POST request that created the session. Figure 3.16 shows the UAC- and UAS-initiated session modi\ufb01cation procedures. \n\n3.7 Performance Evaluation \n\n3.7.1 Implementation \n\nIn order to provide a proof-of-concept of the proposed session initiation protocol and to evaluate and compare its performance with other mechanisms, the proposed protocol and some testing applications have been implemented. The implementation is based on Java, due to its simplicity, cross-platform support, and the availability of a CoAP library [23], which has been suitably extended with the \n\n110 3 Interoperability \n\nCON PUT session_id \n\nACK 2.04 Changed ACK \n\nUAC UAC UAS \n\n(a) (b) \n\nUAS \n\nCON 2.04 Changed \n\nFigure 3.16 Session updated by (a) UAC and (b) UAS. \n\nsession initiation mechanisms described in Section 3.6.2.1. As a proof- of-concept, we implemented two reference applications: \n\n\u2022 a CoAP UA, which allows the establishment of end-to-end audio sessions; \u2022 a CoAP server, which provides a simple data retrieval service, with periodic data noti\ufb01cation. \n\nThe \ufb01rst application consists of an UA, including both UAC and UAS components, which allows establishment and tear down of unidirec- tional or bidirectional RTP audio \ufb02ows between the two UAs. This application is based on a standard SIP UA [33], modi\ufb01ed in order to handle session setup according to the proposed protocol. The audio session (i.e., the RTP \ufb02ows) is negotiated through the standard SDP protocol using the classical o\ufb00er/answer model. The second application is a simple server that allows a client to ini- tiate a data retrieval service (for example, to receive values provided by a sensor) by establishing a data session with a server and specifying the encoding data format and the receiver socket address. Raw data are then encapsulated and sent in UDP packets. The source code of the extended CoAP library, together with the two reference applications, is freely available [34]. \n\n\n![Image](/src/assets/generated_images/iot_p124_i0.png)\n3.7 Performance Evaluation 111 \n\n3.7.2 Experimental Results \n\nWe conducted experimental evaluations in order to compare the pro- posed solution with other protocols and mechanisms. We \ufb01rst com- pared our protocol with other standard and non-standard session ini- tiation signaling protocols by running the same UA (suitably modi\ufb01ed) using three di\ufb00erent underlying session setup protocols: \n\n\u2022 standard SIP; \u2022 a compressed version of SIP that encodes SIP signaling in a CoAP- compatible binary message format (reusing CoAP syntax) [35]; \u2022 the new CoAP-based session initiation protocol proposed here. \n\nThe evaluation results are reported in Figure 3.17. The average size per message of the exchange are reported for the three types of signal- ing protocol. In all three cases, SDP was used for the session nego- tiation. In particular, an SDP o\ufb00er (115 B) was included within the SIP INVITE and the CoAP POST requests. The SDP answer (115 B) was included in the SIP 200 \u201cOK\u201d and CoAP 2.01 \u201cCreated\u201d responses. \n\n\n3000 \n\n2500 \n\n2000 \n\nNetwork traffic [B] \n\n1500 \n\n1000 \n\nCoAP-based CoSIP SIP \n\n500 \n\nSIP 200 OK (BYE); CoAP ACK SIP BYE; CoAP CON DELETE SIP ACK; CoAP ACK SIP 200 OK; CoAP 2.01 Created SIP 180 Ringing SIP 100 Trying; CoAP ACK SIP INVITE; CoAP CON POST \n\n0 \n\nFigure 3.17 Network tra\ufb03c comparison between three session initiation mechanisms: RESTful (CoAP-based), compressed SIP (re-using CoAP-syntax), standard SIP. \n\n112 3 Interoperability \n\nTable 3.4 Comparison of di\ufb00erent session initiation protocols. \n\nProtocol Signaling only Signaling plus SDP \n\nNetwork Ratio Network Ratio tra\ufb03c [B] over SIP tra\ufb03c [B] over SIP \n\nSIP 2433 1 2663 1 \n\nCompressed SIP 1249 0.51 1479 0.55 \n\nCoAP 65 0.027 295 0.11 \n\nTable 3.4 shows the total number of bytes transmitted in the exchange for the three signaling protocols, comparing the network tra\ufb03c with- out and with SDP payload, and the ratio of the tra\ufb03c volume compared to standard SIP for each. It is possible to note that, while standard SIP requires the trans- mission of 2663 B (2433 B for SIP signaling only), the proposed CoAP-based approaches requires only 295 B to be transmitted (only 65 B for CoAP signaling), representing a large decrease. In fact, the ratio between the proposed approach and SIP is only 0.027, so the gain is signi\ufb01cant. The gain, in terms of overall network tra\ufb03c, is due to: \n\n\u2022 the low-overhead of binary CoAP compared to the verbosity of text-based SIP; \u2022 the design of SIP, which is mainly intended for rich multimedia applications and not for IoT scenarios. \n\nThe proposed solution is better suited to meeting the strict require- ments of constrained environments, which force the adoption of mechanisms with low overhead in order to minimize energy con- sumption and to avoid delays due to retransmission (which may occur when operating in LLNs). A second comparison was conducted in order to evaluate the two di\ufb00erent CoAP-based approaches for retrieving data from a remote server. We considered a client interested in receiving data from a remote server (say, a sensor periodically providing value updates). The two approaches considered are: \n\n\u2022 The CoAP client registers itself with the server as an observer of the resource (i.e., using the Observe option) and periodically \n\n\n![Image](/src/assets/generated_images/iot_p126_i0.png)\n3.7 Performance Evaluation 113 \n\nreceives updates of the new resource state according to the CoAP resource observing model [36] through CoAP NON 2.04 \u201cChanged\u201d responses. \u2022 The CoAP client establishes a session with server, negotiating both the receiver socket address and the data encoding format; all data values are then sent by the server within UDP packets. \n\nFigure 3.18 shows the results in terms of overall generated network tra\ufb03c as a function of the number of exchanged packets. The establish- ment of the session requires more bytes at the beginning of the com- munication. However, after a few data packets, the solution based on a CoAP-negotiated session outperforms the solution based on CoAP observing in terms of overall network tra\ufb03c. In the tested application, each update consisted in 4 B of data. CoAP observing introduces an additional 7 B overhead, resulting in a trade-o\ufb00point at just after 7 packets. As for the tear-down procedure, the session-based solution is comparable to session termination through resource observing, so there is no additional overhead. \n\n\n400 \n\n300 \n\nCoAP Observe CoAP-based Session Initiation \n\n200 \n\nNetwork traffic [B] \n\n100 \n\n0 1 3 5 7 9 11 13 15 17 19 21 23 # of packets 25 27 29 \n\nFigure 3.18 Network tra\ufb03c comparison between i) CoAP observing and ii) session-based data \ufb02ow as a function of the number of exchanged packets (adimensional). \n\n114 3 Interoperability \n\nTable 3.5 Comparison of Java bytecode footprints. \n\nLibrary Support Size [B] \n\nmjCoAP RFC 7252 165227 \n\ndraft-ietf-core-block \n\ndraft-ietf-core-observe \n\nmjCoAP + sessions RFC 7252 177661 \n\ndraft-ietf-core-block \n\ndraft-ietf-core-observe \n\nsession initiation \n\nAs a \ufb01nal performance metric, the memory footprint introduced by session establishment logic is considered. Table 3.5 shows a the com- parison of bytecode footprint for the Java libraries (the jar \ufb01les) with and without the session support. The increase of the size is negligible. \n\n3.7.3 Conclusions \n\nMany constrained and non-constrained applications might bene\ufb01t from communication models other than REST and pub/sub, and might require the creation and management of a session (i.e., any exchange of data between an association of participants). Some session initiation protocols, such as SIP, have been introduced but SIP cannot simply be reused in the IoT because of its large overhead which mean that it cannot meet the requirements of constrained environ- ments. For this reason, a lightweight protocol for session initiation, reusing the syntax and semantics of CoAP, and considering a session as a CoAP resource, can be introduced. In fact, the proposed approach for session establishment, management, and termination is, by nature, standard and adheres to the REST paradigm. It provides several advan- tages such as low-overhead and reuse of existing implementations (thus, minimizing memory footprint of smart objects). A Java implementation of the proposed protocol has been used to conduct a performance evaluation, aiming at highlighting the advantages, in terms of network tra\ufb03c (and consequently, on energy- consumption), over alternative solutions, such as SIP and CoAP observing. The results show that the proposed lightweight session initiation protocol meets the IoT\u2019s low-overhead requirements and \n\n3.8 Optimized Communications: the Dual-network Management Protocol 115 \n\nthat applications that rely on this approach outperform others, based on di\ufb00erent mechanisms, such as SIP sessions and CoAP observing. \n\n3.8 Optimized Communications: the Dual-network Management Protocol \n\nThe trade-o\ufb00between high-performance data transmission and low-energy consumption is a long-standing issue in the \ufb01eld of wireless communications. E\ufb03cient data exchange is critical for the battery-powered mobile devices typically used in distributed surveil- lance scenarios, which may be required to transmit video or audio streams between in-network nodes. In such cases, the devices carried by operators must be as lightweight as possible. However, LLNs do not provide su\ufb03cient bandwidth to meet the requirements of streaming transmissions, while high-performance communications result in high energy consumption, shortening the lifetimes of the devices. Here we present the data-driven IoT-oriented Dual-network Management Protocol (DNMP), which uses two IP-addressable radio interfaces on the same node: one with low energy consumption (and throughput) and one with high throughput (and energy consumption). The low-power network acts both as an independent data plane and as a control plane for the high-throughput network, the latter being turned on whenever necessary to support multimedia streaming. In order to validate the protocol, we consider the integration of a low-power IEEE 802.15.4 radio transceiver and a high-throughput IEEE 802.11s radio transceiver. An extensive experimental investigation is then carried out, with the following goals: \n\n\u2022 investigating the performance of the two overlaid networks (IEEE 802.15.4 and IEEE 802.11s); \u2022 determining the critical threshold, in terms of amount of data to be transmitted, beyond which the use of DNMP becomes advanta- geous. \n\n3.8.1 DNMP Motivations \n\nThere are many application \ufb01elds for IoT devices, ranging from remote environmental monitoring to smart surveillance. Clearly, the performance requirements vary signi\ufb01cantly as well. For instance, \n\n116 3 Interoperability \n\nin a remote monitoring scenario [37], sensor nodes are statically deployed and may send only a few data packets per day to a sink node; a few packet losses are likely to be tolerable. In a smart surveillance scenario [38], on the other hand, nodes must be able to send video or audio streams on a mesh/ad-hoc network: resilience and very low packet-loss rates are key system requirements. In particular, many surveillance scenarios require the transmission of audio/video streams between two or more mobile devices: for example, policemen or \ufb01remen can take advantage of this capability to increase their context awareness during operations. However, in order to maximize the lifetime of the equipment without burdening the operators with heavy batteries, it is important to provide mechanisms that minimize energy consumption. The IEEE has developed several standards that partially meet the di\ufb00erent requirements of di\ufb00erent IoT scenarios. For instance, the IEEE 802.15.4 standard promises to make the implementation of systems with years of activity feasible thanks to the adoption of low-power consumption hardware. In this context, the IETF ROLL Working Group has introduced RPL (IPv6 Routing Protocol for Low-Power and Lossy Networks) [39], a lightweight routing protocol for LLNs. In addition, the research community has developed operat- ing systems for constrained objects. Among these, we should mention ContikiOS [40], which, besides supporting low-power standards like 6LoWPAN and RPL, allows for full IP networking with standard IP protocols such as UDP, TCP, and HTTP. The IEEE has also de\ufb01ned several standards to achieve high- performance communication. Among these, IEEE 802.11 is a set of speci\ufb01cations that provide di\ufb00erent standards for wireless net- working, especially for infrastructured wireless networking. The most commonly used versions of IEEE 802.11 (IEEE 802.11g and IEEE 802.11n [41, 42]) rely on access points to collect data from remote terminals. These standards guarantee bit rates of up to 54 Mbps in g mode or 600 Mbps in n mode. However, these solutions do not provide mesh networking, a s mode does. In particular, the IEEE has released the IEEE 802.11s amendment, which extends IEEE 802.11b/g/n [41, 42] by de\ufb01ning an architecture and a protocol stack supporting both broadcast/multicast and unicast delivery using \u201cradio-aware metrics over self-con\ufb01guring multi-hop topologies\u201d [43]. In order to provide a trade-o\ufb00between performance and energy e\ufb03- ciency, we here present the IoT-oriented data-driven energy-e\ufb03cient \n\n3.8 Optimized Communications: the Dual-network Management Protocol 117 \n\nDual-network Management Protocol (DNMP), which relies on the coexistence of a low-power/low-throughput (LPLT) network and a high-power/high-throughput (HPHT) network. The former transmits low-rate data (data plane) and acts as an overlay (control plane) that, according to the information coming from routing tables, selectively activates, via IP-based communications, a set of high-speed interfaces (forming a second data plane). When a large burst of data, such as a video or an audio stream, needs to be transferred, the low-power network selectively turns on the high-speed interfaces of the active nodes along the path between source and destination. When stream- ing has completed, the low-power network turns o\ufb00the high-speed interfaces to avoid wasting energy. We should point out that DNMP is agnostic about the MAC/routing protocols in the nodes\u2019 protocol stacks and only requires that the dual radio interfaces are univocally IP addressable. In order to validate DNMP, we have evaluated its per- formance, in terms of overhead and latency, using the IEEE 802.15.4 standard for the low-power network (data/control plane) and the IEEE 802.11s standard for the high-throughput network (data plane) (see Section 3.8.5). The critical amount of data beyond which DNMP becomes e\ufb00ective is identi\ufb01ed. \n\n3.8.2 Related Work \n\nThe idea of using a low-power overlay to control a high-speed net- work has been considered in the literature. For instance, Gummeson et al. the authors used two low-power technologies to create a uni\ufb01ed network [44]. In their scheme, the nodes learn about the character- istics of radio channels through exploration; then, they dynamically and continuously select the most e\ufb03cient radio channel among those available. Although radios are switched at runtime, an abstraction of a uni\ufb01ed link layer is provided to applications running on multi-radio platforms. However, there was no concept of tra\ufb03c quality of service in this study. DNMP, on the other hand, clearly decouples the two net- works and selects the most appropriate communication interface for the type of tra\ufb03c to be transferred. Sengul et al. propose using multiple radios to transmit bursts of data accumulated at sensors [45]. They highlighted the existence of a trade-o\ufb00when deciding whether to rely on low-power devices or to turn on high-speed interfaces. A similar approach was proposed by Wan et al., who triggered their high-speed interfaces as soon as \n\n118 3 Interoperability \n\nnetwork congestion was detected on the low-power interfaces [46]. Unlike these approaches, DNMP is more general and can be exploited for any kind of data transfer. In addition, in the Sengul and the Wan approaches [45, 46], the high-speed plane is used only as backup for the low-power plane, whilst in DNMP the two planes can be used simultaneously. Stathopoulos et al. used an IEEE 802.15.4 network to switch on IEEE 802.11g interfaces [47]. DNMP can be seen as a formalized extension of this approach, since we generalize the wake-up mecha- nism to any pair of radio interfaces. In addition, since we utilize the presence of IP-addressable interfaces, the DNMP approach is general and agnostic of protocols running at lower layers. The growing interest in dual-radio devices is witnessed by the e\ufb00orts made by the scienti\ufb01c community to develop energy-e\ufb03cient hardware. Jurdak et al. used two IEEE 802.15.4 transceivers to achieve high throughputs with reduced energy consumption [48]. In DNMP, no speci\ufb01c standards are considered a priori. However, as described in Section 3.8.4, as this work focuses on IoT scenarios, the validation has been carried out by integrating a TelosB mote, acting as an IEEE 802.15.4 radio interface, and an IEEE 802.11s dongle, acting as the corresponding interface, on a Raspberry Pi. \n\n3.8.3 The DNMP Protocol \n\nDNMP is a lightweight User Datagram Protocol (UDP)-based application-layer protocol intended to provide a simple mechanism to allow devices equipped with a LPLT radio interface and a HPHT radio interface to establish e\ufb03cient end-to-end routes between pairs of nodes over a multi-hop network. The LPLT radio interface is managed by an IP-based communication protocol, denoted as RPlow. DNMP exploits RPlow as a control-plane protocol to setup one or more routes from a given source to an intended destination, using the HPHT interface, which, in turn, is managed by a data-plane protocol, denoted as RPhigh. Depending on the user application needs, the DNMP control plane RPlow switches on and o\ufb00the HPHT interfaces. This represents an RPhigh overlay that can be used when there are transmissions with high-throughput requirements (e.g., multimedia streaming), for which LPLT interfaces are unsuitable. According to DNMP, each node keeps a counter, referred to as Chigh, of the number of RPhigh routes that require its HPHT interface to be \n\n3.8 Optimized Communications: the Dual-network Management Protocol 119 \n\nactive to ensure end-to-end communication between the requesting source/destination pairs. LOCK and UNLOCK messages are used, respectively, to increment and decrement each involved Chigh by 1. The value of a node\u2019s Chigh depends on the number of concurrent routes that can be set up; more precisely, if a node is needed for n di\ufb00erent routes, its Chigh value is n. When a node\u2019s Chigh reaches 0, this node can switch its RPhigh interface o\ufb00because it is no longer needed in any route. DNMP is based on a request/response communication model and de\ufb01nes the syntax of request and response messages that are used to map the LOCK and UNLOCK operations. As DNMP is UDP-based, it provides mechanisms for reliable message trans- mission, specifying retransmission of requests that did not receive a response, with an exponential backo\ufb00. We note that according to DNMP, the RPlow protocol can be used, not only as a control-plane protocol, but also as a data-plane protocol for transmissions requiring a bit-rate below a certain threshold (i.e., not requiring the throughput provided by RPhigh). The role of RPlow is left to the application, which can decide whether to use DNMP (thus dynamically switching between RPlow and RPhigh) or not, depending on the bit-rate requirements of the data transmission. \n\nDNMP message format DNMP messages are encoded in a simple binary format. Each mes- sage starts with \ufb01ve \ufb01xed-size \ufb01elds, as speci\ufb01ed in Table 3.6. These are followed by a variable number of \u201cHop ID\u201d message \ufb01elds. \n\nRoute establishment DNMP sets up RPhigh routes in a three-phase process, as shown in Figures 3.19\u20133.21. The \ufb01rst stage of the process, called \u201clocking\u201d, switches on all RPhigh radio interfaces of the devices that are on the RPlow route from a given source to a speci\ufb01c destination, using a LOCK message. After the locking, the route identi\ufb01cation stage determines which DNMP nodes are actually needed for the multi-hop communication over RPhigh. Finally, the unlocking stage can be used to switch o\ufb00, using UNLOCK messages, all the RPhigh radio interfaces that are not needed for the end-to-end communication among the speci\ufb01ed endpoints. This prevents unnecessary energy consumption by the RPhigh radio interface. \n\nLocking phase When a source node, denoted as S, needs more bandwidth for transmitting data to a destination node, denoted as D, \n\n120 3 Interoperability \n\nTable 3.6 DNMP message \ufb01elds. \n\nField Length (bits) Description \n\nVersion 2 Indicates the DNMP version number. \n\nCode 6 Split into a 3-bit class (most signi\ufb01cant bits) and a 3-bit detail (least signi\ufb01cant bits), documented as c.dd, where c and dd are two digits from 0 to 7. \n\nThe class can indicate: \n\n\u2022 a request (0 = (000)2), \n\n\u2022 a success response (2 = (010)2), \n\n\u2022 a client error response (4 = (100)2), \n\n\u2022 a server error response (5 = (101)2). \n\nMessage ID 16 Used to detect duplicate messages and to match request/response messages. \n\nSender ID 8 The RPlow short address of the originator of the request, i.e., the node willing to setup a RPhigh route to another node. \n\nDestination ID 8 The RPlow short address of the target of the request, i.e., the node the RPhigh route needs to reach. \n\nHop ID 8 The RPlow short address of the intermediate node that has received the request. This \ufb01eld is used for route-tracing purposes over RPlow. \n\nBy reporting the list of traversed nodes, the sender can learn about which nodes have increased their RPhigh interface counter. \n\nit sends a LOCK request through the RPlow control-plane protocol, to select the next-hop node R1 (at the network layer) in the direction towards D by exploiting its RPhigh routing table to extract R1\u2019s IP address. On receiving the LOCK request, R1 increments its Chigh by 1 and, if previously o\ufb00, switches its RPhigh interface on. Next, R1 appends its identi\ufb01er to the tail of the request message, in order to trace that it has received and processed the message. Finally, R1 selects the receiving node R2 in the next hop and relays the updated request message. These steps are repeated until the LOCK request reaches D. The request message received by D contains all the identi\ufb01ers of the \n\n3.8 Optimized Communications: the Dual-network Management Protocol 121 \n\n1 \n\n1 2 \n\n5 \n\n5 \n\n2 \n\n6 D S \n\nS \n\nON \n\nLOCK \n\nLOCK \n\nLOCK RESP \n\nLOCK \n\nLOCK \n\nON ON ON ON OFF OFF \n\nS 5 \n\nPHY HPHT radio (IEEE 802.11s) LPLT radio (IEEE 802.15.4 with RPL) \n\n6 3 1 D \n\n3 \n\n4 3 \n\n2 \n\n2 5 6 3 D 1 \n\nFigure 3.19 DNMP message \ufb02ow for the RPhigh route establishment: locking. \n\nnodes that relayed the message. At this point, D sends a response message to S as an acknowledgement, including the identi\ufb01ers of all the intermediate nodes so that S becomes aware of the route that the request has followed. This procedure is shown in Figure 3.19. \n\nRoute identi\ufb01cation phase At the end of the locking phase, the LOCK request issued by S has reached D, and all intermediate nodes {Ri} have incremented their Chigh. S can now issue a trace request for D in order to learn which nodes are actually needed to route a message to D using RPhigh. The nodes that are not needed for the RPhigh multihop communication between S and D are then put in a list, called the unlock list (UL), while nodes that are needed are put in another list, called the locked list (LL). The main steps of this phase are shown in Figure 3.20. \n\nUnlockingphase Finally, S sends an UNLOCK request over RPlow to all nodes in the UL, which have increased their Chigh but are not needed for the end-to-end communication between S and D. After receiving the UNLOCK request, an intermediate node decrements its Chigh by 1 and, if Chigh reaches 0, switches o\ufb00its RPhigh interface to save energy. After doing so, the node sends a response back to S to acknowledge that it has received and processed the request. The steps of the unlock- ing phase are shown in Figure 3.21. \n\n122 3 Interoperability \n\nPHY HPHT radio (IEEE 802.11s) LPLT radio (IEEE 802.15.4 with RPL) \n\nS \n\nON ON ON ON ON OFF OFF \n\n2 \n\n2 \n\n1 \n\n2 TRACE TRACE \n\n5 \n\n5 6 \n\n3 \n\n1 \n\n2 \n\n6 3 D 1 \n\nS \n\nS \n\n2 5 6 3 D \n\nD \n\n1 \n\nFigure 3.20 DNMP message \ufb02ow for the RPhigh route establishment: route identi\ufb01cation. \n\nPHY HPHT radio (IEEE 802.11s) LPLT radio (IEEE 802.15.4 with RPL) \n\nS \n\nON OFF ON OFF ON OFF OFF \n\n2 \n\nUNLOCK \n\nUNLOCK \n\n5 \n\n5 6 \n\n3 \n\n1 \n\n2 1 \n\n2 \n\n6 3 D 1 \n\nS \n\nS \n\n2 5 6 3 D \n\nD \n\n1 \n\nFigure 3.21 DNMP message \ufb02ow for the RPhigh route establishment: unlocking. \n\nRoute tear-down When S completes its RPhigh data transmission to D, it sends UNLOCK requests to the nodes that are in the LL, so that each of these nodes decreases by 1 the value of Chigh and, if possible, turns o\ufb00 its HPHT interface. \n\n3.8 Optimized Communications: the Dual-network Management Protocol 123 \n\n3.8.4 Implementation with IEEE 802.15.4 and IEEE 802.11s \n\nIn order to validate DNMP, we considered an IEEE 802.15.4 LPLT interface and an IEEE 802.11s HPHT interface. In the following, we \ufb01rst provide more details on the two standards and then we characterize their DNMP-based integration on a node. \n\n3.8.4.1 LPLT Networking The IEEE 802.15.4 standard, which de\ufb01nes physical (PHY) and medium access control (MAC) layers for wireless personal area networks (WPANs), targets reduced energy consumption and ubiq- uitous communications. Although IEEE 802.15.4 can operate on three ISM frequency bands, here we use the band at 2.4 GHz since it o\ufb00ers the largest channel bandwidth and allows for bit rates of 250 kpbs. Although the maximum transmit power de\ufb01ned by the standard is around 0 dBm, the transmission range is about 100 m with currently available transceivers. At the MAC layer, the IEEE 802.15.4 standard uses a carrier sense multiple access with collision avoidance (CSMA/CA) strategy to minimize energy dissipation. Since the imple- mentation of the LPLT network is carried out via a TelosB running the Contiki OS (an open-source operating system for low-power nodes) [40], we use the ContikiMAC protocol [49], which allows us to achieve useful energy savings by cyclically turning on and o\ufb00 radio interfaces. In order to provide full in-network connectivity, we rely on RPL, which is emerging as the de facto routing protocol for constrained networks. RPL allows us to build a multi-hop and dynamically recon\ufb01gurable routing tree between each pair of nodes in the network. Finally, at the transport layer, we use UDP, since it is more suitable for constrained nodes than traditional TCP. \n\n3.8.4.2 HPHT Networking The IEEE 802.11s standard is an amendment of the IEEE 802.11 standard and is fully compliant with the IEEE 802.11b/g/n standards. While IEEE 802.11b/g/n networks operate only in infrastructure mode \u2013 that is, all communications are centralized \u2013 the IEEE 802.11s standard overcomes this limitation to enable mesh networking. The maximum transmit power allowed by the standard is 20 dBm, which is 100 times higher than that used by IEEE 802.15.4. Due to its inherent dependence on IEEE 802.11n, IEEE 802.11s operates at a maximum net data rate ranging from 54 to 600 Mbps (when it uses 40 MHz \n\n124 3 Interoperability \n\nchannels and is con\ufb01gured to support multiple-input multiple-output communications and frame aggregation). For medium access, mesh stations implement the mesh coordina- tion function (MCF). MCF relies on the contention-based protocol known as enhanced distributed channel access (EDCA), which is itself an improved variant of the basic IEEE 802.11 distributed coordina- tion function (DCF). Using DCF, a station transmits a single frame of arbitrary length. With EDCA, a station may transmit multiple frames whose total transmission duration may not exceed the so-called trans- mission opportunity limit. The intended receiver acknowledges any successful frame reception. The default path selection protocol fore- seen by the IEEE 802.11s standard, called the hybrid wireless mesh protocol (HWMP), combines the concurrent operations of a proactive tree-oriented approach with an on-demand distributed path selection protocol derived from the ad-hoc on-demand distance vector proto- col. The proactive mode requires a mesh station to be con\ufb01gured as a root mesh station. \n\n3.8.4.3 Node Integration The two reference (LPLT and HPHT) standards were integrated on a single node in order to deploy a real testbed for dual-interface nodes. Regarding the IEEE 802.15.4 standard, the chosen node is a SkyMote TelosB. TelosB is the best known mote, and is a veri\ufb01ed hardware plat- form that uses Contiki OS. According to the CC2420 datasheet,3 the mote consumes 50 mW in transmission/reception phases and 0.24 \ud835\udf07W in sleep mode. As for the IEEE 802.11s standard, the choice of the USB dongle was not straightforward, because compatibility with the IEEE 802.11s draft strictly depends on the available drivers for the chosen platform. Our choice fell on the TP-LINK TL-WN722n USB dongle, as there is open source \ufb01rmware for its chipset (the Atheros AR9271). This \ufb01rmware can be compiled on di\ufb00erent platforms and natively supports the mesh point mode. The power consumption of the TP-LINK IEEE 802.11s interface is 1.1 W in transmission mode and 0.2 W in reception mode. The model used operates at a voltage of 3.3 V and has no power consumption in sleep mode.4 The selected radio interfaces have then been integrated on a Linux-powered Rasp- berry Pi rev.B, whose two USB ports have been used to connect the \n\n3 http://inst.eecs.berkeley.edu/\\HCode{<SPitie/>}cs150/Documents/CC2420.pdf. 4 https://wikidevi.com/wiki/Atheros_AR9271. \n\n\n![Image](/src/assets/generated_images/iot_p138_i0.png)\n3.8 Optimized Communications: the Dual-network Management Protocol 125 \n\nFigure 3.22 Picture of the integrated node. A Raspberry Pi hosts a TelosB mote as IEEE 802.15.4 interface and a TP-LINK as IEEE 802.11s interface. \n\n\nTelosB and the Wi-Fi dongle. The integrated dual-interface node is shown in Figure 3.22. The DNMP code was developed in C for Contiki OS. This allows us to have low-level control over the IEEE 802.15.4 network, enabling us to format UDP packets correctly and to handle routing. If, according to the LOCK-UNLOCK policy, RPlow has to modify the state of the RPhigh interface, Contiki OS has to speak with the Raspberry Pi and make some modi\ufb01cations to the actual network con\ufb01guration. In order to communicate with the TelosB, we have adapted the serialdump.c serial console provided with Contiki OS, enabling the motes to parse the data coming from the serial port and to react appropriately to the various messages. In this way, serialdump.c becomes a sort of \u201cdae- mon\u201d, listening on the serial port for potential messages of interest. Due to its characteristics, serialdump.c is also in charge of the HWMP route-identi\ufb01cation and unlocking phases, as outlined in Section 3.8.3. \n\n3.8.5 Performance Evaluation \n\nIn this section, we analyze the performance of the proposed overlaid dual-radio system. The chosen scenario consists of a surveillance network for infrastructure monitoring. In the presence of an alarm, high-priority data (such as a video stream) needs to be transmitted from the terminal of an operator to the terminal of another operator. \n\n3.8.5.1 Experimental Setup The testbed consists of a linear network of DNMP-enabled dual-radio nodes (an example of such an application would be for monitoring \n\n126 3 Interoperability \n\nFirst: all 802.11s interfaces on RPL route are turned ON \n\nSecond: Useless 802.11s interfaces are then turned OFF \n\n802.15.4 messages \n\n802.15.4 message \n\n802.15.4 Tx range \n\n802.15.4 Tx range \n\n802.11s Tx range \n\n802.11s Tx range \n\nON \n\nON \n\nON ON \n\nON OFF \n\nOFF \n\nON \n\nON \n\nOFF \n\n2 \n\n4 \n\n2 \n\n5 \n\n5 \n\n4 1 \n\n1 \n\n3 \n\n3 \n\nFigure 3.23 IEEE 802.15.4 vs. IEEE 802.11s transmission ranges. \n\nthe perimeter of a building). Using the maximum transmit power, the transmission range of the IEEE 802.11s dongles is nearly twice the transmission range of IEEE 802.15.4 TelosB motes (Figure 3.23). We refer to the scenario shown in Figures 3.19\u20133.21, with a sequence of \ufb01ve nodes. Node S wants to communicate with node D. If nodes S and D use only the IEEE 802.15.4 network, they need to create a four-hop route, since every node has radio visibility of only its clos- est neighbors. On the other hand, if nodes communicate through the IEEE 802.11s network, HWMP, which IEEE 802.11s uses for routing, leads to the creation of a two-hop route between the two nodes. \n\n3.8.5.2 Operational Limitations of IEEE 802.15.4 We \ufb01rst investigate the features and limitations of the IEEE 802.15.4 standard. In particular, the gap, in terms of performance, between ideal Contiki nodes (simulated in the Cooja simulator) and real nodes (oper- ating in an indoor scenario) needs to be determined. The analysis evi- denced a signi\ufb01cant di\ufb00erence between real and ideal nodes, in terms of packet-loss rate and average delay. In particular, in order to per- form simulations of the experimental scenario, we \ufb01ne-tuned Cooja. After some testing, we heuristically set the transmission and recep- tion probabilities of each node to 0.95. By doing so, the performance of the simulated and real nodes showed the same trends. Due to the limited number of available dual-radio nodes, analysis of deployments involving larger numbers of nodes relied on simulations. The performance of IEEE 802.15.4 is investigated by simulating a very low bit-rate service, namely, an audio stream with a rate \n\n3.8 Optimized Communications: the Dual-network Management Protocol 127 \n\n100 \n\n200 \n\n300 \n\n400 \n\n500 \n\n600 \n\n700 \n\n800 \n\n50 \n\n100 \n\n150 \n\n192 \n\n252 \n\n302 \n\n552 \n\nTransmission time [ms] \n\nApplicative payload [B] \n\n1 Hop 2 Hops 3 Hops 4 Hops \n\nFigure 3.24 Experimental results: transmission time as a function of the payload size. \n\nof 1008 Byte/s. This bit rate was chosen since Contiki has severe constraints on the dimension of the IPv6 bu\ufb00er, which limits the size of the payload of IPv6 packets. Low-power devices, such as TelosB motes, have very limited RAM \u2013 of the order of a few kilobytes \u2013 so that memory allocation to build and send IPv6 packets is a practical issue. In Figure 3.24, the transmission time is shown as a function of the payload. In particular, the results show that increasing the packet payload does not signi\ufb01cantly a\ufb00ect the performance of the network for bu\ufb00er-size dimensions below 300 B (i.e., 252 B at the application layer). On the contrary, for larger packet dimensions, the packet is fragmented, thus leading to higher transmission latency. At this point, we set the packet size to 300 B and we con\ufb01gure the nodes to exchange data using UDP over IPv6. Thus, the packet is struc- tured as follows: \n\n\u2022 40 B of IPv6 header \u2022 8 B of UDP header \u2022 252 B of application data. \n\nWith this con\ufb01guration, we investigate the feasibility of the IEEE 802.15.4 standard for media streaming. In particular, we simulate in Cooja the transmission of a 5 s audio stream (at 1008 B/s) in a multi-hop network. Even this low rate can have a negative impact on network performance, in terms of packet-loss rate, as shown in Table 3.7. In fact, the packet loss reaches 45% with six hops and 50% \n\n128 3 Interoperability \n\nTable 3.7 Packet-loss rate at di\ufb00erent hops for a 5 s audio stream at 1008 B/s (i.e., 5 kB). \n\nNumber of hops 1 2 3 4 6 8 10 \n\nPacket-loss rate 0% 5% 5% 15% 45% 50% 50% \n\n0 \n\n1 \n\n2 \n\n3 \n\n4 \n\n5 \n\n6 \n\n7 \n\n1 2 3 4 6 8 10 \n\nTransmission time [s] \n\nHop number \n\nAvg TX time \n\n95% CI \n\nFigure 3.25 Experimental results: average transmission time with 95% Con\ufb01dence Interval (CI), as a function of the number of hops from source to destination. \n\nwith eight or more hops. The packet loss under the IEEE 802.15.4 protocol is mainly due to collisions between packets and limited bu\ufb00er queues. In fact, when a node acting as relay tries to forward a packet, it may still \ufb01nd the medium busy because of another data transmission. Since queue sizes at nodes are limited and intermediate nodes cannot store all the received data, the network experiences signi\ufb01cant packet loss. Figure 3.25 shows the average time required to send an IPv6 packet \u2013 part of a 20-packet stream \u2013 between source and destina- tion, as a function of the number of hops. As expected, this time is approximately a linearly increasing function of the number of hops. In Figure 3.26, the performance of an IEEE 802.15.4 network, in terms of packet-loss rate, is shown as a function of the number of hops. In this case, the o\ufb00ered load on the network is given by a 1 min long 1008 B/s stream; that is, 60kB. This makes the performance even worse: the packet-loss rate increases to 39% for a four-hop transmission and to 53.75% for a six-hop transmission. \n\n3.8 Optimized Communications: the Dual-network Management Protocol 129 \n\n0 \n\n10 \n\n20 \n\n30 \n\n40 \n\n50 \n\n60 \n\n70 \n\nPacket loss [%] \n\n1 2 3 4 6 8 10 Hop number \n\nFigure 3.26 Experimental results: packet-loss rate as a function of the number of hops from source to destination. \n\nThe results show that a multi-hop IEEE 802.15.4 network cannot meet the strict requirements of real-time streaming applications, in terms of packet-loss rate and delay, in networks where communica- tion routes may have more than four hops. However, in the case of very low-rate audio streaming over networks with a small value of the max- imum number of hops, such requirements could be met. It must be remarked that there will always be a limitation on the stream duration: injecting more data into the network (say, by transmitting for 1 min at 1008 B/s) may lead to a breakdown of the IEEE 802.15.4 network, thus making communications impractical. Therefore, high-bandwidth and high-performance services cannot run on IEEE 802.15.4 networks. \n\n3.8.6 IEEE 802.15.4-controlled Selective Activation of the IEEE 802.11s Network \n\nWhile IEEE 802.15.4 is suitable for lightweight tasks, requiring the transmission of only small amounts of data, as shown above it is not possible to rely on it for real-time, high-bandwidth, and low-latency applications. The next phase of our experimentation aims at determining the threshold amount of data that makes it more convenient to rely on DNMP to activate a HPHT network. We refer to the same linear topology considered in Section 3.8.5.1: while for the IEEE 802.15.4 network, four hops are needed, only two hops are needed for IEEE 802.11s network. We consider the transmission of a \ufb01xed amount of application data (payload) and analyze the \n\n130 3 Interoperability \n\ntime required to transmit the payload with the proposed hybrid IEEE 802.15.4/IEEE 802.11s approach (with DNMP). As considered in Section 3.8.5.2, in the IEEE 802.15.4 network the payload is inserted into UDP/6LoWPAN packets of 300 B (i.e., 252 B of payload per packet at the application layer). In the IEEE 802.11s network, the payload is sent in a standard UDP/IPV4 packet. Referring to DNMP, the total transmission time is made up of: \n\n\u2022 the transmission time of the DNMP LOCK message from the source to the destination (IEEE 802.15.4 network); \u2022 the time needed to turn the IEEE 802.11s interfaces on (IEEE 802.11s network); \u2022 the time to create high-speed routes successfully (IEEE 802.11s net- work). \n\nThe performance comparison was carried out by considering the mean round trip time (RTT) of a DNMP message in the deployed \ufb01ve-node IEEE 802.15.4 network. In particular, the RTT accounts for: \n\n\u2022 the transmission of the DNMP request message; \u2022 the processing of the message at the application layer by Contiki OS on each relay node; \u2022 the transmission of the response back to the source node. \n\nThe time between the instant when the IEEE 802.11s interface is switched on and the instant when the transmission towards the destination is possible has been experimentally measured at 3.237 s. This delay is due to kernel calls that start the radio networking and the tra\ufb03c needed by the HWMP protocol to set up the routing. In Figure 3.27, the time (dimension: [s]) required for the data to reach the destination is shown as a function of the payload size (dimension: [B]). While the time required using only the IEEE 802.15.4 network increases signi\ufb01cantly with the payload size, with DNMP, after an initial setup time, the transmission time still increases, but almost negligibly with respect to the single IEEE 802.15.4 net- work case. The results show that the threshold below which the DNMP-based approach becomes ine\ufb03cient is \u223c2 kB. \n\n3.8.7 Conclusions \n\nDNMP is an innovative IP-based application-layer protocol that allows high-bandwidth radio interfaces to be adaptively turned \n\n3.9 Discoverability in Constrained Environments 131 \n\n12 \n\n1008 \n\n2016 \n\n4032 \n\n8064 \n\n10 \n\n8 \n\n6 \n\n4 \n\n2 \n\nApplicative payload [B] \n\nTransmission time [s] \n\nDNMP with IEEE 802.11s IEEE 802.15.4 \n\n0 \n\nFigure 3.27 Experimental results: transmission time as a function of the payload size using IEEE 802.15.4 and IEEE 802.11s. \n\non and o\ufb00, in order to support high-throughput and low-latency transmissions. In particular, it only requires the presence of an LPLT interface (acting as both data and control plane) to activate an HPHT interface (data plane). By leveraging on the routes created by the LPLT network, nodes manage to signal and wake up only the minimum set of nodes that guarantee data transmission via the HPHT network. In order to provide an exhaustive performance evaluation of DNMP, we integrated an IEEE 802.15.4 transceiver (LPLT) and an IEEE 802.11s (HPHT) transceiver on a Raspberry Pi. We then investigated the performance of the DNMP-based overlaid networks, determining the critical threshold, in terms of amount of data to be transmitted, beyond which the use of DNMP becomes advantageous. In the considered experimental scenario this critical threshold is \u223c2 kB. \n\n3.9 Discoverability in Constrained Environments \n\n3.9.1 CoRE Link Format \n\nThe Constrained RESTful Environments (CoRE) approach imple- ments the REST architecture in way that supports constrained smart objects and networks (e.g., 6LoWPAN). The discovery of resources hosted by a server is fundamental for M2M scenarios. The HTTP \u201cweb discovery\u201d of resources is de\ufb01ned in RFC 2616 [2] and the description \n\n132 3 Interoperability \n\nof relations between resources is de\ufb01ned as \u201cweb linking\u201d [12]. The CoRE Link Format speci\ufb01cation [13] de\ufb01nes the discovery of resources hosted by a constrained web server, their attributes, and other resource relations such as CoRE resource discovery. The main function of such a discovery mechanism is to provide universal resource identi\ufb01ers (URIs, commonly called \u201clinks\u201d) for the resources hosted by the smart object. The resources are com- plemented by attributes about those resources and possible further link relations. In CoRE, this collection of links is represented as a resource of its own (in contrast to the HTTP headers, which are delivered along with a speci\ufb01c resource). The RFC document speci\ufb01es a link format for use in CoRE resource discovery by extending the HTTP Link header format [12] to describe these link descriptions. The CoRE Link Format is carried as a payload and is assigned an Internet media type. A \u201cwell-known\u201d relative URI /.well-known/ core is de\ufb01ned as a default entry point for requesting the list of links about resources hosted by a server node and thus performing CoRE resource discovery. This approach is suitable for adoption in combination with CoAP, HTTP, or any other web transfer protocol. The link format can also be saved in \ufb01le format. The CoRE Link Format is a serialization of a typed link describing the relationships between resources: so-called \u201cweb linking\u201d. In the RFC, web linking is extended with speci\ufb01c constrained M2M attributes; links are carried as a message payload rather than in an HTTP link header \ufb01eld, and a default interface is de\ufb01ned to discover resources hosted by a server. This speci\ufb01cation also de\ufb01nes a new relation type: \u201chosts\u201d. These identify that the resource is hosted by the server from which the link document was requested. In HTTP, the link header is used to keep link information about a resource along with an HTTP response. In CoRE, the main use case for web linking is the discovery of which resources a server hosts in the \ufb01rst place. Some resources may have additional links associated with them and, for that reason, the CoRE link format serialization is carried as a resource representation of the well-known URI. The CoRE link format reuses the format of HTTP link header serialization. \n\n3.9.1.1 CoRE Link Format: Discovery In IoT applications, there is the concrete need for local clients and servers to \ufb01nd and interact with each other without human intervention or any prior con\ufb01guration. The CoRE Link Format can \n\n3.9 Discoverability in Constrained Environments 133 \n\nbe used by smart objects hosting resources in such environments so as to enable discovery of the resources hosted by the server. Resource discovery can be performed either in unicast or multicast mode. When a server\u2019s IP address is already known, either a priori or resolved via the DNS [50, 51], unicast discovery is performed in order to locate the entry point to the resource of interest. In CoRE Link Format, this is performed using a GET to /.well-known/core on the server, which returns a payload in the CoRE Link Format. A client would then match the appropriate resource type, interface description, and possible media type [52] for its application. These attributes may also be included in the query string in order to \ufb01lter the number of links returned in a response. Multicast resource discovery is useful when a consumer wants to locate a resource within a limited local scope, and that scope supports IP multicast. A GET request to the appropriate multicast address is made for /.well-known/core. In order to limit the number and size of responses, a query string is submitted with the known attributes of the resource. Typically, a resource would be discovered based on its resource type and/or interface description, along with possible application-speci\ufb01c attributes. \n\n3.9.1.2 Link Format The CoRE Link Format (see Listing 3.1) extends the HTTP Link header \ufb01eld speci\ufb01ed in RFC 5988 [12]. The format is compact and exten- sible does not require special XML or binary parsing. This link for- mat is just one serialization of the typed links de\ufb01ned in the stardard; others include HTML links, Atom feed links [53], and HTTP Link header \ufb01elds. The CoRE link format de\ufb01nes the Internet media type \u201capplication/link-format\u201d, encoded as UTF-8. UTF-8 data can be com- pared bitwise, which allows values to contain UTF-8 data without any added complexity for constrained nodes. The CoRE Link Format is equivalent to the RFC 5988 ([12]) Link Format, but the augmented Backus-Naur form in the present speci\ufb01cation is repeated along with some improvements, so as to be compliant with RFC 5234 [54]. It also includes new link parameters. The link parameter \u201chref\u201d is reserved for use as a query parameter for \ufb01ltering in this speci\ufb01cation, and must not be de\ufb01ned as a link parameter. Multiple link descriptions are separated by commas. Note that commas can also occur in quoted strings and URIs but do not end a description. In order to convert an HTTP link header \ufb01eld to this link format, the \u201cLink:\u201d HTTP header is removed, \n\n134 3 Interoperability \n\nany linear whitespace is removed, the header value is converted to UTF-8, and any percent- encodings are decoded. \n\nListing 3.1 CoRE link format speci\ufb01cation as in RFC 6690. Link = link-value-list link-value-list = [ link-value *[ \",\" link-value ]] link-value = \"<\" URI-Reference \">\" *( \";\" link-param ) link-param = ( ( \"rel\" \"=\" relation-types ) / ( \"anchor\" \"=\" DQUOTE URI-Reference DQUOTE ) / ( \"rev\" \"=\" relation-types ) / ( \"hreflang\" \"=\" Language-Tag ) / ( \"media\" \"=\" ( MediaDesc / ( DQUOTE MediaDesc DQUOTE ) ) ) / ( \"title\" \"=\" quoted-string ) / ( \"title*\" \"=\" ext-value ) / ( \"type\" \"=\" ( media-type / quoted-mt ) ) / ( \"rt\" \"=\" relation-types ) / ( \"if\" \"=\" relation-types ) / ( \"sz\" \"=\" cardinal ) / ( link-extension ) ) link-extension = ( parmname [ \"=\" ( ptoken / quoted-string ) ] ) / ( ext-name-star \"=\" ext-value ) ext-name-star = parmname \"*\" ; reserved for RFC-2231-profiled ; extensions. Whitespace NOT ; allowed in between. ptoken = 1*ptokenchar ptokenchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"\u2019\" / \"(\" / \")\" / \"*\" / \"+\" / \"-\" / \".\" / \"/\" / DIGIT / \":\" / \"<\" / \"=\" / \">\" / \"?\" / \"@\" / ALPHA / \"[\" / \"]\" / \"\u2227\" / \"_\" / \"\u2018\" / \"{\" / \"|\" / \"}\" / \"\u223c\" media-type = type-name \"/\" subtype-name quoted-mt = DQUOTE media-type DQUOTE relation-types = relation-type / DQUOTE relation-type *( 1*SP relation-type ) DQUOTE relation-type = reg-rel-type / ext-rel-type reg-rel-type = LOALPHA *( LOALPHA / DIGIT / \".\" / \"-\" ) ext-rel-type = URI cardinal = \"0\" / ( %x31-39 *DIGIT ) LOALPHA = %x61-7A ; a-z quoted-string = <defined in [RFC2616]> \n\n3.9 Discoverability in Constrained Environments 135 \n\nURI = <defined in [RFC3986]> URI-Reference = <defined in [RFC3986]> type-name = <defined in [RFC4288]> subtype-name = <defined in [RFC4288]> MediaDesc = <defined in [W3C.HTML.4.01]> Language-Tag = <defined in [RFC5646]> ext-value = <defined in [RFC5987]> parmname = <defined in [RFC5987]> \n\n3.9.1.3 The Interface Description Attribute The interface description \u201cif\u201d attribute is an opaque string used to pro- vide a name or URI indicating a speci\ufb01c interface de\ufb01nition used to interact with the target resource. This attribute describes the generic REST interface to interact with a resource or a set of resources. It is expected that an interface description will be reused by di\ufb00erent resource types, for example the resource types \u201coutdoor-temperature\u201d, \u201cdew-point\u201d, and \u201crel-humidity\u201d. Multiple interface descriptions may be included in the value of this parameter, each separated by a space, similar to the relation attribute. The interface description can be also the URI of a web appli- cation description language (WADL) de\ufb01nition of the target resource http://www.example.org/myapp.wadl#sensor, a URN indicating the type of interface to the resource, such as \u201curn:myapp:sensor\u201d, or an application-speci\ufb01c name, such as \u201csensor\u201d. The Interface Description attribute must not appear more than once in a link. \n\n3.9.2 CoRE Interfaces \n\nThe resource discovery o\ufb00ered by a smart object is a fundamental ele- ment in IoT applications. The discovery of resources provided by an HTTP web server is de\ufb01ned by the web linking RFC [12] and its adop- tion for the description and discovery of resources hosted by smart objects is speci\ufb01ed by the CoRE Link Format 3.9.1 and can be used by CoAP or HTTP servers. The CoRE Link Format de\ufb01nes an attribute that can be used to describe the REST interface of a resource, and may include a link to a description document. The CoRE Interfaces document [55] de\ufb01nes the well-known REST interface descriptions for resource types in constrained environments using the CoRE Link Format standard. A short reference is provided for each type that can be e\ufb03ciently included in the interface descrip- tion attribute (if=) of the CoRE Link Format. A client discovering \n\n136 3 Interoperability \n\nthe \u201cif\u201d link attribute will be able to consume resources based on its knowledge of the expected interface types. In this sense, the interface type acts in a similar way as a content-format, but as a selector for a high-level functional abstraction. The main de\ufb01ned REST interfaces are related to the following resources: \n\n\u2022 sensor \u2022 parameter \u2022 read-only parameter \u2022 actuator. \n\nEach of them is described with the corresponding value of the interface description attribute (if) and the associated valid methods. These interfaces can support plain text and/or Sensor Markup Language (SenML) media types (see Section 3.10). Table 3.8 and Sections 3.9.2.1\u20133.9.2.4 will present available interfaces and their characteristics. When a value for the if= attribute appears in a link, the associated resource must implement and support the associated standard REST interface and may support additional functionality. This approach has been designed to work within the context of CoRE link format speci- \ufb01cations, but is applicable for REST interface de\ufb01nitions. \n\n3.9.2.1 Sensor The sensor interface allows the reader to access the value of a sensor resource through a GET request. The media type of the resource can be plain text or SenML. The former may be used for a single measurement that does not require metadata and, for a measure- ment with metadata such as a unit or time stamp, SenML is the best approach. A resource with this type of interface can also use SenML to \n\nTable 3.8 Interface description summary. \n\nInterface if= Methods Content-Formats \n\nSensor core.s GET link-format,text/plain \n\nParameter core.p GET, PUT link-format,text/plain \n\nRead-only Parameter core.rp GET link-format,text/plain \n\nActuator core.a GET, PUT, POST link-format,text/plain \n\n3.9 Discoverability in Constrained Environments 137 \n\nreturn multiple measurements in the same representation. Listing 3.2 reports some examples of sensor interface requests in both text/plain and application/senml+json formats. \n\nListing 3.2 Examples of sensor interface requests. \n\nReq: GET /s/humidity (Accept: text/plain) Res: 2.05 Content (text/plain) 80 Req: GET /s/humidity (Accept: application/senml+json) Res: 2.05 Content (application/senml+json) {\"e\":[ { \"n\": \"humidity\", \"v\": 80, \"u\": \"%RH\" }], } \n\n3.9.2.2 Parameter The parameter interface allows con\ufb01gurable parameters/information to be modeled as a resource. The value of the parameter can be read using a GET or updated using a PUT request. Both plain text or SenML media types can be returned. The following example shows a request for reading and updating a parameter resource. \n\nListing 3.3 Request for reading and updating a parameter resource. \n\nReq: GET /d/name Res: 2.05 Content (text/plain) node5 Req: PUT /d/name (text/plain) outdoor Res: 2.04 Changed \n\n3.9.2.3 Read-only Parameter Following the same approach as for the parameter interface, the read-only parameter interface only allows the reader to access the parameter\u2019s con\ufb01guration using a GET request. Plain text or SenML media types may be returned from this type of interface and Listing 3.4 shows an example. \n\nListing 3.4 Example of read-only parameter interface. \n\nReq: GET /d/model Res: 2.05 Content (text/plain) SuperNode200 \n\n3.9.2.4 Actuator The actuator interface is associated with resources that model di\ufb00erent kinds of actuators. Examples of actuators include LEDs, relays, motor \n\n138 3 Interoperability \n\ncontrollers and light dimmers. The value associated to the the actuator can be read using a GET and updated through a PUT request. Further- more, this interface allows the use of POST to change the state of an actuator, for example to toggle between its possible values. Plain text or SenML media types can be used and returned for this interface cat- egory. SenML can be also used to include multiple measurements in the same representation. An example would be a list of recent actua- tor values or a list of values to update. Listing 3.5 shows requests for reading, setting and toggling an actuator (associated with an LED). \n\nListing 3.5 Requests to change an actuator. \n\nReq: GET /a/1/led Res: 2.05 Content (text/plain) 0 Req: PUT /a/1/led (text/plain) 1 Res: 2.04 Changed Req: POST /a/1/led (text/plain) Res: 2.04 Changed Req: GET /a/1/led Res: 2.05 Content (text/plain) 0 \n\n3.10 Data Formats: Media Types for Sensor Markup Language \n\nConnecting sensors to the internet is not new, and there have been many protocols designed to facilitate the process. The SenML speci\ufb01- cation [56] de\ufb01nes new media types to embed simple sensor informa- tion in application protocols, such as HTTP and CoAP. The format was designed so that processors with very limited capabilities could easily encode a sensor measurement into the media type, while at the same time a server parsing the data could relatively e\ufb03ciently collect a large number of sensor measurements. SenML is de\ufb01ned by a data model for measurements and simple metadata about measurements and devices. The data is structured as a single object (with attributes) that contains an array of entries. Each entry is an object that has attributes, such as a unique identi\ufb01er for the sensor, the time the measurement was made, and the current value. Serializations for this data model are de\ufb01ned for JSON, XML and E\ufb03cient XML Interchange (EXI). \n\n3.10 Data Formats: Media Types for Sensor Markup Language 139 \n\nThis approach allows a server to e\ufb03ciently parse large numbers of measurements. SenML can be adopted to data \ufb02ow models, data feeds pushed from a sensor to a collector, and to the web resource model, where the sensor is requested as a resource representation (e.g., \u201cGET/sensor/temperature\u201d). SenML strikes a balance between having some information about the sensor carried with the sensor data so that the data is self-describing but also making that a fairly minimal set of auxiliary information, for e\ufb03ciency reasons. Other information about the sensor can be discovered by other methods such as using the CoRE link format. For example, Listing 3.6 shows a measurement from a tem- perature gauge encoded in the JSON syntax. The array has a single SenML record with a measurement for a sensor labelled as \u201curn:dev:ow:10e2073a01080063\u201d with a current value of 23.1\u2218C. \n\nListing 3.6 Temperature measurement encoded in JSON. \n\n[ {\"n\":\"urn:dev:ow:10e2073a01080063\",\"u\":\"Cel\",\"v\":23.1} ] \n\nSenML is de\ufb01ned by a data model for measurements and simple metadata about measurements and devices. The data is structured as a single array containing a list of SenML records. Each record contains \ufb01elds such as an unique identi\ufb01er for the sensor, the time, the mea- surement, the unit the measurement is recorded in, and the current value of the sensor. Serializations for this data model are de\ufb01ned for JSON, CBOR, XML, and E\ufb03cient XML Interchange (EXI). SenML\u2019s main concepts and elements are: \n\n\u2022 SenML record: One measurement or con\ufb01guration instance in time presented using the SenML data model. \u2022 SenML pack: One or more SenML records in an array structure. \u2022 SenML label: A short name used in SenML records to denote dif- ferent SenML \ufb01elds (e.g., \u201cv\u201d for \u201cvalue\u201d). \u2022 SenML \ufb01eld: A component of a record that associates a value to a SenML label for this record. \n\nEach SenML pack carries a single array that represents a set of mea- surements and/or parameters. This array contains a series of SenML \n\n140 3 Interoperability \n\nrecords with various \ufb01elds, as described below. There are two kinds of \ufb01elds: base and regular. The base \ufb01elds can be included in any SenML record and they apply to the entries in the record. Each base \ufb01eld also applies to all records after it, up to, but not including the next record that has that same base \ufb01eld. All base \ufb01elds are optional. Regular \ufb01elds can be included in any SenML record and apply only to that record. Basic \ufb01elds associated with SenML records are: \n\n\u2022 Base name: A string prepended to the names found in the entries. \u2022 Base time: A base time that is added to the time found in an entry. \u2022 Base unit: A base unit that is assumed for all entries, unless other- wise indicated. If a record does not contain a unit value, then the base unit is used. Otherwise the value found in the unit (if any) is used. \u2022 Base Value: A base value is added to the value found in an entry, similar to base time. \u2022 Base sum: A base sum is added to the sum found in an entry, similar to base time. \u2022 Version: Version number of media type format. This \ufb01eld is an optional positive integer and defaults to 5 if not present. \n\nRegular \ufb01elds are: \n\n\u2022 Name: Name of the sensor or parameter. When appended to the base n Name \ufb01eld, this must result in a globally unique identi\ufb01er for the resource. The name is optional if the base name is present. If the name is missing, base name must uniquely identify the resource. This can be used to represent a large array of measurements from the same sensor without having to repeat its identi\ufb01er on every mea- surement. \u2022 Unit: Units for a measurement value. Optional. \u2022 Value: Value of the entry. Optional if a sum value is present, otherwise required. Values are represented using basic data types. This speci\ufb01cation de\ufb01nes \ufb02oating point numbers (\u201cv\u201d \ufb01eld for value), Booleans (\u201cvb\u201d for Boolean value), strings (\u201cvs\u201d for string value) and binary data (\u201cvd\u201d for data value). Exactly one value \ufb01eld must appear unless there is sum \ufb01eld, in which case it is allowed to have no value \ufb01eld. \u2022 Sum: Integrated sum of the values over time. Optional. This \ufb01eld is in the units speci\ufb01ed in the unit value multiplied by seconds. \u2022 Time: Time when value was recorded. Optional. \n\n3.10 Data Formats: Media Types for Sensor Markup Language 141 \n\nTable 3.9 JSON SenML labels. \n\nSenML Label JSON Type \n\nBase name bn String \n\nBase time bt Number \n\nBase units bu String \n\nBase balue bv Number \n\nBase dum bs Number \n\nVersion bver Number \n\nName n String \n\nUnit u String \n\nValue v Number \n\nString value vs String \n\nBoolean value vb Boolean \n\nData value vd String \n\nValue sum s Number \n\nTime t Number \n\nUpdate time ut Number \n\nLink l String \n\n\u2022 Update time: An optional time in seconds that represents the max- imum time before this sensor will provide an updated reading for a measurement. This can be used to detect the failure of sensors or communications paths from them. \n\nTable 3.9 shows the JSON representation (application/senml+json) for SenML \ufb01elds. The SenML labels are used as the JSON object member names in JSON objects representing JSON SenML records. Examples of SenML use are presented in Section 3.10.1. \n\n3.10.1 JSON Representations \n\n3.10.1.1 Single Datapoint Listing 3.7 shows a temperature reading taken approximately \u201cnow\u201d by a one-wire sensor device that was assigned the unique one-wire address of 10e2073a01080063. \n\n142 3 Interoperability \n\nListing 3.7 Temperature reading from one-wire device at unspeci\ufb01ed time. \n\n[ {\"n\":\"urn:dev:ow:10e2073a01080063\",\"u\":\"Cel\",\"v\":23.1} ] \n\n3.10.1.2 Multiple Datapoints Listing 3.8 shows voltage and current \u201cnow\u201d in the JSON representa- tion; that is at an unspeci\ufb01ed time. \n\nListing 3.8 Voltage and current measurements at unspeci\ufb01ed time. \n\n[ {\"bn\":\"urn:dev:ow:10e2073a01080063:\",\"n\":\"voltage\", \"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"u\":\"A\",\"v\":1.2} ] \n\nListing 3.9 is similar, but shows the current on Tuesday 9 June 2010 at 18:01:16.001 UTC and at each second for the previous 5 s. \n\nListing 3.9 Temperature readings at speci\ufb01ed dates and times. \n\n[ {\"bn\":\"urn:dev:ow:10e2073a0108006:\", \"bt\":1.276020076001e+09,\"bu\":\"A\",\"bver\":5, \"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}, {\"n\":\"current\",\"t\":-3,\"v\":1.4}, {\"n\":\"current\",\"t\":-2,\"v\":1.5}, {\"n\":\"current\",\"t\":-1,\"v\":1.6}, {\"n\":\"current\",\"v\":1.7} ] \n\n3.10.1.3 Multiple Measurements Listing 3.10 shows humidity measurements from a mobile device with a one-wire address 10e2073a01080063, starting at Monday 31 October 2011 at 13:24:24 UTC. The device also provides position data, which is provided in the same measurement or parameter array as separate entries. Note that the time is used for correlating data that belongs together, such as a measurement and a parameter associated with it. Finally, the device also reports extra data about its battery status at a separate time. \n\n3.10 Data Formats: Media Types for Sensor Markup Language 143 \n\nListing 3.10 Multiple humidity measurements. \n\n[ {\"bn\":\"urn:dev:ow:10e2073a01080063\", \"bt\":1.320067464e+09,\"bu\":\"%RH\",\"v\":20}, {\"u\":\"lon\",\"v\":24.30621}, {\"u\":\"lat\",\"v\":60.07965}, {\"t\":60,\"v\":20.3}, {\"u\":\"lon\",\"t\":60,\"v\":24.30622}, {\"u\":\"lat\",\"t\":60,\"v\":60.07965}, {\"t\":120,\"v\":20.7}, {\"u\":\"lon\",\"t\":120,\"v\":24.30623}, {\"u\":\"lat\",\"t\":120,\"v\":60.07966}, {\"u\":\"%EL\",\"t\":150,\"v\":98}, {\"t\":180,\"v\":21.2}, {\"u\":\"lon\",\"t\":180,\"v\":24.30628}, {\"u\":\"lat\",\"t\":180,\"v\":60.07967} ] \n\n145 \n\n4 \n\nDiscoverability \n\nThe IoT is envisioned to bring together billions of devices, or \u201csmart objects\u201d, by connecting them in an Internet-like structure, allowing them to communicate and exchange information and to enable new forms of interaction among things and people. Smart objects are typically equipped with a microcontroller, a radio interface for com- munication, sensors and/or actuators. Smart objects are constrained devices, with limited capabilities in terms of computational power and memory. They are typically battery-powered, thus introducing even more constraints on energy consumption: this motivates the quest for energy-e\ufb03cient technologies, communication/networking protocols, and mechanisms. Internet Protocol (IP) has been widely envisaged as the true IoT enabler, as it allows full interoperability among heterogeneous objects. As part of the standardization process that is taking place, new low-power protocols are being de\ufb01ned in international organizations, such as the IETF and the IEEE. \n\n4.1 Service and Resource Discovery \n\nTogether with application-layer protocols, suitable mechanisms for service and resource discovery should be de\ufb01ned. In particular, CoAP de\ufb01nes the term service discovery as the procedure used by a client to learn about the endpoints exposed by a server. A service is discovered by a client by learning the Uniform Resource Identi\ufb01er (URI) [28] that references a resource in the server namespace. Resource discov- ery is related to the discovery of the resources o\ufb00ered by a CoAP endpoint. In particular, M2M applications rely on this feature to keep applications resilient to change, and therefore not requiring human \n\nInternet of Things: Architectures, Protocols and Standards, First Edition. Simone Cirani, Gianluigi Ferrari, Marco Picone, and Luca Veltri. \u00a9 2019 John Wiley & Sons Ltd. Published 2019 by John Wiley & Sons Ltd. \n\n146 4 Discoverability \n\nintervention. A resource directory (RD) [14] is a network element hosting the description of resources held on other servers, allowing lookups to be performed for those resources. A crucial issue for the robust applications, in terms of resilience to changes that might occur over time (e.g., availability, mobility, or resource description), and the feasible deployment of (billions of) smart objects is the availability of mechanisms that minimize, if not remove, the need for human intervention for the con\ufb01guration of newly deployed objects. The RESTful paradigm is intended to promote software longevity and independent evolution [29], both of which are extremely important for IoT and M2M applications deployed on smart objects that are expected to stay operational for long periods; say, years. Self-con\ufb01guring service and resource discovery mechanisms should take into account the di\ufb00erent scopes that these operations might have: \n\n\u2022 in a local scope, they should enable communication between geo- graphically concentrated smart objects; that is, residing in the same network; \u2022 in a global (large-scale) scope, they should enable communication between smart objects residing in di\ufb00erent (and perhaps geograph- ically distant) networks. \n\nThese approaches should also be scalable, since the expected number of deployed objects is going to be of the order of billions. Self-con\ufb01guration is another crucial feature for the di\ufb00usion of IoT systems, where all the objects equipped with a radio interface are potential sources of information to be interconnected. An external operator managing a network \ufb01rst needs to con\ufb01gure the system. Clearly, if this operation is carried out manually, there may be mis- con\ufb01gurations. This is far more likely when thousands of devices are involved. In addition, an occasional manual network recon\ufb01guration may cause a signi\ufb01cant system outage, just as, in an industrial plant, machines may need to be stopped for normal maintenance. For this reason, a self-con\ufb01gurable IoT system is a good way to prevent long outages and con\ufb01guration errors. \n\n4.2 Local and Large-scale Service Discovery \n\nIn the literature, there are already mechanisms for implementing ser- vice discovery. Most of these, however, were originally conceived for \n\n4.2 Local and Large-scale Service Discovery 147 \n\nLANs and were then extended for constrained IPv6 over low-power wireless personal area networks (6LoWPANs). One of these mecha- nisms is Universal Plug and Play (UPnP) [57], a protocol that allows for automatic creation of a device-to-device network. However, as UPnP uses TCP as the transport protocol and XML as the message exchange format, it is not suited to constrained devices. Another proposed mechanism is based on the Service Location Protocol (SLP) [58, 59] through which computers and devices can \ufb01nd services in LANs without prior con\ufb01guration. Devices use SLP to announce the services they provide in the local network; these are grouped into scopes: simple strings that classify the services. The use of SLP may be important in large-scale IoT scenarios, in order to make service discovery automatic. However, SLP does not target constrained devices like those used in the IoT. In addition, it relies on centralized approaches, which may be prone to failure. Finally, up to now, no SLP implementation has been available for Contiki-based devices. Another alternative to UPnP is the Zero-con\ufb01guration (Zero- conf) [60] networking protocol, which allows for automatic creation of computer networks based on the TCP/IP Internet stack and does not require any external con\ufb01guration. Zeroconf implements three main functionalities: \n\n\u2022 automatic network address assignment; \u2022 automatic distribution and resolution of host names; \u2022 automatic location of network services. \n\nAutomatic network assignment intervenes when a node \ufb01rst con- nects to the network. The host name distribution and resolution is implemented using multicast DNS (mDNS) [61], a service that has the same interfaces, packet formats, and semantics as standard DNS messages to resolve host names in networks that do not include a local name server. In the service discovery phase, Zeroconf implements DNS-based Service Discovery (DNS-SD) [62]. Using standard DNS queries, a client can discover, for a given domain, the named instances of the service of interest. In the \ufb01eld of ubiquitous computing, PIAX, a P2P platform for geo- graphic service location, has been proposed [63, 64]. In PIAX, every node is a peer of the overlay. This approach is not suitable for the IoT, since many nodes are constrained in terms of processing capabilities. In addition, PIAX does not provide a URI resolution service, so that it \n\n148 4 Discoverability \n\ncan only try to route the query to the correct area of the network but cannot resolve the endpoint to be contacted. E\ufb00orts have been made to adapt these solutions to the world of con- strained devices. Busnel et al. introduced a P2P overlay to perform broadcast or anycast in wireless sensor networks (WSNs) without any centralized element [65]. Sensors were clustered according to their types into speci\ufb01c layers. However, they took into account neither local service discovery nor computational complexity due to the existence of nodes belonging to di\ufb00erent layers. Gutierrez et al. instead introduced a separation between WSNs and P2P networks [66]. Their focus was on exploiting these two types of network to develop a feedback loop to allow developers to de\ufb01ne self-managing behaviors. However, they did not take into account aspects like energy e\ufb03ciency, self-discovery of resources, or large-scale deployments. Leguay et al. implemented an automatic discovery mechanism [67]. In their approach each node is responsible for announcing itself to the main gateway through HELLO messages. These messages are sent either in response to a discovery request or proactively sent in an auto- matic way. The gateway is then be in charge of addressing the requests coming from external networks to the correct nodes. Kovacevic et al. have proposed NanoSD, a lightweight service discovery protocol designed for highly dynamic, mobile, and het- erogeneous sensor networks [68]. Their solution requires extensive multicast and broadcast messages to keep track of service information of the neighboring nodes. Another solution was presented by Mayer and Guinard [69]. They developed a RESTFul web service using HTTP-based service discov- ery. However, their approach does not provide management and status maintenance of existing services. Finally, Butt et al. divided the network into groups, assigning di\ufb00er- ent roles to the nodes in each group [70]. Embedding a directory agent into the border router makes scalability easier. However, this architec- ture tends to be too fragile in the presence of failures of the central border router. In addition, the protocol focuses on in-network service location, but it lacks coordination with other similar entities, thus pre- venting large-scale discovery. A few papers related to service discovery in IoT systems have appeared. Jara et al. sketched an architecture for large-scale service discovery and location [71]. However, theirs was a centralized solution, \n\n4.2 Local and Large-scale Service Discovery 149 \n\nexposing a search engine to make the integration of distributed service directories feasible. Paganelli and Parlanti exploited an underlying distributed P2P overlay to support more complex queries, such as multi-attribute and range queries [72]. This approach is more focused on service resolution rather than on the creation of the overlay by automatically discovering existing services. Unlike our approach, which aims at being transparent and agnostic of the underlying technology, several P2P overlays presented in the literature focus on RFID for supply chains [73\u201375]. CoAP natively provides a mechanism for service discovery and location [7]. Each CoAP server must expose an interface /.well- known/core, to which the RD or, more generally, a generic node can send requests for discovering available resources. The CoAP server will reply with the list of resources and, for each resource, an attribute that speci\ufb01es the format of the data associated with that resource. CoAP, however, does not specify how a node joining the network for the \ufb01rst time must behave in order to announce itself to the resource directory node. In the IETF\u2019s latest draft for CoAP [76], this functionality is extended to multicast communications. In particular, multicast resource discov- ery can be useful when a client needs to locate a resource within a limited scope, and that scope supports IP multicast. A GET request to the appropriate multicast address is made for /.well-known/ core. Of course, multicast resource Discovery works only within an IP multicast domain and does not scale to larger networks that do not support end-to-end multicast. However, in CoAP there is no speci\ufb01- cation on how a remote client can lookup the RD and query for the resource of interest. Peer-to-peer (P2P) networks have been designed to provide some desirable features for large-scale systems, such as scalability, fault-tolerance, and self-con\ufb01guration. The main feature that makes P2P networks appealing is the fact that as the number of participating nodes increases, the overall system capacity (in terms of processing and storage capabilities) increases as well. This challenges classical client/server architectures, where an increase in the number of clients may bring the system to saturation and/or failure. P2P networks arrange participating nodes in an overlay network, built on top of an existing network, such as the Internet. The algorithm through which the overlay is created can be used to make a distinction between \n\n150 4 Discoverability \n\nstructured and unstructured P2P networks. Structured P2P networks, such as distributed hash tables (DHTs), are built using consistent hashing algorithms, which guarantee that the routing of requests takes a deterministic and upper-bounded number of hops for completion, at the cost of having network tra\ufb03c for managing and maintaining the overlay. Historically, P2P networks have been associated with \ufb01le sharing applications, such as eMule1 and BitTorrent2. The decrease in the popularity of \ufb01le sharing applications has cooled interest in P2P, even though notable applications, such as Skype, have historically used a P2P overlay as backbone to provide a scalable and e\ufb03cient service. However, the features that P2P networks have been designed for are very appealing for IoT scenarios, where large-scale and robust applications need to be supported. IoT thus represents an opportunity of a renaissance for P2P. Centralized approaches for service discovery, such as the RD of the CoAP protocol, su\ufb00er from scalability and availability limitations and are prone to attacks, such as denial of service (DoS). Possible alterna- tives to this problem may consist of the use of DHTs. Key/value pairs are stored in a DHT and any participating node can e\ufb03ciently retrieve the value associated with a given key. Responsibility for maintaining the mapping from keys to values is distributed among the nodes in such a way that a change in the set of participants causes a minimal amount of disruption (consistent hashing). This allows a DHT to scale to extremely large numbers of nodes and to handle continuous node arrivals, departures, and failures. Several di\ufb00erent algorithms and protocols have already been proposed for DHTs; the most signi\ufb01cant are Chord [77] (for its simplicity) and Kademlia [78] (for its e\ufb03ciency). Some papers have also been published on the use of P2P for service discovery. Yulin et al. combine P2P technology and the centralized Universal Description Discovery and Integration (UDDI) technology to provide a \ufb02exible and reliable service discovery approach [79]. Ka\ufb03lle et al. apply the concepts of DHTs to the service discovery, creating an overlay P2P to exchange information about available services without \ufb02ooding the entire network [80]. However, these approaches do not take into account the constraints and requirements of IoT. In Section 4.3, we will detail our P2P implementation for large-scale service/resource discovery in IoT networks, extending the P2P DHT solution by taking \n\n1 http://www.emule-project.net/. 2 http://www.bittorrent.com/. \n\n4.2 Local and Large-scale Service Discovery 151 \n\ninto account the requirements of scalability and self-con\ufb01guration typical of constrained networks. \n\n4.2.1 ZeroConf \n\nZeroConf is an open standard originally designed by Apple. It allows services to be setup automatically within a network, without requiring manual con\ufb01guration. The IETF Zeroconf Working Group was formed in 1999 and has worked on the de\ufb01nitions and the standardization mechanisms required to achieve zero con\ufb01guration of services. ZeroConf is based on the combination of three functionalities: address selection, service name resolution, and service discovery. These functions are provided by the following suite of standards, respectively: \n\n\u2022 IPv4 link-local addressing [81]: this standard allows hosts to self-assign IP addresses in a network without relying on a DHCP server; \u2022 Multicast DNS [82]: this standard provides a way to resolve names to IP addresses without relying on a DNS server; \u2022 DNS service discovery (DNS-SD) [83]: this standard allows discov- ery of services within a network using the semantics of DNS mes- sages. \n\nThe ZeroConf suite allows services to be con\ufb01gured and discovered without requiring DHCP and DNS servers. It does this by making all hosts collectively responsible for publishing/discovering services and resolving names to addresses, simply by using the semantics of the DNS protocol and multicast communication. ZeroConf supports both IPv4 and IPv6, using multicast IP addresses 224.0.0.251 and \ufb0002::fb and UDP ports 53 and 5353, respectively. Service discovery typically occurs by searching for services of a given type in a particular domain; that is, matching the service type string of the form _ServiceName._ServiceType._TransportProtocolName. Domain. (for example, _http._tcp.local. or _coap._udp.local.) The service discovery process returns a list of services that comply with the searched type. Subsequently, a service with a given name can be resolved to an IP address and port number at which it can be accessed. In the case of a CoAP server, once discovered, a request can be issued to the server for its /.well-known/core in order to perform resource discovery. \n\n152 4 Discoverability \n\nSeveral implementations of ZeroConf are available, in essence for all platforms. Due to this widespread support, ZeroConf is a very good option for IoT smart objects that want to advertise their presence and allow other applications to discover them automatically with no man- ual con\ufb01guration. The limitation of ZeroConf is its reliance on multicast communica- tion, which is rarely propagated beyond the scope of the local network, making ZeroConf typically suitable only for local environments. How- ever, locally, ZeroConf provides an extremely convenient and elegant way to perform service discovery and can thus be adopted to deploy self-con\ufb01guring IoT applications. \n\n4.2.2 UPnP \n\nWith a similar intent to ZeroConf, the Universal Plug and Play (UPnP) protocol suite provides a way to perform dynamic and seamless discovery of devices in a network, without relying on DHCP and DNS servers. UPnP has been de\ufb01ned by the UPnP Forum and uses HTTPU/HTTPMU (HTTP over UDP and HTTP over multicast UDP) and SOAP to perform service description, discovery, and data transfer. UPnP suits home appliances rather than enterprise-level deployments due to its security and e\ufb03ciency issues. Many consumer-oriented smart objects, such as Philips Hue light bulbs, use UPnP as a zero-con\ufb01guration service discovery mechanism for bridges. \n\n4.2.3 URI Beacons and the Physical Web \n\nThe Physical Web, a concept promoted by Google, is a di\ufb00erent approach to provide seamless discovery and interaction with smart objects. The assumption behind the Physical Web is that the web itself provides all the necessary means for a fruitful interaction with any endpoint, be that a website or an object. As a consequence, the only operation that is needed in order to merge the physical world and the web is to discover the URL related to a web resource linked to a smart object. After that, a web browser is capable of delivering a user interface to the end user, which they can use to interact with the object (mediated by a backend that is actually connected to the object itself). The discovery mechanism de\ufb01ned by the Physical Web (and illustrated in Figure 4.1) is based on the use of URI beacons; that is, \n\n\n![Image](/src/assets/generated_images/iot_p165_i0.png)\n\nURI Beacon \n\nURL broadcast \n\nPhysical Web detects beacons and presents them to user \n\nURL 1 \n\nURL 2 \n\nURL 3 \n\nObject can be controlled \n\nWeb Content \n\nMobile App \n\nUpon click, user is directed to \n\nInteractive Website \n\n1 \n\n2 \n\n3 \n\n4 \n\nFigure 4.1 Physical Web discovery mechanism. \n\n154 4 Discoverability \n\nBluetooth Low Energy (BLE) devices broadcasting URLs. The use of BLE is particularly convenient because it is supported on the vast majority of user devices as well as having low energy consumption, which is important in order to ensure that battery-powered beacons can last as long as possible. The standard for data broadcasting over BLE is the Eddystone protocol, designed by Google. The Eddystone protocol de\ufb01nes four packet types: \n\n\u2022 Eddystone-UID, used to contain a beacon identi\ufb01er; \u2022 Eddystone-URL, used to broadcast a URL; \u2022 Eddystone-TLM, used for sending telemetry information \u2022 Eddystone-EID, used for carrying ephemeral IDs, in order to protect against replay attacks or spoo\ufb01ng. \n\nAlthough BLE is currently the only communication protocol that can be used to broadcast a URL, other options, such as mDNS or UPnP, can still be applied and might be supported in the future. The advantage in using URI beacons is the possibility to discover and interact with objects even if the user device is not connected to the same network. However, this bene\ufb01t may also become a downside, because the interaction with the object might not take into account context information related to the association of the user device with the network. Moreover, it may be unsafe in some scenarios to openly broadcast object URLs: it might raise security issues and it could be impossible to restrict discovery to only authorized devices. The Phys- ical Web is therefore particularly suited to public spaces, where no restricted access to objects should occur. \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT \n\nIn this section, we present a scalable and self-con\ufb01guring architec- ture for service and resource discovery in the IoT. aiming at provid- ing mechanisms requiring no human intervention for con\ufb01guration, thus simplifying the deployment of IoT applications. Our approach is based on: \n\n\u2022 at a large scale, P2P technologies, to provide a distributed large-scale service discovery infrastructure; \u2022 at a local scale, zero-con\ufb01guration mechanisms. \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 155 \n\nInformation on resources provided by smart objects attached to a local wireless network are gathered by a special boundary node, referred to as the \u201cIoT gateway\u201d. This is also part of a P2P overlay used to store and retrieve such information, resulting into a distributed and scal- able RD. As will be shown, the global service discovery performance depends only on the number of peers in the P2P overlay; this makes the proposed approach directly scalable when the size of the IoT net- work increases. Local service discovery at the IoT gateway makes the process of discovery of new resources automatic. In particular, in our experimental tests we use CoAP for the description of the available endpoints. To the best of our knowledge, this is the \ufb01rst research to provide an architecture and mechanisms that allow for service discovery at both global and local scales into a unique self-con\ufb01guring system. We also provide some preliminary results obtained by an implementation and a real-world deployment of our architecture, thus demonstrating its feasibility. We note that the proposed architecture is built upon components designed to be absolutely agnostic regarding the format of service and resource descriptors, in order to avoid the introduction of application-speci\ufb01c constraints. In fact, the architecture provides mechanisms for publishing and retrieving information, mapped to service or RD URIs, which can be represented in any suitable content format for service/resource description, either already available, such as the CoRE Link Format [13], or foreseeable. The adoption of standard description formats is mandatory to guarantee maximum interoperability, but it is a service\u2019s responsibility to enforce this practice. It is also important to note that IoT applications should be implemented according to the REST paradigm; the de\ufb01nition of CoAP is intended to accomplish precisely this. Client applications, in order to comply with the RESTful paradigm, must follow the HATEOAS (Hypermedia as the Engine of Application State) principle [2], which forbids applications from driving interactions that are based on out-of-band information rather than on hypermedia. The existence of prerequisites, in terms of resource representations, is a violation of the REST paradigm. The service discovery architecture itself does not do this: it is extremely \ufb02exible, able to handle any resource description format. The absence of content-related dependencies leads to more robust implementations, in terms of longevity and adaptability to changes that resource descriptions might undergo. \n\n\n![Image](/src/assets/generated_images/iot_p168_i0.png)\n156 4 Discoverability \n\n4.3.1 IoT Gateway \n\nThe service discovery architecture proposed in this work relies on the presence of an IoT gateway. By combining di\ufb00erent functions, the IoT gateway provides both IoT nodes and standard (non-constrained) nodes with service and resource discovery, proxying, and (optionally) caching and access-control functionalities. In this section, the internal architecture of the IoT gateway and its associated functions will be detailed. \n\n4.3.1.1 Proxy Functionality The IoT gateway interacts, at the application level, with other IoT nodes through CoAP and may act as both CoAP client and CoAP server. More precisely, in the terms of the CoAP speci\ufb01cations, it may act as CoAP origin server and/or proxy. The CoAP speci\ufb01cation de\ufb01nes an origin server as a CoAP server on which a given resource resides or has to be created, while a proxy is a CoAP endpoint which, by implementing both the server and client sides of CoAP, forwards requests to an origin server and relays back the received responses. The proxy may also (optionally) perform caching and protocol translation (in which case it is termed a \u201ccross-proxy\u201d). \n\n\nIoT Network \n\nP \n\nCoAP HTTP \n\nUDP \n\nIP \n\nRD Cache \n\n802.15.4 802.15.4 802.11 802.11 \n\nTCP \n\nFigure 4.2 Architecture of IoT gateway with internal layers and caching/resource directory capabilities. \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 157 \n\nThe presence of a proxy at the border of an IoT network can be very useful for a number of reasons: \n\n\u2022 to protect the constrained network from the outside: for security reasons such as DoS attacks; \u2022 to integrate with the existing web through legacy HTTP clients; \u2022 to ensure high availability of resources through caching; \u2022 to reduce network load of constrained devices; \u2022 to support data formats that might not be suitable for constrained applications, such as XML. \n\nIn Figure 4.2, a layered view of the IoT gateway node is presented. In addition to standard CoAP proxying behavior, the IoT gateway may also act as an HTTP-to-CoAP proxy by translating HTTP requests to CoAP requests (and vice-versa). Just like standard CoAP proxying, an HTTP-to-CoAP proxy can integrate two di\ufb00erent operational modes: \n\n\u2022 reverse proxy: by translating incoming HTTP requests to CoAP requests, it provides access to resources that are created and stored by CoAP nodes within the IoT network (acting as CoAP servers); \u2022 origin server: acting as both HTTP and CoAP server, by letting CoAP nodes residing in the IoT network (and acting as clients) create resources through CoAP POST/PUT requests, and by making such resources available to other nodes through HTTP and CoAP. \n\nThe latter operational mode is particularly suited for duty-cycled IoT nodes, which may post resources only during short wake-up intervals. Figure 4.3 shows the di\ufb00erence between a reverse proxy and an origin server. From an architectural point of view, the IoT gateway comprises the following elements: \n\n\u2022 an IP gateway, managing IPv4/IPv6 connectivity among smart objects in heterogeneous networks (i.e., IEEE 802.15.4, IEEE 802.11.x, and IEEE 802.3) so as to allow for interconnection of devices operating in di\ufb00erent networks by providing an IP layer to let nodes communicate seamlessly; \u2022 a CoAP origin server, which can be used by CoAP clients within the network to post resources that will be maintained by the server on their behalf; \n\n158 4 Discoverability \n\nCoAP GET/temp \n\nCoAP 2.05 Content \n\nHTTP GET/temp \n\n{value=20, unit=C} \n\nHTTP 200 OK {value=20, unit=C} \n\nCoAP Server \n\nHTTP Client \n\nMjCoAP HTTP-CoAP Proxy acting as Reverse \n\nProxy \n\n(a) \n\nCoAP POST/temp \n\nCoAP 2.01 Created \n\nHTTP GET/temp \n\nHTTP 404 Not Found {value=20, unit=C} \n\nHTTP 200 OK \n\nHTTP GET/temp \n\n{value=20, unit=C} \n\nCoAP Client \n\nMjCoAP HTTP-CoAP Proxy acting as Origin Server \n\nHTTP Client \n\nHTTP Client \n\n(b) \n\nFigure 4.3 HTTP-to-CoAP proxy acting as: (a) reverse proxy and (b) origin server. \n\n\u2022 a HTTP-to-CoAP reverse proxy, optionally equipped with caching capabilities, which can be used for accessing services and resources that are available in an internal constrained network. \n\nThe IoT gateway is therefore a network element that coordinates and enables full and seamless interoperability among highly heterogeneous devices, which: \n\n\u2022 may operate di\ufb00erent protocols at the link and/or application layers; \u2022 may not be aware of the true nature of the nodes providing services and resources; \u2022 may be geographically distant. \n\n4.3.1.2 Service and Resource Discovery Service discovery aims at obtaining the hostport of the CoAP servers in the network, while resource discovery is discovery of the resources that a CoAP server manages. Because of its role in managing the \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 159 \n\nlife-cycle of nodes residing in its network, the IoT gateway is naturally aware of the presence of the nodes and the available services and resources. When the IoT gateway detects that a CoAP node has joined its IP network, it can query the CoAP node, asking for the list of provided services; in CoAP this is done by sending a GET request to the /.well-known/core URI. Such information (the resource directory) is then locally maintained by the IoT gateway and successively used to route incoming requests to the proper resource node. According to this mechanism, the IoT gateway may act as an RD for the CoAP nodes within the network. In Section 4.3.2, we detail how IoT gateways can be federated in a P2P overlay in order to provide a distributed and global service and resource directory that can be used to discover services at a global scale. In Section 4.3.3, we then provide a zero-con\ufb01guration solution for discovery of resources and services within a local scope, with no prior knowledge or intervention required on any node of the network. This allows the IoT gateways to populate and update their resource and service directories. \n\n4.3.2 A P2P-based Large-scale Service Discovery Architecture \n\nAs stated in Section 4.3.1, IoT gateways can be federated in a P2P over- lay in order to provide a large-scale service discovery mechanism. The use of a P2P overlay can provide several desirable features: \n\n\u2022 scalability: P2P systems are typically designed to scale and increase their capacity as the number of participants increases; \u2022 high-availability: P2P systems are inherently robust because they have no single point of failure and the failure of a node does not compromise the overall availability of the services and resources provided; \u2022 self-con\ufb01guration: P2P systems provide mechanisms to let the overlay re-organize itself automatically when nodes join and leave, requiring no direct intervention for con\ufb01guration. \n\nThese features \ufb01t perfectly in IoT scenarios, where billions of objects are expected to be deployed. Among several approaches to imple- menting P2P overlays, structured overlays, such as DHTs, have some interesting features, including e\ufb03cient storage and lookup procedures, resulting in deterministic behavior. On the contrary, with \n\n160 4 Discoverability \n\nunstructured overlays, \ufb02ooding techniques are used for message routing. In the remainder of this section, we propose a P2P-based approach that provides a scalable and self-con\ufb01guring architecture for service discovery at a global scale. IoT gateways are organized as peers of a structured P2P overlay, which provides for e\ufb03cient name resolution for CoAP services. The large-scale service discovery architecture presented in this work relies on two P2P overlays: \n\n\u2022 the Distributed Location Service (DLS) [84] \u2022 the Distributed Geographic Table (DGT) [85, 86]. \n\nThe DLS provides a name resolution service to retrieve all the information needed to access a resource (of any kind) identi\ufb01ed by a URI. The DGT builds up a distributed geographical knowledge, based on the location of nodes, which can be used to retrieve a list of resources matching geographic criteria. The combination of these two P2P overlay systems allows for the building of a distributed architecture for large-scale service discovery, with the typical features of P2P networks (scalability, robustness, and self-con\ufb01guration), yet enabling the unique feature of service and resource discovery on a geographical basis. In the following, we \ufb01rst detail the DLS and DGT and then we describe the overall envisioned system architecture. \n\n4.3.2.1 Distributed Location Service The DLS is a DHT-based architecture that provides a name resolu- tion service based on storage and retrieval of bindings between a URI, identifying resources (e.g., web services) and the information that indi- cates how they can be accessed [84]. In essence, the DLS implements a location service that can be used to store and retrieve information for accessing services and resources. Together with each contact URI, other information can be stored, such as the expiration time, an access priority value, and, optionally, a human-readable text (e.g., a contact description or a name). The service provided by DLS can be considered as similar to that of the DNS, since it can be used to resolve a name to retrieve the infor- mation needed to access the content related to that name. However, the DNS has many limitations that the DLS overcomes, such as: \n\n\u2022 the DNS applies only to the fully quali\ufb01ed domain names (FQDN) and not to the entire URI; \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 161 \n\n\u2022 the DNS typically has long propagation times (further increased by the use of caching), which are not suited to highly dynamic scenar- ios, such as those encompassing node mobility; \u2022 the DNS essentially provides the resolution of a name, which results in an IP address, but it does not allow for storage and retrieval of additional useful information related to the resolved URI, such as the description and the parameters of the hosted service. \n\nAnother important feature that makes the use of the DLS preferable to the DNS is its robustness. If a DNS server is unreachable, then resolu- tion cannot be performed. In contrast, P2P overlays do not have single point of failure that might cause service disruption, resulting in a more robust, dynamic, and scalable solution. A DLS can be logically accessed through two simple methods: \n\n\u2022 put(key,value); \u2022 get(key); \n\nwhere key is a resource URI (actually its hash), while value is struc- tured information that may include location information (e.g. a con- tact URI) together with a display name, expiration time, priority value, etc. The get(key) method should return the set of the corresponding values (actually the contact information) associated with the targeted resource. The removal of a resource is performed by updating an exist- ing resource through a put operation with expiration time set to zero. This mapping allows the approach to support: \n\n\u2022 mobility: it is su\ufb03cient to put and replace an old resource with an updated one that considers the new position of the resource; \u2022 replication: it is su\ufb03cient to execute several put operations for the same resource in order to have multiple replicas di\ufb00used in the DHT. \n\nThe DLS interface can be easily integrated with existing networked applications, such as a middleware layer o\ufb00ering services to applica- tions and working on top of standard transport protocols. Di\ufb00erent RPC protocols, such as dSIP [87] and RELOAD [88], may be used for messaging, regardless of the actual selected DHT algorithm (e.g., Chord or Kademlia). \n\n4.3.2.2 Distributed Geographic Table The DGT [85, 86] is a structured overlay scheme, built directly using the geographical location of the nodes. Unlike DHTs, with a DGT each \n\n162 4 Discoverability \n\nparticipant can e\ufb03ciently retrieve node or resource information (data or services) located near any chosen geographic position. In such a sys- tem, the responsibility for maintaining information about the position of active peers is distributed among nodes, so that a change in the set of participants causes a minimal amount of disruption. The DGT is di\ufb00erent from other P2P-based localization systems, where geographic information is routed, stored, and retrieved among nodes organized according to a structured overlay scheme. The DGT principle is to build the overlay by directly taking into account the geo- graphic positions of nodes. This allows for building of a network in which overlay neighbors are also geographic neighbors; no additional messages are needed to identify the closest neighbors of a peer. The main di\ufb00erence between the DGT and the DHT-based P2P overlays is the fact that the DGT overlay is structured in such a way that the messages are routed exclusively according to the geographic locations of the nodes, rather than on keys that have been assigned to the nodes. Typically, DHTs arrange hosts at unpredictable and unrelated points in the overlay, deriving keys through hashing functions. In contrast, the DGT ensures that hosts that are geographically close are also neigh- bors in the overlay. The DGT provides a primitive get(lat, lon, rad), which returns a list of nodes that fall inside the circular region centered at (lat, lon) with radius rad. Each node that provides a service can be looked up. The get primitive is used to localize the list of nodes in a certain geographic region. It might be possible to extend the get primitive by introducing query \ufb01lters, making it possible to return only matching services. The DGT does not provide a generic put primitive that can be invoked on the overlay as a whole. However, it is possible to extend the classical DGT behavior with a generic put primitive, consisting of the detection of a list of peers in a given area (through the native DGT get primi- tive) and, subsequently, to invoke a put method directly on each of the detected peers. \n\n4.3.2.3 An Architecture for Large-scale Service Discovery based on Peer-to-peer Technologies The mechanisms presented in the previous subsections are the key ingredients of a large-scale service discovery architecture. In Figure 4.4, an illustrative representation of the system architecture is shown. Several IoT gateways managing their respective networks are interconnected through the two P2P overlays. Each IoT gateway is, \n\n\n![Image](/src/assets/generated_images/iot_p175_i0.png)\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 163 \n\n\nIoT Network 1 IoT Network 4 \n\nIoT Network 2 IoT Network 3 \n\nDistributed Geographic Table \n\nDistributed Location Service \n\nGW1 \n\nGW2 GW3 \n\nGW4 \n\nFigure 4.4 Large-scale service-discovery architecture. IoT gateway nodes act as peers of two di\ufb00erent P2P overlays. The DLS overlay is used for discovering resources and services: a \u201cwhite-pages\u201d service that provides a name resolution service to be used to retrieve the information needed to access a resource. The DGT is used as a \u201cyellow-pages\u201d service, for learning about the existence of IoT gateway nodes in a certain geographical neighborhood. \n\nat the same time, a DLS peer and a DGT peer. The data structures of the overlays are separated, since they pertain to di\ufb00erent operations of the overall architecture. The DLS and DGT overlays are loosely coupled. The IoT gateway uses the DLS to publish/lookup the details of resources and services, and the DGT to publish its presence or dis- cover existing IoT gateways in a given geographic area. This separation allows the IoT gateway to access the services provided by each overlay as a \u201cblack-box\u201d, without any risk of direct interference between the overlays. The IoT gateway is responsible for implementing the behavior required by the service discovery architecture. The lifecycle of an IoT gateway is shown in Figure 4.5 and can be described as follows: \n\n\u2022 Upon start up, the IoT gateway joins the DLS and DGT overlays. \u2022 The IoT gateway publishes its presence in the DGT by issuing a DGT.put (lat, lon, URIGW) request. \u2022 When the IoT gateway detects a new CoAP node in the network, through any suitable means (e.g., Zeroconf), it fetches the node\u2019s \n\n\n![Image](/src/assets/generated_images/iot_p176_i0.png)\n164 4 Discoverability \n\n\nIoT Network GW \n\nLRDA \n\nA B \n\nGet /.well-known/core \n\nDGT.put(lat,lon,URI) \n\nDLS.put(URIGW/.well-known/nodes,LNDP) \n\nDLS.put(URIGW/.well-known/core,LRDP) \n\nDLS.put(URIA/.well-known/core,LRDA*) \n\nDGT \n\nDLS \n\n2a \n\n4 \n\n3a \n\n3a \n\n1 \n\n2b \n\nPOST \n\nFigure 4.5 Messages exchanged when a new node joins the network. First, the IoT gateway discovers the resources of a new CoAP server or stores them on behalf of a CoAP client. Finally, DGT and DLS are updated with information about the new node. \n\nlocal resource directory (LRD) through a CoAP GET request tar- geting the /.well-known/core URI. The LRD is \ufb01lled with documents in JSON-WSP3 or similar formats (such as CoRE Link Format) con- taining the description of all the resources that are hosted by the CoAP node and the information to be used to access them. At this point, the resources included in the fetched node\u2019s LRD are added to the IoT gateway\u2019s LRD. \u2022 If the IoT gateway is willing to let the resources be reachable through it, it will modify its LRD to include the references of the URLs to be used to reach the resources through the IoT gateway, obtaining a new LRD, denoted as LRD*; the IoT gateway could also delete from the LRD all the references directly related to this resource, in order to avoid having a resource that could be accessed without the IoT gateway relaying messages. \u2022 The IoT gateway publishes the LRD* in the DLS through a DLS.put(URInode/.well-known/core,LRD*) request. \u2022 The IoT gateway keeps track of the list of nodes that are in its man- aged network, by adding the node to a local node directory (LND). \u2022 The IoT gateway publishes the LND pair in the DLS through a DLS.put(URIGW/.well-known/nodes,LND) request. \n\n3 JavaScript Object Notation Web-Service Protocol (JSON-WSP) is a web-service protocol that uses JSON for service description, requests, and responses. It has been designed to cope with the lack of service description speci\ufb01cation with documentation in JSON-RPC, a remote procedure call protocol in JSON format. \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 165 \n\n\u2022 If, in addition, the IoT gateway acts as origin server, it stores its own resources, which will then be published as soon as it receives CoAP POST requests from CoAP clients residing in the inner network. \n\nSteps 3 to 7 are repeated for each CoAP node detected in the network. By publishing all the LRDs in the DLS, a distributed resource direc- tory (DRD) is obtained. The DRD provides global knowledge of all the available resources. The use of LNDs provides a census of all the nodes that are within a certain network. Location information is managed with JSON-WSP or CoRE Link Format documents, which provide all the details related to parameters and return values. This is similar to WSDL documents, but in a more compact, yet just as descriptive, for- mat than XML. As soon as a node joins a local network and discovers the presence of an IoT gateway (it can be assumed that either the IoT gateway address is hard-coded or the node joins the RPL tree, \ufb01nd- ing the IoT gateway \u2013 other mechanisms may also be possible), the node announces its presence. We note that this phase is optional, in the sense that other discovery mechanisms can be adopted. When the IoT gateway detects this advertisement, it issues a GET /.well-known/core to the node, in order to discover its available resources. The node, in return, replies by sending a JSON-WSP or CoRE Link Format docu- ment describing its exposed resources, the URI to access them, and their data format. Finally, the IoT gateway will parse this response and will populate the DLS and DGT accordingly. If other IoT gateways are present within a certain network, they can act as additional access points for a resource: this can be achieved by publishing a LRD* \u2032 con- taining the URLs related to them. This will lead to highly available and robust routing in very dynamic scenarios where IoT gateways join and leave the network. Should one want to provide fault-tolerance, infor- mation replication mechanisms can be also introduced [89]. In the proposed architecture, the DLS can be interpreted as a \u201cwhite-pages\u201d service to resolve the name of a service, in the form of a URI, to get all the information needed to access it. Similarly, the DGT can be interpreted as a \u201cyellow-pages\u201d service, used to retrieve a list of available services matching geographic location criteria; that is, in the proximity of a geographic position. Note that the DGT is just one possible solution to get matching services; other mechanisms might be adopted. These might not be related to geographic locations, but instead on di\ufb00erent matching criteria, such as taxonomies/semantics. \n\n\n![Image](/src/assets/generated_images/iot_p178_i0.png)\n166 4 Discoverability \n\nThis is the case if the search is by type of service rather than by geographical location. The distinction between the lookup services provided by DLS and DGT avoids the inclusion, in the URI, of service or resource informa- tion that can dynamically change (such as the location), thus making it possible to support mobility of services and resources. The DGT and the DLS run in parallel, and the IoT gateways of a IoT sub-network act as peers of both the DLS and the DGT. The resulting architecture is very \ufb02exible and scalable: nodes that may join and leave the net- work at any time. In fact, as explained in the previous subsections, the nature of DLS and DGT P2P overlay networks allows new IoT gate- ways to be added without requiring the re-computation of the entire hash table. Vice versa, only the nodes responsible for maintaining the resources close to the joining node must update their hash tables in order to include the resources of the new node. A client needing to retrieve data from a resource and with no infor- mation about the URI to contact, must perform the operations shown in Figure 4.6. It can perform service discovery through the mediation of a known IoT gateway that is part of the DLS and DGT overlays. The procedure can be detailed as follows (the \ufb01rst \ufb01ve steps are explicitly shown in Figure 4.6): \n\n1) The client contacts a known IoT gateway in order to access the DLS and DGT overlays for service discovery. \n\n\nCoAP/HTTP Request \n\n4 3a \n\n2 \n\n1 \n\nC \n\nGW1 GW2 \n\n3b \n\nCoAP GET URlGW2/.well-known/core DGT.get(lat,lon,rad) \n\nDLS.get(URIGW1/.well-known/nodes) \n\nDGT \n\nDLS \n\nFigure 4.6 Data retrieval operations: 1) the client C contacts a known IoT gateway GW1; 2) GW1 accesses the DGT to retrieve the list of IoT gateways available in a given area; 3a) GW1 selects one of these IoT gateways, namely GW2; 3b) GW1 discovers the nodes managed by the GW2 through the DLS or directly by contacting GW2; 4) \ufb01nally, GW1 queries the node, associated with the resource of interest, managed by GW2. \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 167 \n\n2) The client uses the DGT to retrieve a list of IoT gateways that are in the surroundings of a certain geographical location through a DGT.get(lat, lon, rad) request. 3a) The IoT gateway selects one of the IoT gateways returned by the DGT and discovers the list of its managed nodes, through a DLS.get(URIGW1/.well-known/nodes) request. 3b) The IoT gateway discovers the resources that are reachable: \u2022 by executing a DLS.get(URInode/.well-known/core) procedure or \u2022 by issuing a CoAP GET request for URIGW2/.well-known/core. 4) The IoT gateway interacts with the resource by issuing CoAP or HTTP requests targeting the selected resource through the appropriate IoT gateway. The client can then contact the URI of the resource, either directly through CoAP (if supported by the IoT gateway) or by HTTP (by delegating to the IoT gateway the HTTP-CoAP request translation). 5) Once the command has been transmitted to the CoAP server, the latter will reply with the requested data. 6) If supported, the response will be through CoAP to the client. Otherwise, the IoT gateway will be in charge of response trans- lation. \n\n4.3.3 Zeroconf-based Local Service Discovery for Constrained Environments \n\nService discovery within a local network can be performed using sev- eral mechanisms. In scenarios where a huge number of devices are involved or external human intervention is complicated, it is desirable that all devices can automatically adapt to the surrounding environ- ment. The same considerations apply to devices that do not reside in a particular environment but are characterized by mobility, for example smartphones. In both cases, a service discovery mechanism, which requires no prior knowledge of the environment, is preferable. In this section, we propose a novel lightweight Zeroconf-based mechanism for service and resource discovery within local networks. \n\n4.3.3.1 Architecture Our local service discovery mechanism is based on the Zeroconf pro- tocol suite. It involves the following elements: \n\n\u2022 IoT nodes (smart objects) belonging to an IoT network; \u2022 an IoT gateway, which manages the IoT network and acts as the RD; \u2022 client nodes, which are interested in consuming the services o\ufb00ered by the IoT nodes. \n\n168 4 Discoverability \n\nWe assume that IP multicast is supported within the local network and that DHCP [90] provides the dynamic con\ufb01guration for the IP layer. \n\n4.3.3.2 Service Discovery Protocol There are essentially two relevant scenarios for the application of the proposed service discovery protocol: \n\n\u2022 a new device o\ufb00ering some service is added to the network and starts participating actively; \u2022 a client, which is interested in consuming the services o\ufb00ered by the nodes already present in the network, discovers the available services. \n\nIn the former scenario, the procedure for adding a new service to the network can be performed in two di\ufb00erent ways, depending whether: \n\n\u2022 the smart object can be queried for its services (using the /.well-known/core URI); or \u2022 it posts the information related to the services it is o\ufb00ering on the IoT gateway, which acts as a resource directory. \n\nThe di\ufb00erence between the two scenarios also involves the charac- terization of the smart object as a CoAP server or as a CoAP client, respectively. If the device acts as a CoAP (origin) server, the service discovery procedure, as shown in Figure 4.7, is the following: \n\n1) The IoT node joins the network and announces its presence by disseminating a mDNS message for a new service type _coap._ udp.local. 2) The IoT gateway, listening for events related to service type _coap._udp.local., detects that a new node has joined the network. 3) The IoT gateway queries the new node for its provided services by sending a CoAP GET request targeting the URI /.well-known/core. 4) The IoT node replies with a JSON-WSP or CoRE Link Format doc- ument describing the o\ufb00ered services. 5) The IoT gateway updates the list of services that it manages on behalf of the constrained nodes residing in the network, thus mak- ing these services consumable by clients residing outside of the IoT network (e.g., remote Internet hosts, which may be unaware of the constrained nature of the network where the service of interest is located). \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 169 \n\nAdvertises _coap._udp.local. \n\nDetects _coap._udp.local. \n\nGET  /.well-known/core \n\nLocal network \n\nLocal network \n\nService Descriptor \n\nMjCoAP HTTP-CoAP Proxy performing Service Discovery \n\nCoAP Server \n\nFigure 4.7 Service advertisement by CoAP server detected by HTTP-to-CoAP proxy. \n\nCoAP Node \n\nAdvertises _httpcoap._udp.local. \n\nDetects _httpcoap._udp.local. \n\nGET  /.well-known/core \n\nLocal network \n\nLocal network \n\nService Descriptor \n\nProxy IP & Port \n\nMjCoAP HTTP-CoAP Proxy performing Service Advertisement \n\nFigure 4.8 Service advertisement by HTTP-to-CoAP proxy detected by CoAP client. \n\nIf the device acts as a CoAP client, on the other hand, the service discovery procedure, as shown in Figure 4.8, is the following: \n\n1) The proxy, which is a module of the IoT gateway, announces its presence periodically, by disseminating a mDNS message for a new service type _httpcoap._udp.local. \n\n170 4 Discoverability \n\n2) The joining smart object, which is listening for events related to the service type advertised by the IoT gateway (_httpcoap._udp.local.), detects that an IoT gateway is available in the network. 3) The smart object sends a CoAP GET request to the URI /.well- known/core to get a description of the services that the IoT gate- way provides and other information that might be used to detect the most suitable proxy for the client. 4) The IoT gateway replies with a JSON-WSP or CoRE Link Format document describing the services it provides. 5) The smart object processes the payload and then sends a CoAP POST/PUT request to the IoT gateway to store resources to be made available to external clients. \n\nIn this scenario, the IoT gateway does not simply forward incoming requests and relay responses, but it acts as a server both towards \n\n\u2022 the generator of the resource (CoAP client) from which it receives CoAP POST requests; \u2022 external clients, to which it appears as the legitimate origin server, since the generator of the data is not a CoAP server. \n\nWhen a client needs to discover the available services, the procedure comprises the following steps: \n\n1) The client sends a CoAP or HTTP request to the proxy targeting the URI /.well-known/core. 2) The proxy replies with a JSON-WSP or CoRE Link Format docu- ment describing all the services managed on behalf of the nodes; 3) The client then uses the received information to perform subse- quent CoAP or HTTP requests in order to consume the required services. \n\nThe use of IP multicast (i.e., mDNS) has the chief advantage of avoid- ing having to set a priori the actual network address of any device present, thus eliminating the need for any con\ufb01guration. \n\n4.3.4 Implementation Results \n\nThe solutions presented Sections 4.3.1\u20134.3.3 may be used for many large IoT scenarios in which scalable and reliable service and resource discovery is required. In particular, we focus on a smart-infrastructure surveillance scenario, where given areas of interest can be moni- tored by means of wireless devices. Each device (smart object) is characterized by the type of the collected data and by its position. \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 171 \n\nA system user may then be interested either in directly contacting a given resource (e.g., a sensor) or having the list of all available resources in a given area. Such wireless sensors are grouped in low- power wireless networks with one or more gateways acting as interfaces between the resulting constrained wireless network and the rest of the network (namely, in the considered scenario, the Internet). In order to validate the feasibility of the proposed solution and to evaluate its performance, extensive experimentation has been carried out in the reference smart-infrastructure surveillance scenario. The performance evaluation focuses on both local and large-scale service discovery mechanisms, as described in Sections 4.3.2 and 4.3.3, respectively. \n\n4.3.4.1 Local Service Discovery The \ufb01rst phase of the experimental performance analysis focuses on the discovery of new CoAP services (associated with constrained devices) available in the local network. The performance evaluation of our Zeroconf-based local service dis- covery strategy was conducted using Zolertia Z1 Contiki nodes, sim- ulated in the Cooja simulator. The Contiki software stack running on each node was con\ufb01gured so as to \ufb01t in the Z1\u2019s limited available mem- ory, in terms of both RAM and ROM \u2013 Z1 nodes feature a nominal 92 kB ROM (when compiling with 20-bit architecture support) and an 8 kB RAM. In practice, the compilation with the Z1 nodes was performed with a 16-bit target architecture, which lowers the amount of available ROM to roughly 52 kB. The simulated smart objects run Contiki OS, uIPv6, RPL, NullMAC, and NullRDC. The software stack deployed on the smart objects includes our lightweight implementa- tion of the mDNS [82] and DNS-SD [83] protocols, developed in order to minimize memory footprint and to include all the needed modules in the smart objects. The implementations comply with the IETF stan- dards de\ufb01ned in the RFCs and can be replaced by any other compatible implementation, should no particular constraint on the code size be present. The local service discovery mechanism was tested on IEEE 802.15.4 networks formed by Contiki nodes arranged in linear and grid topologies. The performance indicators were: \n\n\u2022 the time needed to perform a DNS-SD query \u2013 from the DNS-SD client perspective; \u2022 the time needed to process an incoming DNS-SD query and respond \u2013 from the DNS-SD server perspective. \n\n172 4 Discoverability \n\nTable 4.1 Local service discovery metrics. \n\nMetric Description Dimension \n\nQC Query client time: the time needed by a node acting as client to send a DNS-SD query and receive a response ms \n\nQS Query server time: the time needed by a node acting as server to construct and send a response back to a DNS-SD client \n\nms \n\nThe impact of the number of constrained nodes (and, therefore, the number of hops needed) in the network was analyzed. All the results were obtained by performing 100 service discovery runs on each con- \ufb01guration. The speci\ufb01c performance metrics are detailed in Table 4.1. In Figure 4.9a, the considered linear topology, with a maximum of 20 nodes deployed in Cooja, is shown. In particular: \n\n\u2022 node 1 is the 6LoWPAN border router (6LBR), which is the root of the RPL tree; \u2022 node 2 is the node acting as DNS-SD server; \u2022 node 3 is the node acting as DNS-SD client. \n\nThe distance between nodes was set so that the query had to follow a multi-hop path consisting of as many hops as the number of nodes in the network. In Figure 4.9b, the corresponding performance, in terms of QC/QS times, as functions of the number of smart objects, is shown. The QS time has a nearly constant value of around 65 ms, since the pro- cessing time is independent of the number of nodes in the network. The QC time is a linear function of the number of hops (which, in our scenario, coincides with the number of nodes), since the query packet has to be relayed by each intermediate node to reach the DNS-SD server node. More complex bi-dimensional topologies were also tested in order to evaluate grid-like deployments. Di\ufb00erent sizes and arrangements for grids were considered, as shown in Figure 4.10. In all cases: \n\n\u2022 node 1 is the 6LBR; \u2022 node 2 is the node acting as DNS-SD server; \u2022 node 3 is the node acting as DNS-SD client. \n\nThe topologies in Figure 4.10 are: (a) Grid-A (3 hops); (b) Grid-B (4 hops); (c) Grid-C (6 hops); (d) Grid-D (5 hops). The corresponding \n\n\n![Image](/src/assets/generated_images/iot_p185_i0.png)\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 173 \n\n0 \n\n100 \n\n200 \n\n300 \n\n400 \n\n500 \n\n600 \n\n700 \n\n800 \n\n900 \n\n1000 \n\n2 4 6 8 10 12 14 16 18 20 \n\nTime [ms] \n\nNumber of smart objects \n\nQS QC \n\n\n(a) \n\n(b) \n\nFigure 4.9 (a) Linear topology considered for multi-hop Zeroconf-based service discovery; (b) average time of Zeroconf-based service discovery on Contiki nodes with linear topology. \n\nperformance of service resolution, in terms of QC/QS times, is shown in Figure 4.11. Just like in the linear case, the QS time is independent of the network size (around 65 ms were still needed by the DNS-SD server-side processing). As the number of nodes participating in the network increases, the QC time increases as well, because of the need for multi-hop communications from client to server. It can be seen that, in the case of Grid-D, even though the number of nodes is larger than in the case of Grid-C, the QC time is shorter. This is because the distance between the nodes has decreased from 40 m to 30 m (to min- imize collisions due to the use of NullMAC) and, therefore, the total number of hops from the client to the server decreases. In general, it can be concluded that, at a \ufb01xed node density, the QC time is a linear function of the number of hops. \n\n\n![Image](/src/assets/generated_images/iot_p186_i0.png)\n\n![Image](/src/assets/generated_images/iot_p186_i1.png)\n\n![Image](/src/assets/generated_images/iot_p186_i2.png)\n\n![Image](/src/assets/generated_images/iot_p186_i3.png)\n174 4 Discoverability \n\n\n2 \n\n4 \n\n7 \n\n10 11 8 \n\n13 14 3 \n\n12 \n\n1 9 \n\n5 6 \n\n\n2 \n\n1 \n\n6 7 8 \n\n9 10 11 \n\n3 \n\n4 5 \n\n\n2 \n\n1 4 \n\n5 \n\n3 \n\n6 \n\n\n2 \n\n4 5 \n\n6 1 \n\n8 9 \n\n3 \n\n7 \n\n(a) (b) \n\n(c) (d) \n\nFigure 4.10 Grid topologies considered for bi-dimensional deployments of smart objects: (a) Grid-A (3 hops); (b) Grid-B (4 hops); (c) Grid-C (6 hops); (d) Grid-D (5 hops). \n\n50 \n\n100 \n\n150 \n\n200 \n\n250 \n\n300 \n\n350 \n\n400 \n\n450 \n\n500 \n\nGrid-A Grid-B Grid-C Grid-D \n\nTime [ms] \n\nQS QC \n\nFigure 4.11 Average QC/QS times of the Zeroconf-based service discovery in the grid topologies shown in Figure 4.10. \n\n4.3 Scalable and Self-con\ufb01guring Architecture for Service Discovery in the IoT 175 \n\n4.3.4.2 Large-scale Service Discovery The second performance evaluation phase focuses on a P2P overlay in which multiple IoT gateways join the network in order to store new resouces in the DLS overlay and retrieve references to existing ones. The aim of this evaluation was to test the validity of the proposed approach with di\ufb00erent con\ufb01gurations and, in particular, to measure the average time required by an IoT gateway to complete the three main actions in the network (JOIN, PUT and GET) for di\ufb00erent sizes of the P2P overlay. We focus only on the evaluation of the DLS overlay since the published content pertains to IoT services and resources and, therefore, it represents the component of the proposed service discov- ery architecture that is directly related to IoT services and resources. The DGT allows for a structured geographical network that can be used to e\ufb03ciently discover available nodes based on location criteria in a content-agnostic way; this is what the DGT was designed and thor- oughly evaluated for, both in simulative environments and real-world deployments [91, 92]. The performance evaluation was carried out for several con\ufb01gura- tions, with di\ufb00erent numbers of IoT gateways (which are also the peers of the overlay). Each IoT gateway acts as boundary node of a wire- less network with CoAP-aware sensor nodes. The DLS overlay uses a Kademlia DHT and the dSIP protocol for P2P signalling [87, 93], both implemented in Java. The P2P overlay contains up to 1000 nodes deployed over an evaluation platform comprising four cluster hosts, ",
  "createdAt": "2026-02-17"
}