{
  "title": "Debugging",
  "slug": "thinkpython2-debugging",
  "description": "Module from thinkpython2.pdf: Debugging",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Debugging\n\n\n\nWhen you are debugging, you should distinguish among different kinds of errors in order to track them down more quickly: \n\n\u2022 Syntax errors are discovered by the interpreter when it is translating the source code into byte code. They indicate that there is something wrong with the structure of the program. Example: Omitting the colon at the end of a def statement generates the somewhat redundant message SyntaxError: invalid syntax. \n\n\u2022 Runtime errors are produced by the interpreter if something goes wrong while the program is running. Most runtime error messages include information about where the error occurred and what functions were executing. Example: An in\ufb01nite recur- sion eventually causes the runtime error \u201cmaximum recursion depth exceeded\u201d. \n\n\u2022 Semantic errors are problems with a program that runs without producing error mes- sages but doesn\u2019t do the right thing. Example: An expression may not be evaluated in the order you expect, yielding an incorrect result. \n\nThe \ufb01rst step in debugging is to \ufb01gure out which kind of error you are dealing with. Al- though the following sections are organized by error type, some techniques are applicable in more than one situation. \n\nA.1 Syntax errors \n\nSyntax errors are usually easy to \ufb01x once you \ufb01gure out what they are. Unfortunately, the error messages are often not helpful. The most common messages are SyntaxError: invalid syntax and SyntaxError: invalid token, neither of which is very informa- tive. \n\nOn the other hand, the message does tell you where in the program the problem occurred. Actually, it tells you where Python noticed a problem, which is not necessarily where the error is. Sometimes the error is prior to the location of the error message, often on the preceding line. \n\n194 Appendix A. Debugging \n\nIf you are building the program incrementally, you should have a good idea about where the error is. It will be in the last line you added. \n\nIf you are copying code from a book, start by comparing your code to the book\u2019s code very carefully. Check every character. At the same time, remember that the book might be wrong, so if you see something that looks like a syntax error, it might be. \n\nHere are some ways to avoid the most common syntax errors: \n\n1. Make sure you are not using a Python keyword for a variable name. \n\n2. Check that you have a colon at the end of the header of every compound statement, including for, while, if, and def statements. \n\n3. Make sure that any strings in the code have matching quotation marks. Make sure that all quotation marks are \u201cstraight quotes\u201d, not \u201ccurly quotes\u201d. \n\n4. If you have multiline strings with triple quotes (single or double), make sure you have terminated the string properly. An unterminated string may cause an invalid token error at the end of your program, or it may treat the following part of the program as a string until it comes to the next string. In the second case, it might not produce an error message at all! \n\n5. An unclosed opening operator\u2014(, {, or [\u2014makes Python continue with the next line as part of the current statement. Generally, an error occurs almost immediately in the next line. \n\n6. Check for the classic = instead of == inside a conditional. \n\n7. Check the indentation to make sure it lines up the way it is supposed to. Python can handle space and tabs, but if you mix them it can cause problems. The best way to avoid this problem is to use a text editor that knows about Python and generates consistent indentation. \n\n8. If you have non-ASCII characters in the code (including strings and comments), that might cause a problem, although Python 3 usually handles non-ASCII characters. Be careful if you paste in text from a web page or other source. \n\nIf nothing works, move on to the next section... \n\nA.1.1 I keep making changes and it makes no difference. \n\nIf the interpreter says there is an error and you don\u2019t see it, that might be because you and the interpreter are not looking at the same code. Check your programming environment to make sure that the program you are editing is the one Python is trying to run. \n\nIf you are not sure, try putting an obvious and deliberate syntax error at the beginning of the program. Now run it again. If the interpreter doesn\u2019t \ufb01nd the new error, you are not running the new code. \n\nThere are a few likely culprits: \n\n\u2022 You edited the \ufb01le and forgot to save the changes before running it again. Some programming environments do this for you, but some don\u2019t. \n\nA.2. Runtime errors 195 \n\n\u2022 You changed the name of the \ufb01le, but you are still running the old name. \n\n\u2022 Something in your development environment is con\ufb01gured incorrectly. \n\n\u2022 If you are writing a module and using import, make sure you don\u2019t give your module the same name as one of the standard Python modules. \n\n\u2022 If you are using import to read a module, remember that you have to restart the interpreter or use reload to read a modi\ufb01ed \ufb01le. If you import the module again, it doesn\u2019t do anything. \n\nIf you get stuck and you can\u2019t \ufb01gure out what is going on, one approach is to start again with a new program like \u201cHello, World!\u201d, and make sure you can get a known program to run. Then gradually add the pieces of the original program to the new one. \n\nA.2 Runtime errors \n\nOnce your program is syntactically correct, Python can read it and at least start running it. What could possibly go wrong? \n\nA.2.1 My program does absolutely nothing. \n\nThis problem is most common when your \ufb01le consists of functions and classes but does not actually invoke a function to start execution. This may be intentional if you only plan to import this module to supply classes and functions. \n\nIf it is not intentional, make sure there is a function call in the program, and make sure the \ufb02ow of execution reaches it (see \u201cFlow of Execution\u201d below). \n\nA.2.2 My program hangs. \n\nIf a program stops and seems to be doing nothing, it is \u201changing\u201d. Often that means that it is caught in an in\ufb01nite loop or in\ufb01nite recursion. \n\n\u2022 If there is a particular loop that you suspect is the problem, add a print statement immediately before the loop that says \u201centering the loop\u201d and another immediately after that says \u201cexiting the loop\u201d. \n\nRun the program. If you get the \ufb01rst message and not the second, you\u2019ve got an in\ufb01nite loop. Go to the \u201cIn\ufb01nite Loop\u201d section below. \n\n\u2022 Most of the time, an in\ufb01nite recursion will cause the program to run for a while and then produce a \u201cRuntimeError: Maximum recursion depth exceeded\u201d error. If that happens, go to the \u201cIn\ufb01nite Recursion\u201d section below. \n\nIf you are not getting this error but you suspect there is a problem with a recursive method or function, you can still use the techniques in the \u201cIn\ufb01nite Recursion\u201d sec- tion. \n\n\u2022 If neither of those steps works, start testing other loops and other recursive functions and methods. \n\n\u2022 If that doesn\u2019t work, then it is possible that you don\u2019t understand the \ufb02ow of execu- tion in your program. Go to the \u201cFlow of Execution\u201d section below. \n\n196 Appendix A. Debugging \n\nIn\ufb01nite Loop \n\nIf you think you have an in\ufb01nite loop and you think you know what loop is causing the problem, add a print statement at the end of the loop that prints the values of the variables in the condition and the value of the condition. \n\nFor example: \n\nwhile x > 0 and y < 0 : # do something to x # do something to y \n\nprint('x: ', x) print('y: ', y) print(\"condition: \", (x > 0 and y < 0)) \n\nNow when you run the program, you will see three lines of output for each time through the loop. The last time through the loop, the condition should be False. If the loop keeps going, you will be able to see the values of x and y, and you might \ufb01gure out why they are not being updated correctly. \n\nIn\ufb01nite Recursion \n\nMost of the time, in\ufb01nite recursion causes the program to run for a while and then produce a Maximum recursion depth exceeded error. \n\nIf you suspect that a function is causing an in\ufb01nite recursion, make sure that there is a base case. There should be some condition that causes the function to return without making a recursive invocation. If not, you need to rethink the algorithm and identify a base case. \n\nIf there is a base case but the program doesn\u2019t seem to be reaching it, add a print state- ment at the beginning of the function that prints the parameters. Now when you run the program, you will see a few lines of output every time the function is invoked, and you will see the parameter values. If the parameters are not moving toward the base case, you will get some ideas about why not. \n\nFlow of Execution \n\nIf you are not sure how the \ufb02ow of execution is moving through your program, add print statements to the beginning of each function with a message like \u201centering function foo\u201d, where foo is the name of the function. \n\nNow when you run the program, it will print a trace of each function as it is invoked. \n\nA.2.3 When I run the program I get an exception. \n\nIf something goes wrong during runtime, Python prints a message that includes the name of the exception, the line of the program where the problem occurred, and a traceback. \n\nThe traceback identi\ufb01es the function that is currently running, and then the function that called it, and then the function that called that, and so on. In other words, it traces the \n\nA.2. Runtime errors 197 \n\nsequence of function calls that got you to where you are, including the line number in your \ufb01le where each call occurred. \n\nThe \ufb01rst step is to examine the place in the program where the error occurred and see if you can \ufb01gure out what happened. These are some of the most common runtime errors: \n\nNameError: You are trying to use a variable that doesn\u2019t exist in the current environment. Check if the name is spelled right, or at least consistently. And remember that local variables are local; you cannot refer to them from outside the function where they are de\ufb01ned. \n\nTypeError: There are several possible causes: \n\n\u2022 You are trying to use a value improperly. Example: indexing a string, list, or tuple with something other than an integer. \n\n\u2022 There is a mismatch between the items in a format string and the items passed for conversion. This can happen if either the number of items does not match or an invalid conversion is called for. \n\n\u2022 You are passing the wrong number of arguments to a function. For methods, look at the method de\ufb01nition and check that the \ufb01rst parameter is self. Then look at the method invocation; make sure you are invoking the method on an object with the right type and providing the other arguments correctly. \n\nKeyError: You are trying to access an element of a dictionary using a key that the dictio- nary does not contain. If the keys are strings, remember that capitalization matters. \n\nAttributeError: You are trying to access an attribute or method that does not exist. Check the spelling! You can use the built-in function vars to list the attributes that do exist. \n\nIf an AttributeError indicates that an object has NoneType, that means that it is None. So the problem is not the attribute name, but the object. \n\nThe reason the object is none might be that you forgot to return a value from a func- tion; if you get to the end of a function without hitting a return statement, it returns None. Another common cause is using the result from a list method, like sort, that returns None. \n\nIndexError: The index you are using to access a list, string, or tuple is greater than its length minus one. Immediately before the site of the error, add a print statement to display the value of the index and the length of the array. Is the array the right size? Is the index the right value? \n\nThe Python debugger (pdb) is useful for tracking down exceptions because it allows you to examine the state of the program immediately before the error. You can read about pdb at https://docs.python.org/3/library/pdb.html. \n\nA.2.4 I added so many print statements I get inundated with output. \n\nOne of the problems with using print statements for debugging is that you can end up buried in output. There are two ways to proceed: simplify the output or simplify the program. \n\n198 Appendix A. Debugging \n\nTo simplify the output, you can remove or comment out print statements that aren\u2019t help- ing, or combine them, or format the output so it is easier to understand. \n\nTo simplify the program, there are several things you can do. First, scale down the problem the program is working on. For example, if you are searching a list, search a small list. If the program takes input from the user, give it the simplest input that causes the problem. \n\nSecond, clean up the program. Remove dead code and reorganize the program to make it as easy to read as possible. For example, if you suspect that the problem is in a deeply nested part of the program, try rewriting that part with simpler structure. If you suspect a large function, try splitting it into smaller functions and testing them separately. \n\nOften the process of \ufb01nding the minimal test case leads you to the bug. If you \ufb01nd that a program works in one situation but not in another, that gives you a clue about what is going on. \n\nSimilarly, rewriting a piece of code can help you \ufb01nd subtle bugs. If you make a change that you think shouldn\u2019t affect the program, and it does, that can tip you off. \n\nA.3 Semantic errors \n\nIn some ways, semantic errors are the hardest to debug, because the interpreter provides no information about what is wrong. Only you know what the program is supposed to do. \n\nThe \ufb01rst step is to make a connection between the program text and the behavior you are seeing. You need a hypothesis about what the program is actually doing. One of the things that makes that hard is that computers run so fast. \n\nYou will often wish that you could slow the program down to human speed, and with some debuggers you can. But the time it takes to insert a few well-placed print statements is often short compared to setting up the debugger, inserting and removing breakpoints, and \u201cstepping\u201d the program to where the error is occurring. \n\nA.3.1 My program doesn\u2019t work. \n\nYou should ask yourself these questions: \n\n\u2022 Is there something the program was supposed to do but which doesn\u2019t seem to be happening? Find the section of the code that performs that function and make sure it is executing when you think it should. \n\n\u2022 Is something happening that shouldn\u2019t? Find code in your program that performs that function and see if it is executing when it shouldn\u2019t. \n\n\u2022 Is a section of code producing an effect that is not what you expected? Make sure that you understand the code in question, especially if it involves functions or methods in other Python modules. Read the documentation for the functions you call. Try them out by writing simple test cases and checking the results. \n\nA.3. Semantic errors 199 \n\nIn order to program, you need a mental model of how programs work. If you write a program that doesn\u2019t do what you expect, often the problem is not in the program; it\u2019s in your mental model. \n\nThe best way to correct your mental model is to break the program into its components (usually the functions and methods) and test each component independently. Once you \ufb01nd the discrepancy between your model and reality, you can solve the problem. \n\nOf course, you should be building and testing components as you develop the program. If you encounter a problem, there should be only a small amount of new code that is not known to be correct. \n\nA.3.2 I\u2019ve got a big hairy expression and it doesn\u2019t do what I expect. \n\nWriting complex expressions is \ufb01ne as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables. \n\nFor example: \n\nself.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard()) \n\nThis can be rewritten as: \n\nneighbor = self.findNeighbor(i) pickedCard = self.hands[neighbor].popCard() self.hands[i].addCard(pickedCard) \n\nThe explicit version is easier to read because the variable names provide additional docu- mentation, and it is easier to debug because you can check the types of the intermediate variables and display their values. \n\nAnother problem that can occur with big expressions is that the order of evaluation may not be what you expect. For example, if you are translating the expression x 2\u03c0 into Python, you might write: \n\ny = x / 2 * math.pi \n\nThat is not correct because multiplication and division have the same precedence and are evaluated from left to right. So this expression computes x\u03c0/2. \n\nA good way to debug expressions is to add parentheses to make the order of evaluation explicit: \n\ny = x / (2 * math.pi) \n\nWhenever you are not sure of the order of evaluation, use parentheses. Not only will the program be correct (in the sense of doing what you intended), it will also be more readable for other people who haven\u2019t memorized the order of operations. \n\nA.3.3 I\u2019ve got a function that doesn\u2019t return what I expect. \n\nIf you have a return statement with a complex expression, you don\u2019t have a chance to print the result before returning. Again, you can use a temporary variable. For example, instead of: \n\nreturn self.hands[i].removeMatches() \n\n200 Appendix A. Debugging \n\nyou could write: \n\ncount = self.hands[i].removeMatches() return count \n\nNow you have the opportunity to display the value of count before returning. \n\nA.3.4 I\u2019m really, really stuck and I need help. \n\nFirst, try getting away from the computer for a few minutes. Computers emit waves that affect the brain, causing these symptoms: \n\n\u2022 Frustration and rage. \n\n\u2022 Superstitious beliefs (\u201cthe computer hates me\u201d) and magical thinking (\u201cthe program only works when I wear my hat backward\u201d). \n\n\u2022 Random walk programming (the attempt to program by writing every possible pro- gram and choosing the one that does the right thing). \n\nIf you \ufb01nd yourself suffering from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are some possible causes of that behavior? When was the last time you had a working program, and what did you do next? \n\nSometimes it just takes time to \ufb01nd a bug. I often \ufb01nd bugs when I am away from the computer and let my mind wander. Some of the best places to \ufb01nd bugs are trains, showers, and in bed, just before you fall asleep. \n\nA.3.5 No, I really need help. \n\nIt happens. Even the best programmers occasionally get stuck. Sometimes you work on a program so long that you can\u2019t see the error. You need a fresh pair of eyes. \n\nBefore you bring someone else in, make sure you are prepared. Your program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely. \n\nWhen you bring someone in to help, be sure to give them the information they need: \n\n\u2022 If there is an error message, what is it and what part of the program does it indicate? \n\n\u2022 What was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the new test case that fails? \n\n\u2022 What have you tried so far, and what have you learned? \n\nWhen you \ufb01nd the bug, take a second to think about what you could have done to \ufb01nd it faster. Next time you see something similar, you will be able to \ufb01nd the bug more quickly. \n\nRemember, the goal is not just to make the program work. The goal is to learn how to make the program work. \n\n\n## Appendix B\n\n\n",
  "createdAt": "2026-02-17"
}