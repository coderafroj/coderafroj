{
  "title": "Case study: interface design",
  "slug": "thinkpython2-case-study-interface-design",
  "description": "Module from thinkpython2.pdf: Case study: interface design",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Case study: interface design\n\n\n\nThis chapter presents a case study that demonstrates a process for designing functions that work together. \n\nIt introduces the turtle module, which allows you to create images using turtle graphics. The turtle module is included in most Python installations, but if you are running Python using PythonAnywhere, you won\u2019t be able to run the turtle examples (at least you couldn\u2019t when I wrote this). \n\nIf you have already installed Python on your computer, you should be able to run the examples. Otherwise, now is a good time to install. I have posted instructions at http: //tinyurl.com/thinkpython2e. \n\nCode examples from this chapter are available from https://thinkpython.com/code/ polygon.py. \n\n4.1 The turtle module \n\nTo check whether you have the turtle module, open the Python interpreter and type \n\n>>> import turtle >>> bob = turtle.Turtle() \n\nWhen you run this code, it should create a new window with small arrow that represents the turtle. Close the window. \n\nCreate a \ufb01le named mypolygon.py and type in the following code: \n\nimport turtle bob = turtle.Turtle() print(bob) turtle.mainloop() \n\nThe turtle module (with a lowercase \u2019t\u2019) provides a function called Turtle (with an up- percase \u2019T\u2019) that creates a Turtle object, which we assign to a variable named bob. Printing bob displays something like: \n\n<turtle.Turtle object at 0xb7bfbf4c> \n\n30 Chapter 4. Case study: interface design \n\nThis means that bob refers to an object with type Turtle as de\ufb01ned in module turtle. \n\nmainloop tells the window to wait for the user to do something, although in this case there\u2019s not much for the user to do except close the window. \n\nOnce you create a Turtle, you can call a method to move it around the window. A method is similar to a function, but it uses slightly different syntax. For example, to move the turtle forward: \n\nbob.fd(100) \n\nThe method, fd, is associated with the turtle object we\u2019re calling bob. Calling a method is like making a request: you are asking bob to move forward. \n\nThe argument of fd is a distance in pixels, so the actual size depends on your display. \n\nOther methods you can call on a Turtle are bk to move backward, lt for left turn, and rt right turn. The argument for lt and rt is an angle in degrees. \n\nAlso, each Turtle is holding a pen, which is either down or up; if the pen is down, the Turtle leaves a trail when it moves. The methods pu and pd stand for \u201cpen up\u201d and \u201cpen down\u201d. \n\nTo draw a right angle, add these lines to the program (after creating bob and before calling mainloop): \n\nbob.fd(100) bob.lt(90) bob.fd(100) \n\nWhen you run this program, you should see bob move east and then north, leaving two line segments behind. \n\nNow modify the program to draw a square. Don\u2019t go on until you\u2019ve got it working! \n\n4.2 Simple repetition \n\nChances are you wrote something like this: \n\nbob.fd(100) bob.lt(90) \n\nbob.fd(100) bob.lt(90) \n\nbob.fd(100) bob.lt(90) \n\nbob.fd(100) \n\nWe can do the same thing more concisely with a for statement. Add this example to mypolygon.py and run it again: \n\nfor i in range(4): print('Hello!') \n\nYou should see something like this: \n\n4.3. Exercises 31 \n\nHello! Hello! Hello! Hello! This is the simplest use of the for statement; we will see more later. But that should be enough to let you rewrite your square-drawing program. Don\u2019t go on until you do. \n\nHere is a for statement that draws a square: for i in range(4): bob.fd(100) bob.lt(90) The syntax of a for statement is similar to a function de\ufb01nition. It has a header that ends with a colon and an indented body. The body can contain any number of statements. \n\nA for statement is also called a loop because the \ufb02ow of execution runs through the body and then loops back to the top. In this case, it runs the body four times. \n\nThis version is actually a little different from the previous square-drawing code because it makes another turn after drawing the last side of the square. The extra turn takes more time, but it simpli\ufb01es the code if we do the same thing every time through the loop. This version also has the effect of leaving the turtle back in the starting position, facing in the starting direction. \n\n4.3 Exercises \n\nThe following is a series of exercises using the turtle module. They are meant to be fun, but they have a point, too. While you are working on them, think about what the point is. \n\nThe following sections have solutions to the exercises, so don\u2019t look until you have \ufb01nished (or at least tried). \n\n1. Write a function called square that takes a parameter named t, which is a turtle. It should use the turtle to draw a square. \n\nWrite a function call that passes bob as an argument to square, and then run the program again. \n\n2. Add another parameter, named length, to square. Modify the body so length of the sides is length, and then modify the function call to provide a second argument. Run the program again. Test your program with a range of values for length. \n\n3. Make a copy of square and change the name to polygon. Add another parameter named n and modify the body so it draws an n-sided regular polygon. Hint: The exterior angles of an n-sided regular polygon are 360/n degrees. \n\n4. Write a function called circle that takes a turtle, t, and radius, r, as parameters and that draws an approximate circle by calling polygon with an appropriate length and number of sides. Test your function with a range of values of r. \n\nHint: \ufb01gure out the circumference of the circle and make sure that length * n = circumference. \n\n5. Make a more general version of circle called arc that takes an additional parameter angle, which determines what fraction of a circle to draw. angle is in units of degrees, so when angle=360, arc should draw a complete circle. \n\n32 Chapter 4. Case study: interface design \n\n4.4 Encapsulation \n\nThe \ufb01rst exercise asks you to put your square-drawing code into a function de\ufb01nition and then call the function, passing the turtle as a parameter. Here is a solution: \n\ndef square(t): for i in range(4): t.fd(100) t.lt(90) \n\nsquare(bob) \n\nThe innermost statements, fd and lt are indented twice to show that they are inside the for loop, which is inside the function de\ufb01nition. The next line, square(bob), is \ufb02ush with the left margin, which indicates the end of both the for loop and the function de\ufb01nition. \n\nInside the function, t refers to the same turtle bob, so t.lt(90) has the same effect as bob.lt(90). In that case, why not call the parameter bob? The idea is that t can be any turtle, not just bob, so you could create a second turtle and pass it as an argument to square: \n\nalice = turtle.Turtle() square(alice) \n\nWrapping a piece of code up in a function is called encapsulation. One of the bene\ufb01ts of encapsulation is that it attaches a name to the code, which serves as a kind of documenta- tion. Another advantage is that if you re-use the code, it is more concise to call a function twice than to copy and paste the body! \n\n4.5 Generalization \n\nThe next step is to add a length parameter to square. Here is a solution: \n\ndef square(t, length): for i in range(4): t.fd(length) t.lt(90) \n\nsquare(bob, 100) \n\nAdding a parameter to a function is called generalization because it makes the function more general: in the previous version, the square is always the same size; in this version it can be any size. \n\nThe next step is also a generalization. Instead of drawing squares, polygon draws regular polygons with any number of sides. Here is a solution: \n\ndef polygon(t, n, length): angle = 360 / n for i in range(n): t.fd(length) t.lt(angle) \n\npolygon(bob, 7, 70) \n\n4.6. Interface design 33 \n\nThis example draws a 7-sided polygon with side length 70. \n\nIf you are using Python 2, the value of angle might be off because of integer division. A simple solution is to compute angle = 360.0 / n. Because the numerator is a \ufb02oating- point number, the result is \ufb02oating point. \n\nWhen a function has more than a few numeric arguments, it is easy to forget what they are, or what order they should be in. In that case it is often a good idea to include the names of the parameters in the argument list: \n\npolygon(bob, n=7, length=70) \n\nThese are called keyword arguments because they include the parameter names as \u201ckey- words\u201d (not to be confused with Python keywords like while and def). \n\nThis syntax makes the program more readable. It is also a reminder about how arguments and parameters work: when you call a function, the arguments are assigned to the param- eters. \n\n4.6 Interface design \n\nThe next step is to write circle, which takes a radius, r, as a parameter. Here is a simple solution that uses polygon to draw a 50-sided polygon: \n\nimport math \n\ndef circle(t, r): circumference = 2 * math.pi * r n = 50 length = circumference / n polygon(t, n, length) \n\nThe \ufb01rst line computes the circumference of a circle with radius r using the formula 2\u03c0r. Since we use math.pi, we have to import math. By convention, import statements are usually at the beginning of the script. \n\nn is the number of line segments in our approximation of a circle, so length is the length of each segment. Thus, polygon draws a 50-sided polygon that approximates a circle with radius r. \n\nOne limitation of this solution is that n is a constant, which means that for very big circles, the line segments are too long, and for small circles, we waste time drawing very small segments. One solution would be to generalize the function by taking n as a parameter. This would give the user (whoever calls circle) more control, but the interface would be less clean. \n\nThe interface of a function is a summary of how it is used: what are the parameters? What does the function do? And what is the return value? An interface is \u201cclean\u201d if it allows the caller to do what they want without dealing with unnecessary details. \n\nIn this example, r belongs in the interface because it speci\ufb01es the circle to be drawn. n is less appropriate because it pertains to the details of how the circle should be rendered. \n\nRather than clutter up the interface, it is better to choose an appropriate value of n depend- ing on circumference: \n\n34 Chapter 4. Case study: interface design \n\ndef circle(t, r): circumference = 2 * math.pi * r n = int(circumference / 3) + 3 length = circumference / n polygon(t, n, length) \n\nNow the number of segments is an integer near circumference/3, so the length of each segment is approximately 3, which is small enough that the circles look good, but big enough to be ef\ufb01cient, and acceptable for any size circle. \n\nAdding 3 to n guarantees that the polygon has at least 3 sides. \n\n4.7 Refactoring \n\nWhen I wrote circle, I was able to re-use polygon because a many-sided polygon is a good approximation of a circle. But arc is not as cooperative; we can\u2019t use polygon or circle to draw an arc. \n\nOne alternative is to start with a copy of polygon and transform it into arc. The result might look like this: \n\ndef arc(t, r, angle): arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n \n\nfor i in range(n): t.fd(step_length) t.lt(step_angle) \n\nThe second half of this function looks like polygon, but we can\u2019t re-use polygon without changing the interface. We could generalize polygon to take an angle as a third argument, but then polygon would no longer be an appropriate name! Instead, let\u2019s call the more general function polyline: \n\ndef polyline(t, n, length, angle): for i in range(n): t.fd(length) t.lt(angle) \n\nNow we can rewrite polygon and arc to use polyline: \n\ndef polygon(t, n, length): angle = 360.0 / n polyline(t, n, length, angle) \n\ndef arc(t, r, angle): arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = float(angle) / n polyline(t, n, step_length, step_angle) \n\nFinally, we can rewrite circle to use arc: \n\n4.8. A development plan 35 \n\ndef circle(t, r): arc(t, r, 360) \n\nThis process\u2014rearranging a program to improve interfaces and facilitate code re-use\u2014is called refactoring. In this case, we noticed that there was similar code in arc and polygon, so we \u201cfactored it out\u201d into polyline. \n\nIf we had planned ahead, we might have written polyline \ufb01rst and avoided refactoring, but often you don\u2019t know enough at the beginning of a project to design all the interfaces. Once you start coding, you understand the problem better. Sometimes refactoring is a sign that you have learned something. \n\n4.8 A development plan \n\nA development plan is a process for writing programs. The process we used in this case study is \u201cencapsulation and generalization\u201d. The steps of this process are: \n\n1. Start by writing a small program with no function de\ufb01nitions. \n\n2. Once you get the program working, identify a coherent piece of it, encapsulate the piece in a function and give it a name. \n\n3. Generalize the function by adding appropriate parameters. \n\n4. Repeat steps 1\u20133 until you have a set of working functions. Copy and paste working code to avoid retyping (and re-debugging). \n\n5. Look for opportunities to improve the program by refactoring. For example, if you have similar code in several places, consider factoring it into an appropriately general function. \n\nThis process has some drawbacks\u2014we will see alternatives later\u2014but it can be useful if you don\u2019t know ahead of time how to divide the program into functions. This approach lets you design as you go along. \n\n4.9 docstring \n\nA docstring is a string at the beginning of a function that explains the interface (\u201cdoc\u201d is short for \u201cdocumentation\u201d). Here is an example: \n\ndef polyline(t, n, length, angle): \"\"\"Draws n line segments with the given length and angle (in degrees) between them. t is a turtle. \"\"\" for i in range(n): t.fd(length) t.lt(angle) \n\nBy convention, all docstrings are triple-quoted strings, also known as multiline strings because the triple quotes allow the string to span more than one line. \n\n36 Chapter 4. Case study: interface design \n\nIt is terse, but it contains the essential information someone would need to use this func- tion. It explains concisely what the function does (without getting into the details of how it does it). It explains what effect each parameter has on the behavior of the function and what type each parameter should be (if it is not obvious). \n\nWriting this kind of documentation is an important part of interface design. A well- designed interface should be simple to explain; if you have a hard time explaining one of your functions, maybe the interface could be improved. \n\n4.10 Debugging \n\nAn interface is like a contract between a function and a caller. The caller agrees to provide certain parameters and the function agrees to do certain work. \n\nFor example, polyline requires four arguments: t has to be a Turtle; n has to be an integer; length should be a positive number; and angle has to be a number, which is understood to be in degrees. \n\nThese requirements are called preconditions because they are supposed to be true before the function starts executing. Conversely, conditions at the end of the function are post- conditions. Postconditions include the intended effect of the function (like drawing line segments) and any side effects (like moving the Turtle or making other changes). \n\nPreconditions are the responsibility of the caller. If the caller violates a (properly docu- mented!) precondition and the function doesn\u2019t work correctly, the bug is in the caller, not the function. \n\nIf the preconditions are satis\ufb01ed and the postconditions are not, the bug is in the function. If your pre- and postconditions are clear, they can help with debugging. \n\n4.11 Glossary \n\nmethod: A function that is associated with an object and called using dot notation. \n\nloop: A part of a program that can run repeatedly. \n\nencapsulation: The process of transforming a sequence of statements into a function de\ufb01- nition. \n\ngeneralization: The process of replacing something unnecessarily speci\ufb01c (like a number) with something appropriately general (like a variable or parameter). \n\nkeyword argument: An argument that includes the name of the parameter as a \u201ckey- word\u201d. \n\ninterface: A description of how to use a function, including the name and descriptions of the arguments and return value. \n\nrefactoring: The process of modifying a working program to improve function interfaces and other qualities of the code. \n\ndevelopment plan: A process for writing programs. \n\n4.12. Exercises 37 \n\nFigure 4.1: Turtle \ufb02owers. \n\nFigure 4.2: Turtle pies. \n\ndocstring: A string that appears at the top of a function de\ufb01nition to document the func- tion\u2019s interface. \n\nprecondition: A requirement that should be satis\ufb01ed by the caller before a function starts. \n\npostcondition: A requirement that should be satis\ufb01ed by the function before it ends. \n\n4.12 Exercises \n\nExercise 4.1. Download the code in this chapter from https: // thinkpython. com/ code/ polygon. py . \n\n1. Draw a stack diagram that shows the state of the program while executing circle(bob, radius). You can do the arithmetic by hand or add print statements to the code. \n\n2. The version of arc in Section 4.7 is not very accurate because the linear approximation of the circle is always outside the true circle. As a result, the Turtle ends up a few pixels away from the correct destination. My solution shows a way to reduce the effect of this error. Read the code and see if it makes sense to you. If you draw a diagram, you might see how it works. Exercise 4.2. Write an appropriately general set of functions that can draw \ufb02owers as in Figure 4.1. \n\nSolution: https: // thinkpython. com/ code/ flower. py , also requires https: // thinkpython. com/ code/ polygon. py . Exercise 4.3. Write an appropriately general set of functions that can draw shapes as in Figure 4.2. \n\nSolution: https: // thinkpython. com/ code/ pie. py . Exercise 4.4. The letters of the alphabet can be constructed from a moderate number of basic ele- ments, like vertical and horizontal lines and a few curves. Design an alphabet that can be drawn with a minimal number of basic elements and then write functions that draw the letters. \n\nYou should write one function for each letter, with names draw_a, draw_b, etc., and put your functions in a \ufb01le named letters.py. You can download a \u201cturtle typewriter\u201d from https: // thinkpython. com/ code/ typewriter. py to help you test your code. \n\n38 Chapter 4. Case study: interface design \n\nYou can get a solution from https: // thinkpython. com/ code/ letters. py ; it also requires https: // thinkpython. com/ code/ polygon. py . Exercise 4.5. Read about spirals at http: // en. wikipedia. org/ wiki/ Spiral ; then write a program that draws an Archimedian spiral (or one of the other kinds). Solution: https: // thinkpython. com/ code/ spiral. py . \n\n\n## Chapter 5\n\n\n",
  "createdAt": "2026-02-17"
}