{
  "title": "The Goodies",
  "slug": "thinkpython2-the-goodies",
  "description": "Module from thinkpython2.pdf: The Goodies",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# The Goodies\n\n\n\nOne of my goals for this book has been to teach you as little Python as possible. When \nthere were two ways to do something, I picked one and avoided mentioning the other. Or \nsometimes I put the second one into an exercise. \n\nNow I want to go back for some of the good bits that got left behind. Python provides a \nnumber of features that are not really necessary\u2014you can write good code without them\u2014 \nbut with them you can sometimes write code that\u2019s more concise, readable or ef\ufb01cient, and \nsometimes all three. \n\n19.1 \nConditional expressions \n\nWe saw conditional statements in Section 5.4. Conditional statements are often used to \nchoose one of two values; for example: \n\nif x > 0: \ny = math.log(x) \nelse: \ny = float('nan') \n\nThis statement checks whether x is positive. If so, it computes math.log . If not, math.log \nwould raise a ValueError. To avoid stopping the program, we generate a \u201cNaN\u201d, which is \na special \ufb02oating-point value that represents \u201cNot a Number\u201d. \n\nWe can write this statement more concisely using a conditional expression : \n\ny = math.log(x) if x > 0 else float('nan') \n\nYou can almost read this line like English: \u201c y gets log- x if x is greater than 0; otherwise it \ngets NaN\u201d. \n\nRecursive functions can sometimes be rewritten using conditional expressions. For exam- \nple, here is a recursive version of factorial : \n\ndef factorial(n): \nif n == 0: \nreturn 1 \nelse: \nreturn n * factorial(n-1) \n\n184 \nChapter 19. The Goodies \n\nWe can rewrite it like this: \n\ndef factorial(n): \nreturn 1 if n == 0 else n * factorial(n-1) \n\nAnother use of conditional expressions is handling optional arguments. For example, here \nis the init method from GoodKangaroo (see Exercise 17.2): \n\ndef __init__(self, name, contents=None): \nself.name = name \nif contents == None: \ncontents = [] \nself.pouch_contents = contents \n\nWe can rewrite this one like this: \n\ndef __init__(self, name, contents=None): \nself.name = name \nself.pouch_contents = [] if contents == None else contents \n\nIn general, you can replace a conditional statement with a conditional expression if both \nbranches contain simple expressions that are either returned or assigned to the same vari- \nable. \n\n19.2 \nList comprehensions \n\nIn Section 10.7 we saw the map and \ufb01lter patterns. For example, this function takes a list \nof strings, maps the string method capitalize to the elements, and returns a new list of \nstrings: \n\ndef capitalize_all(t): \nres = [] \nfor s in t: \nres.append(s.capitalize()) \nreturn res \n\nWe can write this more concisely using a list comprehension : \n\ndef capitalize_all(t): \nreturn [s.capitalize() for s in t] \n\nThe bracket operators indicate that we are constructing a new list. The expression inside \nthe brackets speci\ufb01es the elements of the list, and the for clause indicates what sequence \nwe are traversing. \n\nThe syntax of a list comprehension is a little awkward because the loop variable, s in this \nexample, appears in the expression before we get to the de\ufb01nition. \n\nList comprehensions can also be used for \ufb01ltering. For example, this function selects only \nthe elements of t that are upper case, and returns a new list: \n\ndef only_upper(t): \nres = [] \nfor s in t: \nif s.isupper(): \nres.append(s) \nreturn res \n\n19.3. Generator expressions \n185 \n\nWe can rewrite it using a list comprehension \n\ndef only_upper(t): \nreturn [s for s in t if s.isupper()] \n\nList comprehensions are concise and easy to read, at least for simple expressions. And they \nare usually faster than the equivalent for loops, sometimes much faster. So if you are mad \nat me for not mentioning them earlier, I understand. \n\nBut, in my defense, list comprehensions are harder to debug because you can\u2019t put a print \nstatement inside the loop. I suggest that you use them only if the computation is simple \nenough that you are likely to get it right the \ufb01rst time. And for beginners that means never. \n\n19.3 \nGenerator expressions \n\nGenerator expressions are similar to list comprehensions, but with parentheses instead of \nsquare brackets: \n\n>>> g = (x**2 for x in range(5)) \n>>> g \n<generator object <genexpr> at 0x7f4c45a786c0> \n\nThe result is a generator object that knows how to iterate through a sequence of values. But \nunlike a list comprehension, it does not compute the values all at once; it waits to be asked. \nThe built-in function next gets the next value from the generator: \n\n>>> next(g) \n0 \n>>> next(g) \n1 \n\nWhen you get to the end of the sequence, next raises a StopIteration exception. You can \nalso use a for loop to iterate through the values: \n\n>>> for val in g: \n... \nprint(val) \n4 \n9 \n16 \n\nThe generator object keeps track of where it is in the sequence, so the for loop picks up \nwhere next left off. Once the generator is exhausted, it continues to raise StopIteration : \n\n>>> next(g) \nStopIteration \n\nGenerator expressions are often used with functions like sum , max , and min : \n\n>>> sum(x**2 for x in range(5)) \n30 \n\n19.4 \nany and all \n\nPython provides a built-in function, any , that takes a sequence of boolean values and re- \nturns True if any of the values are True . It works on lists: \n\n186 \nChapter 19. The Goodies \n\n>>> any([False, False, True]) \nTrue \n\nBut it is often used with generator expressions: \n\n>>> any(letter == 't' for letter in 'monty') \nTrue \n\nThat example isn\u2019t very useful because it does the same thing as the in operator. But we \ncould use any to rewrite some of the search functions we wrote in Section 9.3. For example, \nwe could write avoids like this: \n\ndef avoids(word, forbidden): \nreturn not any(letter in forbidden for letter in word) \n\nThe function almost reads like English, \u201c word avoids forbidden if there are not any forbid- \nden letters in word .\u201d \n\nUsing any with a generator expression is ef\ufb01cient because it stops immediately if it \ufb01nds a \nTrue value, so it doesn\u2019t have to evaluate the whole sequence. \n\nPython provides another built-in function, all , that returns True if every element of the \nsequence is True . As an exercise, use all to re-write uses_all from Section 9.3. \n\n19.5 \nSets \n\nIn Section 13.6 I use dictionaries to \ufb01nd the words that appear in a document but not in a \nword list. The function I wrote takes d1 , which contains the words from the document as \nkeys, and d2 , which contains the list of words. It returns a dictionary that contains the keys \nfrom d1 that are not in d2 . \n\ndef subtract(d1, d2): \nres = dict() \nfor key in d1: \nif key not in d2: \nres[key] = None \nreturn res \n\nIn all of these dictionaries, the values are None because we never use them. As a result, we \nwaste some storage space. \n\nPython provides another built-in type, called a set , that behaves like a collection of dic- \ntionary keys with no values. Adding elements to a set is fast; so is checking membership. \nAnd sets provide methods and operators to compute common set operations. \n\nFor example, set subtraction is available as a method called difference or as an operator, \n- . So we can rewrite subtract like this: \n\ndef subtract(d1, d2): \nreturn set(d1) - set(d2) \n\nThe result is a set instead of a dictionary, but for operations like iteration, the behavior is \nthe same. \n\nSome of the exercises in this book can be done concisely and ef\ufb01ciently with sets. For \nexample, here is a solution to has_duplicates , from Exercise 10.7, that uses a dictionary: \n\n19.6. Counters \n187 \n\ndef has_duplicates(t): \nd = {} \nfor x in t: \nif x in d: \nreturn True \nd[x] = True \nreturn False \n\nWhen an element appears for the \ufb01rst time, it is added to the dictionary. If the same element \nappears again, the function returns True . \n\nUsing sets, we can write the same function like this: \n\ndef has_duplicates(t): \nreturn len(set(t)) < len(t) \n\nAn element can only appear in a set once, so if an element in t appears more than once, the \nset will be smaller than t . If there are no duplicates, the set will be the same size as t . \n\nWe can also use sets to do some of the exercises in Chapter 9. For example, here\u2019s a version \nof uses_only with a loop: \n\ndef uses_only(word, available): \nfor letter in word: \nif letter not in available: \nreturn False \nreturn True \n\nuses_only checks whether all letters in word are in available . We can rewrite it like this: \n\ndef uses_only(word, available): \nreturn set(word) <= set(available) \n\nThe <= operator checks whether one set is a subset of another, including the possibility that \nthey are equal, which is true if all the letters in word appear in available . \n\nAs an exercise, rewrite avoids using sets. \n\n19.6 \nCounters \n\nA Counter is like a set, except that if an element appears more than once, the Counter \nkeeps track of how many times it appears. If you are familiar with the mathematical idea \nof a multiset , a Counter is a natural way to represent a multiset. \n\nCounter is de\ufb01ned in a standard module called collections , so you have to import it. You \ncan initialize a Counter with a string, list, or anything else that supports iteration: \n\n>>> from collections import Counter \n>>> count = Counter('parrot') \n>>> count \nCounter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1}) \n\nCounters behave like dictionaries in many ways; they map from each key to the number of \ntimes it appears. As in dictionaries, the keys have to be hashable. \n\nUnlike dictionaries, Counters don\u2019t raise an exception if you access an element that doesn\u2019t \nappear. Instead, they return 0: \n\n188 \nChapter 19. The Goodies \n\n>>> count['d'] \n0 \n\nWe can use Counters to rewrite is_anagram from Exercise 10.6: \n\ndef is_anagram(word1, word2): \nreturn Counter(word1) == Counter(word2) \n\nIf two words are anagrams, they contain the same letters with the same counts, so their \nCounters are equivalent. \n\nCounters provide methods and operators to perform set-like operations, including ad- \ndition, subtraction, union and intersection. And they provide an often-useful method, \nmost_common , which returns a list of value-frequency pairs, sorted from most common to \nleast: \n\n>>> count = Counter('parrot') \n>>> for val, freq in count.most_common(3): \n... \nprint(val, freq) \nr 2 \np 1 \na 1 \n\n19.7 \ndefaultdict \n\nThe collections module also provides defaultdict , which is like a dictionary except that \nif you access a key that doesn\u2019t exist, it can generate a new value on the \ufb02y. \n\nWhen you create a defaultdict, you provide a function that\u2019s used to create new values. A \nfunction used to create objects is sometimes called a factory . The built-in functions that \ncreate lists, sets, and other types can be used as factories: \n\n>>> from collections import defaultdict \n>>> d = defaultdict(list) \n\nNotice that the argument is list , which is a class object, not list() , which is a new list. \nThe function you provide doesn\u2019t get called unless you access a key that doesn\u2019t exist. \n\n>>> t = d['new key'] \n>>> t \n[] \n\nThe new list, which we\u2019re calling t , is also added to the dictionary. So if we modify t , the \nchange appears in d : \n\n>>> t.append('new value') \n>>> d \ndefaultdict(<class 'list'>, {'new key': ['new value']}) \n\nIf you are making a dictionary of lists, you can often write simpler code using defaultdict . \nIn my solution to Exercise 12.2, which you can get from https://thinkpython.com/code/ \nanagram_sets.py , I make a dictionary that maps from a sorted string of letters to the list of \nwords that can be spelled with those letters. For example, \u2019opst\u2019 maps to the list [\u2019opts\u2019, \n\u2019post\u2019, \u2019pots\u2019, \u2019spot\u2019, \u2019stop\u2019, \u2019tops\u2019] . \n\nHere\u2019s the original code: \n\n19.8. Named tuples \n189 \n\ndef all_anagrams(filename): \nd = {} \nfor line in open(filename): \nword = line.strip().lower() \nt = signature(word) \nif t not in d: \nd[t] = [word] \nelse: \nd[t].append(word) \nreturn d \n\nThis can be simpli\ufb01ed using setdefault , which you might have used in Exercise 11.2: \n\ndef all_anagrams(filename): \nd = {} \nfor line in open(filename): \nword = line.strip().lower() \nt = signature(word) \nd.setdefault(t, []).append(word) \nreturn d \n\nThis solution has the drawback that it makes a new list every time, regardless of whether \nit is needed. For lists, that\u2019s no big deal, but if the factory function is complicated, it might \nbe. \n\nWe can avoid this problem and simplify the code using a defaultdict : \n\ndef all_anagrams(filename): \nd = defaultdict(list) \nfor line in open(filename): \nword = line.strip().lower() \nt = signature(word) \nd[t].append(word) \nreturn d \n\nMy solution to Exercise 18.3, which you can download from https://thinkpython.com/ \ncode/PokerHandSoln.py , uses setdefault in the function has_straightflush . This solu- \ntion has the drawback of creating a Hand object every time through the loop, whether it is \nneeded or not. As an exercise, rewrite it using a defaultdict. \n\n19.8 \nNamed tuples \n\nMany simple objects are basically collections of related values. For example, the Point \nobject de\ufb01ned in Chapter 15 contains two numbers, x and y . When you de\ufb01ne a class like \nthis, you usually start with an init method and a str method: \n\nclass Point: \n\ndef __init__(self, x=0, y=0): \nself.x = x \nself.y = y \n\ndef __str__(self): \nreturn '(%g, %g)' % (self.x, self.y) \n\n190 \nChapter 19. The Goodies \n\nThis is a lot of code to convey a small amount of information. Python provides a more \nconcise way to say the same thing: \n\nfrom collections import namedtuple \nPoint = namedtuple('Point', ['x', 'y']) \n\nThe \ufb01rst argument is the name of the class you want to create. The second is a list of the \nattributes Point objects should have, as strings. The return value from namedtuple is a class \nobject: \n\n>>> Point \n<class '__main__.Point'> \n\nPoint automatically provides methods like __init__ and __str__ so you don\u2019t have to \nwrite them. \n\nTo create a Point object, you use the Point class as a function: \n\n>>> p = Point(1, 2) \n>>> p \nPoint(x=1, y=2) \n\nThe init method assigns the arguments to attributes using the names you provided. The \nstr method prints a representation of the Point object and its attributes. \n\nYou can access the elements of the named tuple by name: \n\n>>> p.x, p.y \n(1, 2) \n\nBut you can also treat a named tuple as a tuple: \n\n>>> p[0], p[1] \n(1, 2) \n\n>>> x, y = p \n>>> x, y \n(1, 2) \n\nNamed tuples provide a quick way to de\ufb01ne simple classes. The drawback is that simple \nclasses don\u2019t always stay simple. You might decide later that you want to add methods \nto a named tuple. In that case, you could de\ufb01ne a new class that inherits from the named \ntuple: \n\nclass Pointier(Point): \n# add more methods here \n\nOr you could switch to a conventional class de\ufb01nition. \n\n19.9 \nGathering keyword args \n\nIn Section 12.4, we saw how to write a function that gathers its arguments into a tuple: \n\ndef printall(*args): \nprint(args) \n\nYou can call this function with any number of positional arguments (that is, arguments that \ndon\u2019t have keywords): \n\n19.10. Glossary \n191 \n\n>>> printall(1, 2.0, '3') \n(1, 2.0, '3') \n\nBut the * operator doesn\u2019t gather keyword arguments: \n\n>>> printall(1, 2.0, third='3') \nTypeError: printall() got an unexpected keyword argument 'third' \n\nTo gather keyword arguments, you can use the ** operator: \n\ndef printall(*args, **kwargs): \nprint(args, kwargs) \n\nYou can call the keyword gathering parameter anything you want, but kwargs is a common \nchoice. The result is a dictionary that maps from keywords to values: \n\n>>> printall(1, 2.0, third='3') \n(1, 2.0) {'third': '3'} \n\nIf you have a dictionary of keywords and values, you can use the scatter operator, ** to \ncall a function: \n\n>>> d = dict(x=1, y=2) \n>>> Point(**d) \nPoint(x=1, y=2) \n\nWithout the scatter operator, the function would treat d as a single positional argument, so \nit would assign d to x and complain because there\u2019s nothing to assign to y : \n\n>>> d = dict(x=1, y=2) \n>>> Point(d) \nTraceback (most recent call last): \nFile \"<stdin>\", line 1, in <module> \nTypeError: __new__() missing 1 required positional argument: 'y' \n\nWhen you are working with functions that have a large number of parameters, it is often \nuseful to create and pass around dictionaries that specify frequently used options. \n\n19.10 \nGlossary \n\nconditional expression: An expression that has one of two values, depending on a condi- \ntion. \n\nlist comprehension: An expression with a for loop in square brackets that yields a new \nlist. \n\ngenerator expression: An expression with a for loop in parentheses that yields a genera- \ntor object. \n\nmultiset: A mathematical entity that represents a mapping between the elements of a set \nand the number of times they appear. \n\nfactory: A function, usually passed as a parameter, used to create objects. \n\n192 \nChapter 19. The Goodies \n\n19.11 \nExercises \n\nExercise 19.1. The following is a function that computes the binomial coef\ufb01cient recursively. \n\ndef binomial_coeff(n, k): \n\"\"\"Compute the binomial coefficient \"n choose k\". \n\nn: number of trials \nk: number of successes \n\nreturns: int \n\"\"\" \nif k == 0: \nreturn 1 \nif n == 0: \nreturn 0 \n\nres = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1) \nreturn res \n\nRewrite the body of the function using nested conditional expressions. \n\nOne note: this function is not very ef\ufb01cient because it ends up computing the same values over and \nover. You could make it more ef\ufb01cient by memoizing (see Section 11.6). But you will \ufb01nd that it\u2019s \nharder to memoize if you write it using conditional expressions. \n\n\n## Appendix A\n\n\n",
  "createdAt": "2026-02-17"
}