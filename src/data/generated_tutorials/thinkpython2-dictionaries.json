{
  "title": "Dictionaries",
  "slug": "thinkpython2-dictionaries",
  "description": "Module from thinkpython2.pdf: Dictionaries",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Dictionaries\n\n\n\nThis chapter presents another built-in type called a dictionary. Dictionaries are one of \nPython\u2019s best features; they are the building blocks of many ef\ufb01cient and elegant algo- \nrithms. \n\n11.1 \nA dictionary is a mapping \n\nA dictionary is like a list, but more general. In a list, the indices have to be integers; in a \ndictionary they can be (almost) any type. \n\nA dictionary contains a collection of indices, which are called keys , and a collection of \nvalues. Each key is associated with a single value. The association of a key and a value is \ncalled a key-value pair or sometimes an item . \n\nIn mathematical language, a dictionary represents a mapping from keys to values, so you \ncan also say that each key \u201cmaps to\u201d a value. As an example, we\u2019ll build a dictionary that \nmaps from English to Spanish words, so the keys and the values are all strings. \n\nThe function dict creates a new dictionary with no items. Because dict is the name of a \nbuilt-in function, you should avoid using it as a variable name. \n\n>>> eng2sp = dict() \n>>> eng2sp \n{} \n\nThe squiggly-brackets, {} , represent an empty dictionary. To add items to the dictionary, \nyou can use square brackets: \n\n>>> eng2sp['one'] = 'uno' \n\nThis line creates an item that maps from the key 'one' to the value 'uno' . If we print the \ndictionary again, we see a key-value pair with a colon between the key and value: \n\n>>> eng2sp \n{'one': 'uno'} \n\nThis output format is also an input format. For example, you can create a new dictionary \nwith three items: \n\n104 \nChapter 11. Dictionaries \n\n>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'} \n\nBut if you print eng2sp , you might be surprised: \n\n>>> eng2sp \n{'one': 'uno', 'three': 'tres', 'two': 'dos'} \n\nThe order of the key-value pairs might not be the same. If you type the same example \non your computer, you might get a different result. In general, the order of items in a \ndictionary is unpredictable. \n\nBut that\u2019s not a problem because the elements of a dictionary are never indexed with inte- \nger indices. Instead, you use the keys to look up the corresponding values: \n\n>>> eng2sp['two'] \n'dos' \n\nThe key 'two' always maps to the value 'dos' so the order of the items doesn\u2019t matter. \n\nIf the key isn\u2019t in the dictionary, you get an exception: \n\n>>> eng2sp['four'] \nKeyError: 'four' \n\nThe len function works on dictionaries; it returns the number of key-value pairs: \n\n>>> len(eng2sp) \n3 \n\nThe in operator works on dictionaries, too; it tells you whether something appears as a key \nin the dictionary (appearing as a value is not good enough). \n\n>>> 'one' in eng2sp \nTrue \n>>> 'uno' in eng2sp \nFalse \n\nTo see whether something appears as a value in a dictionary, you can use the method \nvalues , which returns a collection of values, and then use the in operator: \n\n>>> vals = eng2sp.values() \n>>> 'uno' in vals \nTrue \n\nThe in operator uses different algorithms for lists and dictionaries. For lists, it searches the \nelements of the list in order, as in Section 8.6. As the list gets longer, the search time gets \nlonger in direct proportion. \n\nPython dictionaries use a data structure called a hashtable that has a remarkable property: \nthe in operator takes about the same amount of time no matter how many items are in the \ndictionary. I explain how that\u2019s possible in Section B.4, but the explanation might not make \nsense until you\u2019ve read a few more chapters. \n\n11.2 \nDictionary as a collection of counters \n\nSuppose you are given a string and you want to count how many times each letter appears. \nThere are several ways you could do it: \n\n11.2. Dictionary as a collection of counters \n105 \n\n1. You could create 26 variables, one for each letter of the alphabet. Then you could tra- \nverse the string and, for each character, increment the corresponding counter, proba- \nbly using a chained conditional. \n\n2. You could create a list with 26 elements. Then you could convert each character to \na number (using the built-in function ord ), use the number as an index into the list, \nand increment the appropriate counter. \n\n3. You could create a dictionary with characters as keys and counters as the correspond- \ning values. The \ufb01rst time you see a character, you would add an item to the dictionary. \nAfter that you would increment the value of an existing item. \n\nEach of these options performs the same computation, but each of them implements that \ncomputation in a different way. \n\nAn implementation is a way of performing a computation; some implementations are \nbetter than others. For example, an advantage of the dictionary implementation is that we \ndon\u2019t have to know ahead of time which letters appear in the string and we only have to \nmake room for the letters that do appear. \n\nHere is what the code might look like: \n\ndef histogram(s): \nd = dict() \nfor c in s: \nif c not in d: \nd[c] = 1 \nelse: \nd[c] += 1 \nreturn d \n\nThe name of the function is histogram , which is a statistical term for a collection of counters \n(or frequencies). \n\nThe \ufb01rst line of the function creates an empty dictionary. The for loop traverses the string. \nEach time through the loop, if the character c is not in the dictionary, we create a new item \nwith key c and the initial value 1 (since we have seen this letter once). If c is already in the \ndictionary we increment d[c] . \n\nHere\u2019s how it works: \n\n>>> h = histogram('brontosaurus') \n>>> h \n{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1} \n\nThe histogram indicates that the letters 'a' and 'b' appear once; 'o' appears twice, and \nso on. \n\nDictionaries have a method called get that takes a key and a default value. If the key \nappears in the dictionary, get returns the corresponding value; otherwise it returns the \ndefault value. For example: \n\n>>> h = histogram('a') \n>>> h \n{'a': 1} \n>>> h.get('a', 0) \n\n106 \nChapter 11. Dictionaries \n\n1 \n>>> h.get('c', 0) \n0 \n\nAs an exercise, use get to write histogram more concisely. You should be able to eliminate \nthe if statement. \n\n11.3 \nLooping and dictionaries \n\nIf you use a dictionary in a for statement, it traverses the keys of the dictionary. For exam- \nple, print_hist prints each key and the corresponding value: \n\ndef print_hist(h): \nfor c in h: \nprint(c, h[c]) \n\nHere\u2019s what the output looks like: \n\n>>> h = histogram('parrot') \n>>> print_hist(h) \na 1 \np 1 \nr 2 \nt 1 \no 1 \n\nAgain, the keys are in no particular order. To traverse the keys in sorted order, you can use \nthe built-in function sorted : \n\n>>> for key in sorted(h): \n... \nprint(key, h[key]) \na 1 \no 1 \np 1 \nr 2 \nt 1 \n\n11.4 \nReverse lookup \n\nGiven a dictionary d and a key k , it is easy to \ufb01nd the corresponding value v = d[k] . This \noperation is called a lookup . \n\nBut what if you have v and you want to \ufb01nd k ? You have two problems: \ufb01rst, there might \nbe more than one key that maps to the value v . Depending on the application, you might \nbe able to pick one, or you might have to make a list that contains all of them. Second, \nthere is no simple syntax to do a reverse lookup ; you have to search. \n\nHere is a function that takes a value and returns the \ufb01rst key that maps to that value: \n\ndef reverse_lookup(d, v): \nfor k in d: \nif d[k] == v: \nreturn k \nraise LookupError() \n\n11.5. Dictionaries and lists \n107 \n\nThis function is yet another example of the search pattern, but it uses a feature we haven\u2019t \nseen before, raise . \nThe raise statement causes an exception; in this case it causes a \nLookupError , which is a built-in exception used to indicate that a lookup operation failed. \n\nIf we get to the end of the loop, that means v doesn\u2019t appear in the dictionary as a value, so \nwe raise an exception. \n\nHere is an example of a successful reverse lookup: \n\n>>> h = histogram('parrot') \n>>> key = reverse_lookup(h, 2) \n>>> key \n'r' \n\nAnd an unsuccessful one: \n\n>>> key = reverse_lookup(h, 3) \nTraceback (most recent call last): \nFile \"<stdin>\", line 1, in <module> \nFile \"<stdin>\", line 5, in reverse_lookup \nLookupError \n\nThe effect when you raise an exception is the same as when Python raises one: it prints a \ntraceback and an error message. \n\nWhen you raise an exception, you can provide a detailed error message as an optional \nargument. For example: \n\n>>> raise LookupError('value does not appear in the dictionary') \nTraceback (most recent call last): \nFile \"<stdin>\", line 1, in ? \nLookupError: value does not appear in the dictionary \n\nA reverse lookup is much slower than a forward lookup; if you have to do it often, or if the \ndictionary gets big, the performance of your program will suffer. \n\n11.5 \nDictionaries and lists \n\nLists can appear as values in a dictionary. For example, if you are given a dictionary that \nmaps from letters to frequencies, you might want to invert it; that is, create a dictionary \nthat maps from frequencies to letters. Since there might be several letters with the same \nfrequency, each value in the inverted dictionary should be a list of letters. \n\nHere is a function that inverts a dictionary: \n\ndef invert_dict(d): \ninverse = dict() \nfor key in d: \nval = d[key] \nif val not in inverse: \ninverse[val] = [key] \nelse: \ninverse[val].append(key) \nreturn inverse \n\n108 \nChapter 11. Dictionaries \n\n\u2019a\u2019 \n1 \n\n1 \n\ndict \n\nhist \n\n\u2019p\u2019 \n\n1 \n\n\u2019o\u2019 \n1 \n\n\u2019r\u2019 \n2 \n\n\u2019t\u2019 \n\n0 \n\n1 \n\n\u2019a\u2019 \n\n\u2019p\u2019 \n\nlist \n\n2 \n\u2019t\u2019 \n\n\u2019o\u2019 \n3 \n\n1 \n\ndict \n\ninv \n\n2 \n0 \n\nlist \n\n\u2019r\u2019 \n\nFigure 11.1: State diagram. \n\nEach time through the loop, key gets a key from d and val gets the corresponding value. \nIf val is not in inverse , that means we haven\u2019t seen it before, so we create a new item and \ninitialize it with a singleton (a list that contains a single element). Otherwise we have seen \nthis value before, so we append the corresponding key to the list. \n\nHere is an example: \n\n>>> hist = histogram('parrot') \n>>> hist \n{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1} \n>>> inverse = invert_dict(hist) \n>>> inverse \n{1: ['a', 'p', 't', 'o'], 2: ['r']} \n\nFigure 11.1 is a state diagram showing hist and inverse . A dictionary is represented as a \nbox with the type dict above it and the key-value pairs inside. If the values are integers, \n\ufb02oats or strings, I draw them inside the box, but I usually draw lists outside the box, just \nto keep the diagram simple. \n\nLists can be values in a dictionary, as this example shows, but they cannot be keys. Here\u2019s \nwhat happens if you try: \n\n>>> t = [1, 2, 3] \n>>> d = dict() \n>>> d[t] = 'oops' \nTraceback (most recent call last): \nFile \"<stdin>\", line 1, in ? \nTypeError: list objects are unhashable \n\nI mentioned earlier that a dictionary is implemented using a hashtable and that means that \nthe keys have to be hashable . \n\nA hash is a function that takes a value (of any kind) and returns an integer. Dictionaries \nuse these integers, called hash values, to store and look up key-value pairs. \n\nThis system works \ufb01ne if the keys are immutable. But if the keys are mutable, like lists, \nbad things happen. For example, when you create a key-value pair, Python hashes the key \nand stores it in the corresponding location. If you modify the key and then hash it again, it \nwould go to a different location. In that case you might have two entries for the same key, \nor you might not be able to \ufb01nd a key. Either way, the dictionary wouldn\u2019t work correctly. \n\nThat\u2019s why keys have to be hashable, and why mutable types like lists aren\u2019t. The simplest \nway to get around this limitation is to use tuples, which we will see in the next chapter. \n\n11.6. Memos \n109 \n\nfibonacci \nn \n4 \n\nfibonacci \nn \n3 \nfibonacci \nn \n2 \n\nfibonacci \nn \n0 \nfibonacci \nn \n1 \nfibonacci \nn \n1 \nfibonacci \nn \n2 \n\nfibonacci \nn \n0 \nfibonacci \nn \n1 \n\nFigure 11.2: Call graph. \n\nSince dictionaries are mutable, they can\u2019t be used as keys, but they can be used as values. \n\n11.6 \nMemos \n\nIf you played with the fibonacci function from Section 6.7, you might have noticed that \nthe bigger the argument you provide, the longer the function takes to run. Furthermore, \nthe run time increases quickly. \n\nTo understand why, consider Figure 11.2, which shows the call graph for fibonacci with \nn=4 : \n\nA call graph shows a set of function frames, with lines connecting each frame to the frames \nof the functions it calls. At the top of the graph, fibonacci with n=4 calls fibonacci with \nn=3 and n=2 . In turn, fibonacci with n=3 calls fibonacci with n=2 and n=1 . And so on. \n\nCount how many times fibonacci(0) and fibonacci(1) are called. This is an inef\ufb01cient \nsolution to the problem, and it gets worse as the argument gets bigger. \n\nOne solution is to keep track of values that have already been computed by storing them \nin a dictionary. A previously computed value that is stored for later use is called a memo . \nHere is a \u201cmemoized\u201d version of fibonacci : \n\nknown = {0:0, 1:1} \n\ndef fibonacci(n): \nif n in known: \nreturn known[n] \n\nres = fibonacci(n-1) + fibonacci(n-2) \nknown[n] = res \nreturn res \n\nknown is a dictionary that keeps track of the Fibonacci numbers we already know. It starts \nwith two items: 0 maps to 0 and 1 maps to 1. \n\n110 \nChapter 11. Dictionaries \n\nWhenever fibonacci is called, it checks known . If the result is already there, it can return \nimmediately. Otherwise it has to compute the new value, add it to the dictionary, and \nreturn it. \n\nIf you run this version of fibonacci and compare it with the original, you will \ufb01nd that it \nis much faster. \n\n11.7 \nGlobal variables \n\nIn the previous example, known is created outside the function, so it belongs to the special \nframe called __main__ . Variables in __main__ are sometimes called global because they \ncan be accessed from any function. Unlike local variables, which disappear when their \nfunction ends, global variables persist from one function call to the next. \n\nIt is common to use global variables for \ufb02ags ; that is, boolean variables that indicate (\u201c\ufb02ag\u201d) \nwhether a condition is true. For example, some programs use a \ufb02ag named verbose to \ncontrol the level of detail in the output: \n\nverbose = True \n\ndef example1(): \nif verbose: \nprint('Running example1') \n\nIf you try to reassign a global variable, you might be surprised. The following example is \nsupposed to keep track of whether the function has been called: \n\nbeen_called = False \n\ndef example2(): \nbeen_called = True \n# WRONG \n\nBut if you run it you will see that the value of been_called doesn\u2019t change. The problem \nis that example2 creates a new local variable named been_called . The local variable goes \naway when the function ends, and has no effect on the global variable. \n\nTo reassign a global variable inside a function you have to declare the global variable before \nyou use it: \n\nbeen_called = False \n\ndef example2(): \nglobal been_called \nbeen_called = True \n\nThe global statement tells the interpreter something like, \u201cIn this function, when I say \nbeen_called , I mean the global variable; don\u2019t create a local one.\u201d \n\nHere\u2019s an example that tries to update a global variable: \n\ncount = 0 \n\ndef example3(): \ncount = count + 1 \n# WRONG \n\nIf you run it you get: \n\n11.8. Debugging \n111 \n\nUnboundLocalError: local variable 'count' referenced before assignment \n\nPython assumes that count is local, and under that assumption you are reading it before \nwriting it. The solution, again, is to declare count global. \n\ndef example3(): \nglobal count \ncount += 1 \n\nIf a global variable refers to a mutable value, you can modify the value without declaring \nthe variable: \n\nknown = {0:0, 1:1} \n\ndef example4(): \nknown[2] = 1 \n\nSo you can add, remove and replace elements of a global list or dictionary, but if you want \nto reassign the variable, you have to declare it: \n\ndef example5(): \nglobal known \nknown = dict() \n\nGlobal variables can be useful, but if you have a lot of them, and you modify them fre- \nquently, they can make programs hard to debug. \n\n11.8 \nDebugging \n\nAs you work with bigger datasets it can become unwieldy to debug by printing and check- \ning the output by hand. Here are some suggestions for debugging large datasets: \n\nScale down the input: If possible, reduce the size of the dataset. For example if the pro- \ngram reads a text \ufb01le, start with just the \ufb01rst 10 lines, or with the smallest example \nyou can \ufb01nd. You can either edit the \ufb01les themselves, or (better) modify the program \nso it reads only the \ufb01rst n lines. \n\nIf there is an error, you can reduce n to the smallest value that manifests the error, and \nthen increase it gradually as you \ufb01nd and correct errors. \n\nCheck summaries and types: Instead of printing and checking the entire dataset, consider \nprinting summaries of the data: for example, the number of items in a dictionary or \nthe total of a list of numbers. \n\nA common cause of runtime errors is a value that is not the right type. For debugging \nthis kind of error, it is often enough to print the type of a value. \n\nWrite self-checks: Sometimes you can write code to check for errors automatically. For \nexample, if you are computing the average of a list of numbers, you could check that \nthe result is not greater than the largest element in the list or less than the smallest. \nThis is called a \u201csanity check\u201d because it detects results that are \u201cinsane\u201d. \n\nAnother kind of check compares the results of two different computations to see if \nthey are consistent. This is called a \u201cconsistency check\u201d. \n\n112 \nChapter 11. Dictionaries \n\nFormat the output: Formatting debugging output can make it easier to spot an error. We \nsaw an example in Section 6.9. Another tool you might \ufb01nd useful is the pprint mod- \nule, which provides a pprint function that displays built-in types in a more human- \nreadable format ( pprint stands for \u201cpretty print\u201d). \n\nAgain, time you spend building scaffolding can reduce the time you spend debugging. \n\n11.9 \nGlossary \n\nmapping: A relationship in which each element of one set corresponds to an element of \nanother set. \n\ndictionary: A mapping from keys to their corresponding values. \n\nkey-value pair: The representation of the mapping from a key to a value. \n\nitem: In a dictionary, another name for a key-value pair. \n\nkey: An object that appears in a dictionary as the \ufb01rst part of a key-value pair. \n\nvalue: An object that appears in a dictionary as the second part of a key-value pair. This is \nmore speci\ufb01c than our previous use of the word \u201cvalue\u201d. \n\nimplementation: A way of performing a computation. \n\nhashtable: The algorithm used to implement Python dictionaries. \n\nhash function: A function used by a hashtable to compute the location for a key. \n\nhashable: A type that has a hash function. Immutable types like integers, \ufb02oats and strings \nare hashable; mutable types like lists and dictionaries are not. \n\nlookup: A dictionary operation that takes a key and \ufb01nds the corresponding value. \n\nreverse lookup: A dictionary operation that takes a value and \ufb01nds one or more keys that \nmap to it. \n\nraise statement: A statement that (deliberately) raises an exception. \n\nsingleton: A list (or other sequence) with a single element. \n\ncall graph: A diagram that shows every frame created during the execution of a program, \nwith an arrow from each caller to each callee. \n\nmemo: A computed value stored to avoid unnecessary future computation. \n\nglobal variable: A variable de\ufb01ned outside a function. Global variables can be accessed \nfrom any function. \n\nglobal statement: A statement that declares a variable name global. \n\n\ufb02ag: A boolean variable used to indicate whether a condition is true. \n\ndeclaration: A statement like global that tells the interpreter something about a variable. \n\n11.10. Exercises \n113 \n\n11.10 \nExercises \n\nExercise 11.1. Write a function that reads the words in words.txt and stores them as keys in a \ndictionary. It doesn\u2019t matter what the values are. Then you can use the in operator as a fast way to \ncheck whether a string is in the dictionary. \n\nIf you did Exercise 10.10, you can compare the speed of this implementation with the list in operator \nand the bisection search. \nExercise 11.2. Read the documentation of the dictionary method setdefault and use it to write a \nmore concise version of invert_dict . Solution: https: // thinkpython. com/ code/ invert_ \ndict. py . \nExercise 11.3. Memoize the Ackermann function from Exercise 6.2 and see if memoization \nmakes it possible to evaluate the function with bigger arguments. Hint: no. Solution: https: \n// thinkpython. com/ code/ ackermann_ memo. py . \nExercise 11.4. If you did Exercise 10.7, you already have a function named has_duplicates that \ntakes a list as a parameter and returns True if there is any object that appears more than once in the \nlist. \n\nUse a dictionary to write a faster, simpler version of has_duplicates . Solution: https: // \nthinkpython. com/ code/ has_ duplicates. py . \nExercise 11.5. Two words are \u201crotate pairs\u201d if you can rotate one of them and get the other (see \nrotate_word in Exercise 8.5). \n\nWrite a program that reads a wordlist and \ufb01nds all the rotate pairs. \nSolution: https: // \nthinkpython. com/ code/ rotate_ pairs. py . \nExercise 11.6. Here\u2019s another Puzzler from Car Talk ( http: // www. cartalk. com/ content/ \npuzzlers ): \n\nThis was sent in by a fellow named Dan O\u2019Leary. He came upon a common one-syllable, \n\ufb01ve-letter word recently that has the following unique property. When you remove the \n\ufb01rst letter, the remaining letters form a homophone of the original word, that is a word \nthat sounds exactly the same. Replace the \ufb01rst letter, that is, put it back and remove \nthe second letter and the result is yet another homophone of the original word. And the \nquestion is, what\u2019s the word? \n\nNow I\u2019m going to give you an example that doesn\u2019t work. Let\u2019s look at the \ufb01ve-letter \nword, \u2018wrack.\u2019 W-R-A-C-K, you know like to \u2018wrack with pain.\u2019 If I remove the \ufb01rst \nletter, I am left with a four-letter word, \u2019R-A-C-K.\u2019 As in, \u2018Holy cow, did you see the \nrack on that buck! It must have been a nine-pointer!\u2019 It\u2019s a perfect homophone. If you \nput the \u2018w\u2019 back, and remove the \u2018r,\u2019 instead, you\u2019re left with the word, \u2018wack,\u2019 which is \na real word, it\u2019s just not a homophone of the other two words. \n\nBut there is, however, at least one word that Dan and we know of, which will yield two \nhomophones if you remove either of the \ufb01rst two letters to make two, new four-letter \nwords. The question is, what\u2019s the word? \n\nYou can use the dictionary from Exercise 11.1 to check whether a string is in the word list. \n\nTo \ncheck \nwhether \ntwo \nwords \nare \nhomophones, \nyou \ncan \nuse \nthe \nCMU \nPronouncing \nDictionary. \nYou can download it from http: // www. speech. cs. cmu. edu/ cgi-bin/ \ncmudict \nor from https: // thinkpython. com/ code/ c06d \nand you can also down- \nload https: // thinkpython. com/ code/ pronounce. py , which provides a function named \nread_dictionary that reads the pronouncing dictionary and returns a Python dictionary that \nmaps from each word to a string that describes its primary pronunciation. \n\n114 \nChapter 11. Dictionaries \n\nWrite a program that lists all the words that solve the Puzzler. Solution: https: // thinkpython. \ncom/ code/ homophone. py . \n\n\n## Chapter 12\n\n\n",
  "createdAt": "2026-02-17"
}