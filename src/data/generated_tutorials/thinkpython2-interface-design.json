{
  "title": "interface design",
  "slug": "thinkpython2-interface-design",
  "description": "Module from thinkpython2.pdf: interface design",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# interface design\n\n\n\nThis chapter presents a case study that demonstrates a process for designing functions that \nwork together. \n\nIt introduces the turtle module, which allows you to create images using turtle graphics. \nThe turtle module is included in most Python installations, but if you are running Python \nusing PythonAnywhere, you won\u2019t be able to run the turtle examples (at least you couldn\u2019t \nwhen I wrote this). \n\nIf you have already installed Python on your computer, you should be able to run the \nexamples. Otherwise, now is a good time to install. I have posted instructions at http: \n//tinyurl.com/thinkpython2e . \n\nCode examples from this chapter are available from https://thinkpython.com/code/ \npolygon.py . \n\n4.1 \nThe turtle module \n\nTo check whether you have the turtle module, open the Python interpreter and type \n\n>>> import turtle \n>>> bob = turtle.Turtle() \n\nWhen you run this code, it should create a new window with small arrow that represents \nthe turtle. Close the window. \n\nCreate a \ufb01le named mypolygon.py and type in the following code: \n\nimport turtle \nbob = turtle.Turtle() \nprint(bob) \nturtle.mainloop() \n\nThe turtle module (with a lowercase \u2019t\u2019) provides a function called Turtle (with an up- \npercase \u2019T\u2019) that creates a Turtle object, which we assign to a variable named bob . Printing \nbob displays something like: \n\n<turtle.Turtle object at 0xb7bfbf4c> \n\n30 \nChapter 4. Case study: interface design \n\nThis means that bob refers to an object with type Turtle as de\ufb01ned in module turtle . \n\nmainloop tells the window to wait for the user to do something, although in this case \nthere\u2019s not much for the user to do except close the window. \n\nOnce you create a Turtle, you can call a method to move it around the window. A method \nis similar to a function, but it uses slightly different syntax. For example, to move the turtle \nforward: \n\nbob.fd(100) \n\nThe method, fd , is associated with the turtle object we\u2019re calling bob . Calling a method is \nlike making a request: you are asking bob to move forward. \n\nThe argument of fd is a distance in pixels, so the actual size depends on your display. \n\nOther methods you can call on a Turtle are bk to move backward, lt for left turn, and rt \nright turn. The argument for lt and rt is an angle in degrees. \n\nAlso, each Turtle is holding a pen, which is either down or up; if the pen is down, the Turtle \nleaves a trail when it moves. The methods pu and pd stand for \u201cpen up\u201d and \u201cpen down\u201d. \n\nTo draw a right angle, add these lines to the program (after creating bob and before calling \nmainloop ): \n\nbob.fd(100) \nbob.lt(90) \nbob.fd(100) \n\nWhen you run this program, you should see bob move east and then north, leaving two \nline segments behind. \n\nNow modify the program to draw a square. Don\u2019t go on until you\u2019ve got it working! \n\n4.2 \nSimple repetition \n\nChances are you wrote something like this: \n\nbob.fd(100) \nbob.lt(90) \n\nbob.fd(100) \nbob.lt(90) \n\nbob.fd(100) \nbob.lt(90) \n\nbob.fd(100) \n\nWe can do the same thing more concisely with a for statement. Add this example to \nmypolygon.py and run it again: \n\nfor i in range(4): \nprint('Hello!') \n\nYou should see something like this: \n\n4.3. Exercises \n31 \n\nHello! \nHello! \nHello! \nHello! \nThis is the simplest use of the for statement; we will see more later. But that should be \nenough to let you rewrite your square-drawing program. Don\u2019t go on until you do. \n\nHere is a for statement that draws a square: \nfor i in range(4): \nbob.fd(100) \nbob.lt(90) \nThe syntax of a for statement is similar to a function de\ufb01nition. It has a header that ends \nwith a colon and an indented body. The body can contain any number of statements. \n\nA for statement is also called a loop because the \ufb02ow of execution runs through the body \nand then loops back to the top. In this case, it runs the body four times. \n\nThis version is actually a little different from the previous square-drawing code because it \nmakes another turn after drawing the last side of the square. The extra turn takes more \ntime, but it simpli\ufb01es the code if we do the same thing every time through the loop. This \nversion also has the effect of leaving the turtle back in the starting position, facing in the \nstarting direction. \n\n4.3 \nExercises \n\nThe following is a series of exercises using the turtle module. They are meant to be fun, \nbut they have a point, too. While you are working on them, think about what the point is. \n\nThe following sections have solutions to the exercises, so don\u2019t look until you have \ufb01nished \n(or at least tried). \n\n1. Write a function called square that takes a parameter named t , which is a turtle. It \nshould use the turtle to draw a square. \n\nWrite a function call that passes bob as an argument to square , and then run the \nprogram again. \n\n2. Add another parameter, named length , to square . Modify the body so length of the \nsides is length , and then modify the function call to provide a second argument. Run \nthe program again. Test your program with a range of values for length . \n\n3. Make a copy of square and change the name to polygon . Add another parameter \nnamed n and modify the body so it draws an n-sided regular polygon. Hint: The \nexterior angles of an n-sided regular polygon are 360/ n degrees. \n\n4. Write a function called circle that takes a turtle, t , and radius, r , as parameters and \nthat draws an approximate circle by calling polygon with an appropriate length and \nnumber of sides. Test your function with a range of values of r . \n\nHint: \ufb01gure out the circumference of the circle and make sure that length * n = \ncircumference . \n\n5. Make a more general version of circle called arc that takes an additional parameter \nangle , which determines what fraction of a circle to draw. angle is in units of degrees, \nso when angle=360 , arc should draw a complete circle. \n\n32 \nChapter 4. Case study: interface design \n\n4.4 \nEncapsulation \n\nThe \ufb01rst exercise asks you to put your square-drawing code into a function de\ufb01nition and \nthen call the function, passing the turtle as a parameter. Here is a solution: \n\ndef square(t): \nfor i in range(4): \nt.fd(100) \nt.lt(90) \n\nsquare(bob) \n\nThe innermost statements, fd and lt are indented twice to show that they are inside the \nfor loop, which is inside the function de\ufb01nition. The next line, square(bob) , is \ufb02ush with \nthe left margin, which indicates the end of both the for loop and the function de\ufb01nition. \n\nInside the function, t refers to the same turtle bob , so t.lt(90) has the same effect as \nbob.lt(90) . In that case, why not call the parameter bob ? The idea is that t can be any \nturtle, not just bob , so you could create a second turtle and pass it as an argument to square : \n\nalice = turtle.Turtle() \nsquare(alice) \n\nWrapping a piece of code up in a function is called encapsulation . One of the bene\ufb01ts of \nencapsulation is that it attaches a name to the code, which serves as a kind of documenta- \ntion. Another advantage is that if you re-use the code, it is more concise to call a function \ntwice than to copy and paste the body! \n\n4.5 \nGeneralization \n\nThe next step is to add a length parameter to square . Here is a solution: \n\ndef square(t, length): \nfor i in range(4): \nt.fd(length) \nt.lt(90) \n\nsquare(bob, 100) \n\nAdding a parameter to a function is called generalization because it makes the function \nmore general: in the previous version, the square is always the same size; in this version it \ncan be any size. \n\nThe next step is also a generalization. Instead of drawing squares, polygon draws regular \npolygons with any number of sides. Here is a solution: \n\ndef polygon(t, n, length): \nangle = 360 / n \nfor i in range(n): \nt.fd(length) \nt.lt(angle) \n\npolygon(bob, 7, 70) \n\n4.6. Interface design \n33 \n\nThis example draws a 7-sided polygon with side length 70. \n\nIf you are using Python 2, the value of angle might be off because of integer division. A \nsimple solution is to compute angle = 360.0 / n . Because the numerator is a \ufb02oating- \npoint number, the result is \ufb02oating point. \n\nWhen a function has more than a few numeric arguments, it is easy to forget what they are, \nor what order they should be in. In that case it is often a good idea to include the names of \nthe parameters in the argument list: \n\npolygon(bob, n=7, length=70) \n\nThese are called keyword arguments because they include the parameter names as \u201ckey- \nwords\u201d (not to be confused with Python keywords like while and def ). \n\nThis syntax makes the program more readable. It is also a reminder about how arguments \nand parameters work: when you call a function, the arguments are assigned to the param- \neters. \n\n4.6 \nInterface design \n\nThe next step is to write circle , which takes a radius, r , as a parameter. Here is a simple \nsolution that uses polygon to draw a 50-sided polygon: \n\nimport math \n\ndef circle(t, r): \ncircumference = 2 * math.pi * r \nn = 50 \nlength = circumference / n \npolygon(t, n, length) \n\nThe \ufb01rst line computes the circumference of a circle with radius r using the formula 2 \u03c0 r . \nSince we use math.pi , we have to import math . By convention, import statements are \nusually at the beginning of the script. \n\nn is the number of line segments in our approximation of a circle, so length is the length \nof each segment. Thus, polygon draws a 50-sided polygon that approximates a circle with \nradius r . \n\nOne limitation of this solution is that n is a constant, which means that for very big circles, \nthe line segments are too long, and for small circles, we waste time drawing very small \nsegments. One solution would be to generalize the function by taking n as a parameter. \nThis would give the user (whoever calls circle ) more control, but the interface would be \nless clean. \n\nThe interface of a function is a summary of how it is used: what are the parameters? What \ndoes the function do? And what is the return value? An interface is \u201cclean\u201d if it allows the \ncaller to do what they want without dealing with unnecessary details. \n\nIn this example, r belongs in the interface because it speci\ufb01es the circle to be drawn. n is \nless appropriate because it pertains to the details of how the circle should be rendered. \n\nRather than clutter up the interface, it is better to choose an appropriate value of n depend- \ning on circumference : \n\n34 \nChapter 4. Case study: interface design \n\ndef circle(t, r): \ncircumference = 2 * math.pi * r \nn = int(circumference / 3) + 3 \nlength = circumference / n \npolygon(t, n, length) \n\nNow the number of segments is an integer near circumference/3 , so the length of each \nsegment is approximately 3, which is small enough that the circles look good, but big \nenough to be ef\ufb01cient, and acceptable for any size circle. \n\nAdding 3 to n guarantees that the polygon has at least 3 sides. \n\n4.7 \nRefactoring \n\nWhen I wrote circle , I was able to re-use polygon because a many-sided polygon is a good \napproximation of a circle. But arc is not as cooperative; we can\u2019t use polygon or circle to \ndraw an arc. \n\nOne alternative is to start with a copy of polygon and transform it into arc . The result \nmight look like this: \n\ndef arc(t, r, angle): \narc_length = 2 * math.pi * r * angle / 360 \nn = int(arc_length / 3) + 1 \nstep_length = arc_length / n \nstep_angle = angle / n \n\nfor i in range(n): \nt.fd(step_length) \nt.lt(step_angle) \n\nThe second half of this function looks like polygon , but we can\u2019t re-use polygon without \nchanging the interface. We could generalize polygon to take an angle as a third argument, \nbut then polygon would no longer be an appropriate name! Instead, let\u2019s call the more \ngeneral function polyline : \n\ndef polyline(t, n, length, angle): \nfor i in range(n): \nt.fd(length) \nt.lt(angle) \n\nNow we can rewrite polygon and arc to use polyline : \n\ndef polygon(t, n, length): \nangle = 360.0 / n \npolyline(t, n, length, angle) \n\ndef arc(t, r, angle): \narc_length = 2 * math.pi * r * angle / 360 \nn = int(arc_length / 3) + 1 \nstep_length = arc_length / n \nstep_angle = float(angle) / n \npolyline(t, n, step_length, step_angle) \n\nFinally, we can rewrite circle to use arc : \n\n4.8. A development plan \n35 \n\ndef circle(t, r): \narc(t, r, 360) \n\nThis process\u2014rearranging a program to improve interfaces and facilitate code re-use\u2014is \ncalled refactoring . In this case, we noticed that there was similar code in arc and polygon , \nso we \u201cfactored it out\u201d into polyline . \n\nIf we had planned ahead, we might have written polyline \ufb01rst and avoided refactoring, \nbut often you don\u2019t know enough at the beginning of a project to design all the interfaces. \nOnce you start coding, you understand the problem better. Sometimes refactoring is a sign \nthat you have learned something. \n\n4.8 \nA development plan \n\nA development plan is a process for writing programs. The process we used in this case \nstudy is \u201cencapsulation and generalization\u201d. The steps of this process are: \n\n1. Start by writing a small program with no function de\ufb01nitions. \n\n2. Once you get the program working, identify a coherent piece of it, encapsulate the \npiece in a function and give it a name. \n\n3. Generalize the function by adding appropriate parameters. \n\n4. Repeat steps 1\u20133 until you have a set of working functions. Copy and paste working \ncode to avoid retyping (and re-debugging). \n\n5. Look for opportunities to improve the program by refactoring. For example, if you \nhave similar code in several places, consider factoring it into an appropriately general \nfunction. \n\nThis process has some drawbacks\u2014we will see alternatives later\u2014but it can be useful if \nyou don\u2019t know ahead of time how to divide the program into functions. This approach \nlets you design as you go along. \n\n4.9 \ndocstring \n\nA docstring is a string at the beginning of a function that explains the interface (\u201cdoc\u201d is \nshort for \u201cdocumentation\u201d). Here is an example: \n\ndef polyline(t, n, length, angle): \n\"\"\"Draws n line segments with the given length and \nangle (in degrees) between them. \nt is a turtle. \n\"\"\" \nfor i in range(n): \nt.fd(length) \nt.lt(angle) \n\nBy convention, all docstrings are triple-quoted strings, also known as multiline strings \nbecause the triple quotes allow the string to span more than one line. \n\n36 \nChapter 4. Case study: interface design \n\nIt is terse, but it contains the essential information someone would need to use this func- \ntion. It explains concisely what the function does (without getting into the details of how \nit does it). It explains what effect each parameter has on the behavior of the function and \nwhat type each parameter should be (if it is not obvious). \n\nWriting this kind of documentation is an important part of interface design. \nA well- \ndesigned interface should be simple to explain; if you have a hard time explaining one \nof your functions, maybe the interface could be improved. \n\n4.10 \nDebugging \n\nAn interface is like a contract between a function and a caller. The caller agrees to provide \ncertain parameters and the function agrees to do certain work. \n\nFor example, polyline requires four arguments: t has to be a Turtle; n has to be an integer; \nlength should be a positive number; and angle has to be a number, which is understood \nto be in degrees. \n\nThese requirements are called preconditions because they are supposed to be true before \nthe function starts executing. Conversely, conditions at the end of the function are post- \nconditions . Postconditions include the intended effect of the function (like drawing line \nsegments) and any side effects (like moving the Turtle or making other changes). \n\nPreconditions are the responsibility of the caller. If the caller violates a (properly docu- \nmented!) precondition and the function doesn\u2019t work correctly, the bug is in the caller, not \nthe function. \n\nIf the preconditions are satis\ufb01ed and the postconditions are not, the bug is in the function. \nIf your pre- and postconditions are clear, they can help with debugging. \n\n4.11 \nGlossary \n\nmethod: A function that is associated with an object and called using dot notation. \n\nloop: A part of a program that can run repeatedly. \n\nencapsulation: The process of transforming a sequence of statements into a function de\ufb01- \nnition. \n\ngeneralization: The process of replacing something unnecessarily speci\ufb01c (like a number) \nwith something appropriately general (like a variable or parameter). \n\nkeyword argument: An argument that includes the name of the parameter as a \u201ckey- \nword\u201d. \n\ninterface: A description of how to use a function, including the name and descriptions of \nthe arguments and return value. \n\nrefactoring: The process of modifying a working program to improve function interfaces \nand other qualities of the code. \n\ndevelopment plan: A process for writing programs. \n\n4.12. Exercises \n37 \n\nFigure 4.1: Turtle \ufb02owers. \n\nFigure 4.2: Turtle pies. \n\ndocstring: A string that appears at the top of a function de\ufb01nition to document the func- \ntion\u2019s interface. \n\nprecondition: A requirement that should be satis\ufb01ed by the caller before a function starts. \n\npostcondition: A requirement that should be satis\ufb01ed by the function before it ends. \n\n4.12 \nExercises \n\nExercise 4.1. Download the code in this chapter from https: // thinkpython. com/ code/ \npolygon. py . \n\n1. Draw a stack diagram that shows the state of the program while executing circle(bob, \nradius) . You can do the arithmetic by hand or add print statements to the code. \n\n2. The version of arc in Section 4.7 is not very accurate because the linear approximation of the \ncircle is always outside the true circle. As a result, the Turtle ends up a few pixels away from \nthe correct destination. My solution shows a way to reduce the effect of this error. Read the \ncode and see if it makes sense to you. If you draw a diagram, you might see how it works. \nExercise 4.2. Write an appropriately general set of functions that can draw \ufb02owers as in Figure 4.1. \n\nSolution: \nhttps: // thinkpython. com/ code/ flower. py , \nalso \nrequires \nhttps: \n// thinkpython. com/ code/ polygon. py . \nExercise 4.3. Write an appropriately general set of functions that can draw shapes as in Figure 4.2. \n\nSolution: https: // thinkpython. com/ code/ pie. py . \nExercise 4.4. The letters of the alphabet can be constructed from a moderate number of basic ele- \nments, like vertical and horizontal lines and a few curves. Design an alphabet that can be drawn \nwith a minimal number of basic elements and then write functions that draw the letters. \n\nYou should write one function for each letter, with names draw_a , draw_b , etc., and put your \nfunctions in a \ufb01le named letters.py . You can download a \u201cturtle typewriter\u201d from https: \n// thinkpython. com/ code/ typewriter. py to help you test your code. \n\n38 \nChapter 4. Case study: interface design \n\nYou can get a solution from https: // thinkpython. com/ code/ letters. py ; it also requires \nhttps: // thinkpython. com/ code/ polygon. py . \nExercise 4.5. Read about spirals at http: // en. wikipedia. org/ wiki/ Spiral ; then write \na program that draws an Archimedian spiral (or one of the other kinds). Solution: https: // \nthinkpython. com/ code/ spiral. py . \n\n\n## Chapter 5\n\n\n",
  "createdAt": "2026-02-17"
}