{
  "title": "Functions",
  "slug": "thinkpython2-functions",
  "description": "Module from thinkpython2.pdf: Functions",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Functions\n\n\n\nIn the context of programming, a function is a named sequence of statements that performs a computation. When you de\ufb01ne a function, you specify the name and the sequence of statements. Later, you can \u201ccall\u201d the function by name. \n\n3.1 Function calls \n\nWe have already seen one example of a function call: \n\n>>> type(42) <class 'int'> \n\nThe name of the function is type. The expression in parentheses is called the argument of the function. The result, for this function, is the type of the argument. \n\nIt is common to say that a function \u201ctakes\u201d an argument and \u201creturns\u201d a result. The result is also called the return value. \n\nPython provides functions that convert values from one type to another. The int function takes any value and converts it to an integer, if it can, or complains otherwise: \n\n>>> int('32') 32 >>> int('Hello') ValueError: invalid literal for int(): Hello \n\nint can convert \ufb02oating-point values to integers, but it doesn\u2019t round off; it chops off the fraction part: \n\n>>> int(3.99999) 3 >>> int(-2.3) -2 \n\nfloat converts integers and strings to \ufb02oating-point numbers: \n\n>>> float(32) 32.0 >>> float('3.14159') 3.14159 \n\n18 Chapter 3. Functions \n\nFinally, str converts its argument to a string: \n\n>>> str(32) '32' >>> str(3.14159) '3.14159' \n\n3.2 Math functions \n\nPython has a math module that provides most of the familiar mathematical functions. A module is a \ufb01le that contains a collection of related functions. \n\nBefore we can use the functions in a module, we have to import it with an import state- ment: \n\n>>> import math \n\nThis statement creates a module object named math. If you display the module object, you get some information about it: \n\n>>> math <module 'math' (built-in)> \n\nThe module object contains the functions and variables de\ufb01ned in the module. To access one of the functions, you have to specify the name of the module and the name of the function, separated by a dot (also known as a period). This format is called dot notation. \n\n>>> ratio = signal_power / noise_power >>> decibels = 10 * math.log10(ratio) \n\n>>> radians = 0.7 >>> height = math.sin(radians) \n\nThe \ufb01rst example uses math.log10 to compute a signal-to-noise ratio in decibels (assuming that signal_power and noise_power are de\ufb01ned). The math module also provides log, which computes logarithms base e. \n\nThe second example \ufb01nds the sine of radians. The variable name radians is a hint that sin and the other trigonometric functions (cos, tan, etc.) take arguments in radians. To convert from degrees to radians, divide by 180 and multiply by \u03c0: \n\n>>> degrees = 45 >>> radians = degrees / 180.0 * math.pi >>> math.sin(radians) 0.707106781187 \n\nThe expression math.pi gets the variable pi from the math module. Its value is a \ufb02oating- point approximation of \u03c0, accurate to about 15 digits. \n\nIf you know trigonometry, you can check the previous result by comparing it to the square root of two, divided by two: \n\n>>> math.sqrt(2) / 2.0 0.707106781187 \n\n3.3. Composition 19 \n\n3.3 Composition \n\nSo far, we have looked at the elements of a program\u2014variables, expressions, and statements\u2014in isolation, without talking about how to combine them. \n\nOne of the most useful features of programming languages is their ability to take small building blocks and compose them. For example, the argument of a function can be any kind of expression, including arithmetic operators: \n\nx = math.sin(degrees / 360.0 * 2 * math.pi) \n\nAnd even function calls: \n\nx = math.exp(math.log(x+1)) \n\nAlmost anywhere you can put a value, you can put an arbitrary expression, with one ex- ception: the left side of an assignment statement has to be a variable name. Any other expression on the left side is a syntax error (we will see exceptions to this rule later). \n\n>>> minutes = hours * 60 # right >>> hours * 60 = minutes # wrong! SyntaxError: can't assign to operator \n\n3.4 Adding new functions \n\nSo far, we have only been using the functions that come with Python, but it is also possible to add new functions. A function de\ufb01nition speci\ufb01es the name of a new function and the sequence of statements that run when the function is called. \n\nHere is an example: \n\ndef print_lyrics(): print(\"I'm a lumberjack, and I'm okay.\") print(\"I sleep all night and I work all day.\") \n\ndef is a keyword that indicates that this is a function de\ufb01nition. The name of the function is print_lyrics. The rules for function names are the same as for variable names: letters, numbers and underscore are legal, but the \ufb01rst character can\u2019t be a number. You can\u2019t use a keyword as the name of a function, and you should avoid having a variable and a function with the same name. \n\nThe empty parentheses after the name indicate that this function doesn\u2019t take any argu- ments. \n\nThe \ufb01rst line of the function de\ufb01nition is called the header; the rest is called the body. The header has to end with a colon and the body has to be indented. By convention, indentation is always four spaces. The body can contain any number of statements. \n\nThe strings in the print statements are enclosed in double quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string. \n\nAll quotation marks (single and double) must be \u201cstraight quotes\u201d, usually located next to Enter on the keyboard. \u201cCurly quotes\u201d, like the ones in this sentence, are not legal in Python. \n\nIf you type a function de\ufb01nition in interactive mode, the interpreter prints dots (...) to let you know that the de\ufb01nition isn\u2019t complete: \n\n20 Chapter 3. Functions \n\n>>> def print_lyrics(): ... print(\"I'm a lumberjack, and I'm okay.\") ... print(\"I sleep all night and I work all day.\") ... \n\nTo end the function, you have to enter an empty line. \n\nDe\ufb01ning a function creates a function object, which has type function: \n\n>>> print(print_lyrics) <function print_lyrics at 0xb7e99e9c> >>> type(print_lyrics) <class 'function'> \n\nThe syntax for calling the new function is the same as for built-in functions: \n\n>>> print_lyrics() I'm a lumberjack, and I'm okay. I sleep all night and I work all day. \n\nOnce you have de\ufb01ned a function, you can use it inside another function. For example, to repeat the previous refrain, we could write a function called repeat_lyrics: \n\ndef repeat_lyrics(): print_lyrics() print_lyrics() \n\nAnd then call repeat_lyrics: \n\n>>> repeat_lyrics() I'm a lumberjack, and I'm okay. I sleep all night and I work all day. I'm a lumberjack, and I'm okay. I sleep all night and I work all day. \n\nBut that\u2019s not really how the song goes. \n\n3.5 De\ufb01nitions and uses \n\nPulling together the code fragments from the previous section, the whole program looks like this: \n\ndef print_lyrics(): print(\"I'm a lumberjack, and I'm okay.\") print(\"I sleep all night and I work all day.\") \n\ndef repeat_lyrics(): print_lyrics() print_lyrics() \n\nrepeat_lyrics() \n\nThis program contains two function de\ufb01nitions: print_lyrics and repeat_lyrics. Func- tion de\ufb01nitions get executed just like other statements, but the effect is to create function objects. The statements inside the function do not run until the function is called, and the function de\ufb01nition generates no output. \n\n3.6. Flow of execution 21 \n\nAs you might expect, you have to create a function before you can run it. In other words, the function de\ufb01nition has to run before the function gets called. \n\nAs an exercise, move the last line of this program to the top, so the function call appears before the de\ufb01nitions. Run the program and see what error message you get. \n\nNow move the function call back to the bottom and move the de\ufb01nition of print_lyrics after the de\ufb01nition of repeat_lyrics. What happens when you run this program? \n\n3.6 Flow of execution \n\nTo ensure that a function is de\ufb01ned before its \ufb01rst use, you have to know the order state- ments run in, which is called the \ufb02ow of execution. \n\nExecution always begins at the \ufb01rst statement of the program. Statements are run one at a time, in order from top to bottom. \n\nFunction de\ufb01nitions do not alter the \ufb02ow of execution of the program, but remember that statements inside the function don\u2019t run until the function is called. \n\nA function call is like a detour in the \ufb02ow of execution. Instead of going to the next state- ment, the \ufb02ow jumps to the body of the function, runs the statements there, and then comes back to pick up where it left off. \n\nThat sounds simple enough, until you remember that one function can call another. While in the middle of one function, the program might have to run the statements in another function. Then, while running that new function, the program might have to run yet an- other function! \n\nFortunately, Python is good at keeping track of where it is, so each time a function com- pletes, the program picks up where it left off in the function that called it. When it gets to the end of the program, it terminates. \n\nIn summary, when you read a program, you don\u2019t always want to read from top to bottom. Sometimes it makes more sense if you follow the \ufb02ow of execution. \n\n3.7 Parameters and arguments \n\nSome of the functions we have seen require arguments. For example, when you call math.sin you pass a number as an argument. Some functions take more than one ar- gument: math.pow takes two, the base and the exponent. \n\nInside the function, the arguments are assigned to variables called parameters. Here is a de\ufb01nition for a function that takes an argument: \n\ndef print_twice(bruce): print(bruce) print(bruce) \n\nThis function assigns the argument to a parameter named bruce. When the function is called, it prints the value of the parameter (whatever it is) twice. \n\nThis function works with any value that can be printed. \n\n22 Chapter 3. Functions \n\n>>> print_twice('Spam') Spam Spam >>> print_twice(42) 42 42 >>> print_twice(math.pi) 3.14159265359 3.14159265359 \n\nThe same rules of composition that apply to built-in functions also apply to programmer- de\ufb01ned functions, so we can use any kind of expression as an argument for print_twice: \n\n>>> print_twice('Spam '*4) Spam Spam Spam Spam Spam Spam Spam Spam >>> print_twice(math.cos(math.pi)) -1.0 -1.0 \n\nThe argument is evaluated before the function is called, so in the examples the expressions 'Spam '*4 and math.cos(math.pi) are only evaluated once. \n\nYou can also use a variable as an argument: \n\n>>> michael = 'Eric, the half a bee.' >>> print_twice(michael) Eric, the half a bee. Eric, the half a bee. \n\nThe name of the variable we pass as an argument (michael) has nothing to do with the name of the parameter (bruce). It doesn\u2019t matter what the value was called back home (in the caller); here in print_twice, we call everybody bruce. \n\n3.8 Variables and parameters are local \n\nWhen you create a variable inside a function, it is local, which means that it only exists inside the function. For example: \n\ndef cat_twice(part1, part2): cat = part1 + part2 print_twice(cat) \n\nThis function takes two arguments, concatenates them, and prints the result twice. Here is an example that uses it: \n\n>>> line1 = 'Bing tiddle ' >>> line2 = 'tiddle bang.' >>> cat_twice(line1, line2) Bing tiddle tiddle bang. Bing tiddle tiddle bang. \n\nWhen cat_twice terminates, the variable cat is destroyed. If we try to print it, we get an exception: \n\n3.9. Stack diagrams 23 \n\nline1 \n\nline2 \u2019tiddle bang.\u2019 \n\npart1 \n\npart2 \n\ncat \n\nbruce \n\n\u2019Bing tiddle \u2019 \n\n\u2019Bing tiddle \u2019 \n\n\u2019tiddle bang.\u2019 \n\n\u2019Bing tiddle tiddle bang.\u2019 \n\n\u2019Bing tiddle tiddle bang.\u2019 \n\ncat_twice \n\nprint_twice \n\n__main__ \n\nFigure 3.1: Stack diagram. \n\n>>> print(cat) NameError: name 'cat' is not defined \n\nParameters are also local. For example, outside print_twice, there is no such thing as bruce. \n\n3.9 Stack diagrams \n\nTo keep track of which variables can be used where, it is sometimes useful to draw a stack diagram. Like state diagrams, stack diagrams show the value of each variable, but they also show the function each variable belongs to. \n\nEach function is represented by a frame. A frame is a box with the name of a function beside it and the parameters and variables of the function inside it. The stack diagram for the previous example is shown in Figure 3.1. \n\nThe frames are arranged in a stack that indicates which function called which, and so on. In this example, print_twice was called by cat_twice, and cat_twice was called by __main__, which is a special name for the topmost frame. When you create a variable outside of any function, it belongs to __main__. \n\nEach parameter refers to the same value as its corresponding argument. So, part1 has the same value as line1, part2 has the same value as line2, and bruce has the same value as cat. \n\nIf an error occurs during a function call, Python prints the name of the function, the name of the function that called it, and the name of the function that called that, all the way back to __main__. \n\nFor example, if you try to access cat from within print_twice, you get a NameError: \n\nTraceback (innermost last): File \"test.py\", line 13, in __main__ cat_twice(line1, line2) File \"test.py\", line 5, in cat_twice print_twice(cat) File \"test.py\", line 9, in print_twice print(cat) NameError: name 'cat' is not defined \n\n24 Chapter 3. Functions \n\nThis list of functions is called a traceback. It tells you what program \ufb01le the error occurred in, and what line, and what functions were executing at the time. It also shows the line of code that caused the error. \n\nThe order of the functions in the traceback is the same as the order of the frames in the stack diagram. The function that is currently running is at the bottom. \n\n3.10 Fruitful functions and void functions \n\nSome of the functions we have used, such as the math functions, return results; for lack of a better name, I call them fruitful functions. Other functions, like print_twice, perform an action but don\u2019t return a value. They are called void functions. \n\nWhen you call a fruitful function, you almost always want to do something with the result; for example, you might assign it to a variable or use it as part of an expression: \n\nx = math.cos(radians) golden = (math.sqrt(5) + 1) / 2 \n\nWhen you call a function in interactive mode, Python displays the result: \n\n>>> math.sqrt(5) 2.2360679774997898 \n\nBut in a script, if you call a fruitful function all by itself, the return value is lost forever! \n\nmath.sqrt(5) \n\nThis script computes the square root of 5, but since it doesn\u2019t store or display the result, it is not very useful. \n\nVoid functions might display something on the screen or have some other effect, but they don\u2019t have a return value. If you assign the result to a variable, you get a special value called None. \n\n>>> result = print_twice('Bing') Bing Bing >>> print(result) None \n\nThe value None is not the same as the string 'None'. It is a special value that has its own type: \n\n>>> type(None) <class 'NoneType'> \n\nThe functions we have written so far are all void. We will start writing fruitful functions in a few chapters. \n\n3.11 Why functions? \n\nIt may not be clear why it is worth the trouble to divide a program into functions. There are several reasons: \n\n3.12. Debugging 25 \n\n\u2022 Creating a new function gives you an opportunity to name a group of statements, which makes your program easier to read and debug. \n\n\u2022 Functions can make a program smaller by eliminating repetitive code. Later, if you make a change, you only have to make it in one place. \n\n\u2022 Dividing a long program into functions allows you to debug the parts one at a time and then assemble them into a working whole. \n\n\u2022 Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it. \n\n3.12 Debugging \n\nOne of the most important skills you will acquire is debugging. Although it can be frus- trating, debugging is one of the most intellectually rich, challenging, and interesting parts of programming. \n\nIn some ways debugging is like detective work. You are confronted with clues and you have to infer the processes and events that led to the results you see. \n\nDebugging is also like an experimental science. Once you have an idea about what is going wrong, you modify your program and try again. If your hypothesis was correct, you can predict the result of the modi\ufb01cation, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up with a new one. As Sherlock Holmes pointed out, \u201cWhen you have eliminated the impossible, whatever remains, however im- probable, must be the truth.\u201d (A. Conan Doyle, The Sign of Four) \n\nFor some people, programming and debugging are the same thing. That is, programming is the process of gradually debugging a program until it does what you want. The idea is that you should start with a working program and make small modi\ufb01cations, debugging them as you go. \n\nFor example, Linux is an operating system that contains millions of lines of code, but it started out as a simple program Linus Torvalds used to explore the Intel 80386 chip. Ac- cording to Larry Green\ufb01eld, \u201cOne of Linus\u2019s earlier projects was a program that would switch between printing AAAA and BBBB. This later evolved to Linux.\u201d (The Linux Users\u2019 Guide Beta Version 1). \n\n3.13 Glossary \n\nfunction: A named sequence of statements that performs some useful operation. Func- tions may or may not take arguments and may or may not produce a result. \n\nfunction de\ufb01nition: A statement that creates a new function, specifying its name, param- eters, and the statements it contains. \n\nfunction object: A value created by a function de\ufb01nition. The name of the function is a variable that refers to a function object. \n\nheader: The \ufb01rst line of a function de\ufb01nition. \n\n26 Chapter 3. Functions \n\nbody: The sequence of statements inside a function de\ufb01nition. \n\nparameter: A name used inside a function to refer to the value passed as an argument. \n\nfunction call: A statement that runs a function. It consists of the function name followed by an argument list in parentheses. \n\nargument: A value provided to a function when the function is called. This value is as- signed to the corresponding parameter in the function. \n\nlocal variable: A variable de\ufb01ned inside a function. A local variable can only be used inside its function. \n\nreturn value: The result of a function. If a function call is used as an expression, the return value is the value of the expression. \n\nfruitful function: A function that returns a value. \n\nvoid function: A function that always returns None. \n\nNone: A special value returned by void functions. \n\nmodule: A \ufb01le that contains a collection of related functions and other de\ufb01nitions. \n\nimport statement: A statement that reads a module \ufb01le and creates a module object. \n\nmodule object: A value created by an import statement that provides access to the values de\ufb01ned in a module. \n\ndot notation: The syntax for calling a function in another module by specifying the mod- ule name followed by a dot (period) and the function name. \n\ncomposition: Using an expression as part of a larger expression, or a statement as part of a larger statement. \n\n\ufb02ow of execution: The order statements run in. \n\nstack diagram: A graphical representation of a stack of functions, their variables, and the values they refer to. \n\nframe: A box in a stack diagram that represents a function call. It contains the local vari- ables and parameters of the function. \n\ntraceback: A list of the functions that are executing, printed when an exception occurs. \n\n3.14 Exercises \n\nExercise 3.1. Write a function named right_justify that takes a string named s as a parameter and prints the string with enough leading spaces so that the last letter of the string is in column 70 of the display. \n\n>>> right_justify('monty') monty \n\nHint: Use string concatenation and repetition. Also, Python provides a built-in function called len that returns the length of a string, so the value of len('monty') is 5. \n\n3.14. Exercises 27 \n\nExercise 3.2. A function object is a value you can assign to a variable or pass as an argument. For example, do_twice is a function that takes a function object as an argument and calls it twice: \n\ndef do_twice(f): f() f() \n\nHere\u2019s an example that uses do_twice to call a function named print_spam twice. \n\ndef print_spam(): print('spam') \n\ndo_twice(print_spam) \n\n1. Type this example into a script and test it. \n\n2. Modify do_twice so that it takes two arguments, a function object and a value, and calls the function twice, passing the value as an argument. \n\n3. Copy the de\ufb01nition of print_twice from earlier in this chapter to your script. \n\n4. Use the modi\ufb01ed version of do_twice to call print_twice twice, passing 'spam' as an argument. \n\n5. De\ufb01ne a new function called do_four that takes a function object and a value and calls the function four times, passing the value as a parameter. There should be only two statements in the body of this function, not four. \n\nSolution: https: // thinkpython. com/ code/ do_ four. py . Exercise 3.3. Note: This exercise should be done using only the statements and other features we have learned so far. \n\n1. Write a function that draws a grid like the following: \n\n+ - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + \n\nHint: to print more than one value on a line, you can print a comma-separated sequence of values: \n\nprint('+', '-') \n\nBy default, print advances to the next line, but you can override that behavior and put a space at the end, like this: \n\nprint('+', end=' ') print('-') \n\n28 Chapter 3. Functions \n\nThe output of these statements is '+ -' on the same line. The output from the next print statement would begin on the next line. \n\n2. Write a function that draws a similar grid with four rows and four columns. \n\nSolution: https: // thinkpython. com/ code/ grid. py . Credit: This exercise is based on an exercise in Oualline, Practical C Programming, Third Edition, O\u2019Reilly Media, 1997. \n\n\n## Chapter 4\n\n\n",
  "createdAt": "2026-02-17"
}