{
  "title": "Functions",
  "slug": "thinkpython2-functions",
  "description": "Module from thinkpython2.pdf: Functions",
  "tags": [
    "thinkpython2",
    "Elite"
  ],
  "content": "# Functions\n\n\n\nIn the context of programming, a function is a named sequence of statements that performs \na computation. When you de\ufb01ne a function, you specify the name and the sequence of \nstatements. Later, you can \u201ccall\u201d the function by name. \n\n3.1 \nFunction calls \n\nWe have already seen one example of a function call : \n\n>>> type(42) \n<class 'int'> \n\nThe name of the function is type . The expression in parentheses is called the argument of \nthe function. The result, for this function, is the type of the argument. \n\nIt is common to say that a function \u201ctakes\u201d an argument and \u201creturns\u201d a result. The result \nis also called the return value . \n\nPython provides functions that convert values from one type to another. The int function \ntakes any value and converts it to an integer, if it can, or complains otherwise: \n\n>>> int('32') \n32 \n>>> int('Hello') \nValueError: invalid literal for int(): Hello \n\nint can convert \ufb02oating-point values to integers, but it doesn\u2019t round off; it chops off the \nfraction part: \n\n>>> int(3.99999) \n3 \n>>> int(-2.3) \n-2 \n\nfloat converts integers and strings to \ufb02oating-point numbers: \n\n>>> float(32) \n32.0 \n>>> float('3.14159') \n3.14159 \n\n18 \nChapter 3. Functions \n\nFinally, str converts its argument to a string: \n\n>>> str(32) \n'32' \n>>> str(3.14159) \n'3.14159' \n\n3.2 \nMath functions \n\nPython has a math module that provides most of the familiar mathematical functions. A \nmodule is a \ufb01le that contains a collection of related functions. \n\nBefore we can use the functions in a module, we have to import it with an import state- \nment : \n\n>>> import math \n\nThis statement creates a module object named math. If you display the module object, you \nget some information about it: \n\n>>> math \n<module 'math' (built-in)> \n\nThe module object contains the functions and variables de\ufb01ned in the module. To access \none of the functions, you have to specify the name of the module and the name of the \nfunction, separated by a dot (also known as a period). This format is called dot notation . \n\n>>> ratio = signal_power / noise_power \n>>> decibels = 10 * math.log10(ratio) \n\n>>> radians = 0.7 \n>>> height = math.sin(radians) \n\nThe \ufb01rst example uses math.log10 to compute a signal-to-noise ratio in decibels (assuming \nthat signal_power and noise_power are de\ufb01ned). The math module also provides log , \nwhich computes logarithms base e . \n\nThe second example \ufb01nds the sine of radians . The variable name radians is a hint that \nsin and the other trigonometric functions ( cos , tan , etc.) take arguments in radians. To \nconvert from degrees to radians, divide by 180 and multiply by \u03c0 : \n\n>>> degrees = 45 \n>>> radians = degrees / 180.0 * math.pi \n>>> math.sin(radians) \n0.707106781187 \n\nThe expression math.pi gets the variable pi from the math module. Its value is a \ufb02oating- \npoint approximation of \u03c0 , accurate to about 15 digits. \n\nIf you know trigonometry, you can check the previous result by comparing it to the square \nroot of two, divided by two: \n\n>>> math.sqrt(2) / 2.0 \n0.707106781187 \n\n3.3. Composition \n19 \n\n3.3 \nComposition \n\nSo far, we have looked at the elements of a program\u2014variables, expressions, and \nstatements\u2014in isolation, without talking about how to combine them. \n\nOne of the most useful features of programming languages is their ability to take small \nbuilding blocks and compose them. For example, the argument of a function can be any \nkind of expression, including arithmetic operators: \n\nx = math.sin(degrees / 360.0 * 2 * math.pi) \n\nAnd even function calls: \n\nx = math.exp(math.log(x+1)) \n\nAlmost anywhere you can put a value, you can put an arbitrary expression, with one ex- \nception: the left side of an assignment statement has to be a variable name. Any other \nexpression on the left side is a syntax error (we will see exceptions to this rule later). \n\n>>> minutes = hours * 60 \n# right \n>>> hours * 60 = minutes \n# wrong! \nSyntaxError: can't assign to operator \n\n3.4 \nAdding new functions \n\nSo far, we have only been using the functions that come with Python, but it is also possible \nto add new functions. A function de\ufb01nition speci\ufb01es the name of a new function and the \nsequence of statements that run when the function is called. \n\nHere is an example: \n\ndef print_lyrics(): \nprint(\"I'm a lumberjack, and I'm okay.\") \nprint(\"I sleep all night and I work all day.\") \n\ndef is a keyword that indicates that this is a function de\ufb01nition. The name of the function \nis print_lyrics . The rules for function names are the same as for variable names: letters, \nnumbers and underscore are legal, but the \ufb01rst character can\u2019t be a number. You can\u2019t use a \nkeyword as the name of a function, and you should avoid having a variable and a function \nwith the same name. \n\nThe empty parentheses after the name indicate that this function doesn\u2019t take any argu- \nments. \n\nThe \ufb01rst line of the function de\ufb01nition is called the header ; the rest is called the body . The \nheader has to end with a colon and the body has to be indented. By convention, indentation \nis always four spaces. The body can contain any number of statements. \n\nThe strings in the print statements are enclosed in double quotes. Single quotes and double \nquotes do the same thing; most people use single quotes except in cases like this where a \nsingle quote (which is also an apostrophe) appears in the string. \n\nAll quotation marks (single and double) must be \u201cstraight quotes\u201d, usually located next \nto Enter on the keyboard. \u201cCurly quotes\u201d, like the ones in this sentence, are not legal in \nPython. \n\nIf you type a function de\ufb01nition in interactive mode, the interpreter prints dots ( ... ) to let \nyou know that the de\ufb01nition isn\u2019t complete: \n\n20 \nChapter 3. Functions \n\n>>> def print_lyrics(): \n... \nprint(\"I'm a lumberjack, and I'm okay.\") \n... \nprint(\"I sleep all night and I work all day.\") \n... \n\nTo end the function, you have to enter an empty line. \n\nDe\ufb01ning a function creates a function object , which has type function : \n\n>>> print(print_lyrics) \n<function print_lyrics at 0xb7e99e9c> \n>>> type(print_lyrics) \n<class 'function'> \n\nThe syntax for calling the new function is the same as for built-in functions: \n\n>>> print_lyrics() \nI'm a lumberjack, and I'm okay. \nI sleep all night and I work all day. \n\nOnce you have de\ufb01ned a function, you can use it inside another function. For example, to \nrepeat the previous refrain, we could write a function called repeat_lyrics : \n\ndef repeat_lyrics(): \nprint_lyrics() \nprint_lyrics() \n\nAnd then call repeat_lyrics : \n\n>>> repeat_lyrics() \nI'm a lumberjack, and I'm okay. \nI sleep all night and I work all day. \nI'm a lumberjack, and I'm okay. \nI sleep all night and I work all day. \n\nBut that\u2019s not really how the song goes. \n\n3.5 \nDe\ufb01nitions and uses \n\nPulling together the code fragments from the previous section, the whole program looks \nlike this: \n\ndef print_lyrics(): \nprint(\"I'm a lumberjack, and I'm okay.\") \nprint(\"I sleep all night and I work all day.\") \n\ndef repeat_lyrics(): \nprint_lyrics() \nprint_lyrics() \n\nrepeat_lyrics() \n\nThis program contains two function de\ufb01nitions: print_lyrics and repeat_lyrics . Func- \ntion de\ufb01nitions get executed just like other statements, but the effect is to create function \nobjects. The statements inside the function do not run until the function is called, and the \nfunction de\ufb01nition generates no output. \n\n3.6. Flow of execution \n21 \n\nAs you might expect, you have to create a function before you can run it. In other words, \nthe function de\ufb01nition has to run before the function gets called. \n\nAs an exercise, move the last line of this program to the top, so the function call appears \nbefore the de\ufb01nitions. Run the program and see what error message you get. \n\nNow move the function call back to the bottom and move the de\ufb01nition of print_lyrics \nafter the de\ufb01nition of repeat_lyrics . What happens when you run this program? \n\n3.6 \nFlow of execution \n\nTo ensure that a function is de\ufb01ned before its \ufb01rst use, you have to know the order state- \nments run in, which is called the \ufb02ow of execution . \n\nExecution always begins at the \ufb01rst statement of the program. Statements are run one at a \ntime, in order from top to bottom. \n\nFunction de\ufb01nitions do not alter the \ufb02ow of execution of the program, but remember that \nstatements inside the function don\u2019t run until the function is called. \n\nA function call is like a detour in the \ufb02ow of execution. Instead of going to the next state- \nment, the \ufb02ow jumps to the body of the function, runs the statements there, and then comes \nback to pick up where it left off. \n\nThat sounds simple enough, until you remember that one function can call another. While \nin the middle of one function, the program might have to run the statements in another \nfunction. Then, while running that new function, the program might have to run yet an- \nother function! \n\nFortunately, Python is good at keeping track of where it is, so each time a function com- \npletes, the program picks up where it left off in the function that called it. When it gets to \nthe end of the program, it terminates. \n\nIn summary, when you read a program, you don\u2019t always want to read from top to bottom. \nSometimes it makes more sense if you follow the \ufb02ow of execution. \n\n3.7 \nParameters and arguments \n\nSome of the functions we have seen require arguments. \nFor example, when you call \nmath.sin you pass a number as an argument. Some functions take more than one ar- \ngument: math.pow takes two, the base and the exponent. \n\nInside the function, the arguments are assigned to variables called parameters . Here is a \nde\ufb01nition for a function that takes an argument: \n\ndef print_twice(bruce): \nprint(bruce) \nprint(bruce) \n\nThis function assigns the argument to a parameter named bruce . When the function is \ncalled, it prints the value of the parameter (whatever it is) twice. \n\nThis function works with any value that can be printed. \n\n22 \nChapter 3. Functions \n\n>>> print_twice('Spam') \nSpam \nSpam \n>>> print_twice(42) \n42 \n42 \n>>> print_twice(math.pi) \n3.14159265359 \n3.14159265359 \n\nThe same rules of composition that apply to built-in functions also apply to programmer- \nde\ufb01ned functions, so we can use any kind of expression as an argument for print_twice : \n\n>>> print_twice('Spam '*4) \nSpam Spam Spam Spam \nSpam Spam Spam Spam \n>>> print_twice(math.cos(math.pi)) \n-1.0 \n-1.0 \n\nThe argument is evaluated before the function is called, so in the examples the expressions \n'Spam '*4 and math.cos(math.pi) are only evaluated once. \n\nYou can also use a variable as an argument: \n\n>>> michael = 'Eric, the half a bee.' \n>>> print_twice(michael) \nEric, the half a bee. \nEric, the half a bee. \n\nThe name of the variable we pass as an argument ( michael ) has nothing to do with the \nname of the parameter ( bruce ). It doesn\u2019t matter what the value was called back home (in \nthe caller); here in print_twice , we call everybody bruce . \n\n3.8 \nVariables and parameters are local \n\nWhen you create a variable inside a function, it is local , which means that it only exists \ninside the function. For example: \n\ndef cat_twice(part1, part2): \ncat = part1 + part2 \nprint_twice(cat) \n\nThis function takes two arguments, concatenates them, and prints the result twice. Here is \nan example that uses it: \n\n>>> line1 = 'Bing tiddle ' \n>>> line2 = 'tiddle bang.' \n>>> cat_twice(line1, line2) \nBing tiddle tiddle bang. \nBing tiddle tiddle bang. \n\nWhen cat_twice terminates, the variable cat is destroyed. If we try to print it, we get an \nexception: \n\n3.9. Stack diagrams \n23 \n\nline1 \n\nline2 \n\u2019tiddle bang.\u2019 \n\npart1 \n\npart2 \n\ncat \n\nbruce \n\n\u2019Bing tiddle \u2019 \n\n\u2019Bing tiddle \u2019 \n\n\u2019tiddle bang.\u2019 \n\n\u2019Bing tiddle tiddle bang.\u2019 \n\n\u2019Bing tiddle tiddle bang.\u2019 \n\ncat_twice \n\nprint_twice \n\n__main__ \n\nFigure 3.1: Stack diagram. \n\n>>> print(cat) \nNameError: name 'cat' is not defined \n\nParameters are also local. For example, outside print_twice , there is no such thing as \nbruce . \n\n3.9 \nStack diagrams \n\nTo keep track of which variables can be used where, it is sometimes useful to draw a stack \ndiagram . Like state diagrams, stack diagrams show the value of each variable, but they \nalso show the function each variable belongs to. \n\nEach function is represented by a frame . A frame is a box with the name of a function \nbeside it and the parameters and variables of the function inside it. The stack diagram for \nthe previous example is shown in Figure 3.1. \n\nThe frames are arranged in a stack that indicates which function called which, and so \non. In this example, print_twice was called by cat_twice , and cat_twice was called \nby __main__ , which is a special name for the topmost frame. When you create a variable \noutside of any function, it belongs to __main__ . \n\nEach parameter refers to the same value as its corresponding argument. So, part1 has the \nsame value as line1 , part2 has the same value as line2 , and bruce has the same value as \ncat . \n\nIf an error occurs during a function call, Python prints the name of the function, the name \nof the function that called it, and the name of the function that called that , all the way back \nto __main__ . \n\nFor example, if you try to access cat from within print_twice , you get a NameError : \n\nTraceback (innermost last): \nFile \"test.py\", line 13, in __main__ \ncat_twice(line1, line2) \nFile \"test.py\", line 5, in cat_twice \nprint_twice(cat) \nFile \"test.py\", line 9, in print_twice \nprint(cat) \nNameError: name 'cat' is not defined \n\n24 \nChapter 3. Functions \n\nThis list of functions is called a traceback . It tells you what program \ufb01le the error occurred \nin, and what line, and what functions were executing at the time. It also shows the line of \ncode that caused the error. \n\nThe order of the functions in the traceback is the same as the order of the frames in the \nstack diagram. The function that is currently running is at the bottom. \n\n3.10 \nFruitful functions and void functions \n\nSome of the functions we have used, such as the math functions, return results; for lack of \na better name, I call them fruitful functions . Other functions, like print_twice , perform \nan action but don\u2019t return a value. They are called void functions . \n\nWhen you call a fruitful function, you almost always want to do something with the result; \nfor example, you might assign it to a variable or use it as part of an expression: \n\nx = math.cos(radians) \ngolden = (math.sqrt(5) + 1) / 2 \n\nWhen you call a function in interactive mode, Python displays the result: \n\n>>> math.sqrt(5) \n2.2360679774997898 \n\nBut in a script, if you call a fruitful function all by itself, the return value is lost forever! \n\nmath.sqrt(5) \n\nThis script computes the square root of 5, but since it doesn\u2019t store or display the result, it \nis not very useful. \n\nVoid functions might display something on the screen or have some other effect, but they \ndon\u2019t have a return value. If you assign the result to a variable, you get a special value \ncalled None . \n\n>>> result = print_twice('Bing') \nBing \nBing \n>>> print(result) \nNone \n\nThe value None is not the same as the string 'None' . It is a special value that has its own \ntype: \n\n>>> type(None) \n<class 'NoneType'> \n\nThe functions we have written so far are all void. We will start writing fruitful functions in \na few chapters. \n\n3.11 \nWhy functions? \n\nIt may not be clear why it is worth the trouble to divide a program into functions. There \nare several reasons: \n\n3.12. Debugging \n25 \n\n\u2022 Creating a new function gives you an opportunity to name a group of statements, \nwhich makes your program easier to read and debug. \n\n\u2022 Functions can make a program smaller by eliminating repetitive code. Later, if you \nmake a change, you only have to make it in one place. \n\n\u2022 Dividing a long program into functions allows you to debug the parts one at a time \nand then assemble them into a working whole. \n\n\u2022 Well-designed functions are often useful for many programs. Once you write and \ndebug one, you can reuse it. \n\n3.12 \nDebugging \n\nOne of the most important skills you will acquire is debugging. Although it can be frus- \ntrating, debugging is one of the most intellectually rich, challenging, and interesting parts \nof programming. \n\nIn some ways debugging is like detective work. You are confronted with clues and you \nhave to infer the processes and events that led to the results you see. \n\nDebugging is also like an experimental science. Once you have an idea about what is going \nwrong, you modify your program and try again. If your hypothesis was correct, you can \npredict the result of the modi\ufb01cation, and you take a step closer to a working program. If \nyour hypothesis was wrong, you have to come up with a new one. As Sherlock Holmes \npointed out, \u201cWhen you have eliminated the impossible, whatever remains, however im- \nprobable, must be the truth.\u201d (A. Conan Doyle, The Sign of Four ) \n\nFor some people, programming and debugging are the same thing. That is, programming \nis the process of gradually debugging a program until it does what you want. The idea is \nthat you should start with a working program and make small modi\ufb01cations, debugging \nthem as you go. \n\nFor example, Linux is an operating system that contains millions of lines of code, but it \nstarted out as a simple program Linus Torvalds used to explore the Intel 80386 chip. Ac- \ncording to Larry Green\ufb01eld, \u201cOne of Linus\u2019s earlier projects was a program that would \nswitch between printing AAAA and BBBB. This later evolved to Linux.\u201d ( The Linux Users\u2019 \nGuide Beta Version 1). \n\n3.13 \nGlossary \n\nfunction: A named sequence of statements that performs some useful operation. Func- \ntions may or may not take arguments and may or may not produce a result. \n\nfunction de\ufb01nition: A statement that creates a new function, specifying its name, param- \neters, and the statements it contains. \n\nfunction object: A value created by a function de\ufb01nition. The name of the function is a \nvariable that refers to a function object. \n\nheader: The \ufb01rst line of a function de\ufb01nition. \n\n26 \nChapter 3. Functions \n\nbody: The sequence of statements inside a function de\ufb01nition. \n\nparameter: A name used inside a function to refer to the value passed as an argument. \n\nfunction call: A statement that runs a function. It consists of the function name followed \nby an argument list in parentheses. \n\nargument: A value provided to a function when the function is called. This value is as- \nsigned to the corresponding parameter in the function. \n\nlocal variable: A variable de\ufb01ned inside a function. A local variable can only be used \ninside its function. \n\nreturn value: The result of a function. If a function call is used as an expression, the return \nvalue is the value of the expression. \n\nfruitful function: A function that returns a value. \n\nvoid function: A function that always returns None . \n\nNone : A special value returned by void functions. \n\nmodule: A \ufb01le that contains a collection of related functions and other de\ufb01nitions. \n\nimport statement: A statement that reads a module \ufb01le and creates a module object. \n\nmodule object: A value created by an import statement that provides access to the values \nde\ufb01ned in a module. \n\ndot notation: The syntax for calling a function in another module by specifying the mod- \nule name followed by a dot (period) and the function name. \n\ncomposition: Using an expression as part of a larger expression, or a statement as part of \na larger statement. \n\n\ufb02ow of execution: The order statements run in. \n\nstack diagram: A graphical representation of a stack of functions, their variables, and the \nvalues they refer to. \n\nframe: A box in a stack diagram that represents a function call. It contains the local vari- \nables and parameters of the function. \n\ntraceback: A list of the functions that are executing, printed when an exception occurs. \n\n3.14 \nExercises \n\nExercise 3.1. Write a function named right_justify that takes a string named s as a parameter \nand prints the string with enough leading spaces so that the last letter of the string is in column 70 \nof the display. \n\n>>> right_justify('monty') \nmonty \n\nHint: Use string concatenation and repetition. Also, Python provides a built-in function called len \nthat returns the length of a string, so the value of len('monty') is 5. \n\n3.14. Exercises \n27 \n\nExercise 3.2. A function object is a value you can assign to a variable or pass as an argument. For \nexample, do_twice is a function that takes a function object as an argument and calls it twice: \n\ndef do_twice(f): \nf() \nf() \n\nHere\u2019s an example that uses do_twice to call a function named print_spam twice. \n\ndef print_spam(): \nprint('spam') \n\ndo_twice(print_spam) \n\n1. Type this example into a script and test it. \n\n2. Modify do_twice so that it takes two arguments, a function object and a value, and calls the \nfunction twice, passing the value as an argument. \n\n3. Copy the de\ufb01nition of print_twice from earlier in this chapter to your script. \n\n4. Use the modi\ufb01ed version of do_twice to call print_twice twice, passing 'spam' as an \nargument. \n\n5. De\ufb01ne a new function called do_four that takes a function object and a value and calls the \nfunction four times, passing the value as a parameter. There should be only two statements in \nthe body of this function, not four. \n\nSolution: https: // thinkpython. com/ code/ do_ four. py . \nExercise 3.3. Note: This exercise should be done using only the statements and other features we \nhave learned so far. \n\n1. Write a function that draws a grid like the following: \n\n+ - - - - + - - - - + \n| \n| \n| \n| \n| \n| \n| \n| \n| \n| \n| \n| \n+ - - - - + - - - - + \n| \n| \n| \n| \n| \n| \n| \n| \n| \n| \n| \n| \n+ - - - - + - - - - + \n\nHint: to print more than one value on a line, you can print a comma-separated sequence of \nvalues: \n\nprint('+', '-') \n\nBy default, print advances to the next line, but you can override that behavior and put a \nspace at the end, like this: \n\nprint('+', end=' ') \nprint('-') \n\n28 \nChapter 3. Functions \n\nThe output of these statements is '+ -' on the same line. The output from the next print \nstatement would begin on the next line. \n\n2. Write a function that draws a similar grid with four rows and four columns. \n\nSolution: https: // thinkpython. com/ code/ grid. py . Credit: This exercise is based on an \nexercise in Oualline, Practical C Programming, Third Edition , O\u2019Reilly Media, 1997. \n\n\n## Chapter 4\n\n\n",
  "createdAt": "2026-02-17"
}